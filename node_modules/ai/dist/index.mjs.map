{"version":3,"sources":["../core/index.ts","../core/data-stream/create-data-stream.ts","../core/util/prepare-response-headers.ts","../core/data-stream/create-data-stream-response.ts","../core/util/prepare-outgoing-http-headers.ts","../core/util/write-to-server-response.ts","../core/data-stream/pipe-data-stream-to-response.ts","../errors/invalid-argument-error.ts","../util/retry-with-exponential-backoff.ts","../util/retry-error.ts","../core/prompt/prepare-retries.ts","../core/telemetry/assemble-operation-name.ts","../core/telemetry/get-base-telemetry-attributes.ts","../core/telemetry/get-tracer.ts","../core/telemetry/noop-tracer.ts","../core/telemetry/record-span.ts","../core/telemetry/select-telemetry-attributes.ts","../core/embed/embed.ts","../core/util/split-array.ts","../core/embed/embed-many.ts","../errors/no-image-generated-error.ts","../core/generate-text/generated-file.ts","../core/util/detect-mimetype.ts","../core/generate-image/generate-image.ts","../core/generate-object/generate-object.ts","../errors/no-object-generated-error.ts","../util/download-error.ts","../util/download.ts","../core/prompt/data-content.ts","../core/prompt/invalid-data-content-error.ts","../core/prompt/invalid-message-role-error.ts","../core/prompt/split-data-url.ts","../core/prompt/convert-to-language-model-prompt.ts","../core/prompt/prepare-call-settings.ts","../core/prompt/standardize-prompt.ts","../core/prompt/attachments-to-parts.ts","../core/prompt/message-conversion-error.ts","../core/prompt/convert-to-core-messages.ts","../core/prompt/message.ts","../core/types/provider-metadata.ts","../core/types/json-value.ts","../core/prompt/content-part.ts","../core/prompt/tool-result-content.ts","../core/types/usage.ts","../core/generate-object/inject-json-instruction.ts","../core/generate-object/output-strategy.ts","../core/util/async-iterable-stream.ts","../core/generate-object/validate-object-generation-input.ts","../core/prompt/stringify-for-telemetry.ts","../core/generate-object/stream-object.ts","../util/delayed-promise.ts","../util/create-resolvable-promise.ts","../core/util/create-stitchable-stream.ts","../core/util/now.ts","../core/generate-text/generate-text.ts","../errors/no-output-specified-error.ts","../errors/tool-execution-error.ts","../core/prompt/prepare-tools-and-tool-choice.ts","../core/util/is-non-empty-object.ts","../core/util/split-on-last-whitespace.ts","../core/util/remove-text-after-last-whitespace.ts","../core/generate-text/parse-tool-call.ts","../errors/invalid-tool-arguments-error.ts","../errors/no-such-tool-error.ts","../errors/tool-call-repair-error.ts","../core/generate-text/reasoning-detail.ts","../core/generate-text/to-response-messages.ts","../core/generate-text/output.ts","../errors/index.ts","../errors/invalid-stream-part-error.ts","../errors/mcp-client-error.ts","../core/generate-text/smooth-stream.ts","../core/generate-text/stream-text.ts","../util/as-array.ts","../util/consume-stream.ts","../core/util/merge-streams.ts","../core/generate-text/run-tools-transformation.ts","../errors/no-speech-generated-error.ts","../core/generate-speech/generated-audio-file.ts","../core/generate-speech/generate-speech.ts","../errors/no-transcript-generated-error.ts","../core/transcribe/transcribe.ts","../core/util/merge-objects.ts","../core/middleware/default-settings-middleware.ts","../core/util/get-potential-start-index.ts","../core/middleware/extract-reasoning-middleware.ts","../core/middleware/simulate-streaming-middleware.ts","../core/middleware/wrap-language-model.ts","../core/prompt/append-client-message.ts","../core/prompt/append-response-messages.ts","../core/registry/custom-provider.ts","../core/registry/no-such-provider-error.ts","../core/registry/provider-registry.ts","../core/tool/mcp/mcp-client.ts","../core/tool/tool.ts","../core/tool/mcp/mcp-sse-transport.ts","../core/tool/mcp/json-rpc-message.ts","../core/tool/mcp/types.ts","../core/tool/mcp/mcp-transport.ts","../core/util/cosine-similarity.ts","../core/util/simulate-readable-stream.ts","../streams/assistant-response.ts","../streams/langchain-adapter.ts","../streams/stream-callbacks.ts","../streams/llamaindex-adapter.ts","../streams/stream-data.ts","../util/constants.ts"],"sourcesContent":["// re-exports:\nexport { createIdGenerator, generateId } from '@ai-sdk/provider-utils';\nexport type { IDGenerator } from '@ai-sdk/provider-utils';\nexport {\n  formatAssistantStreamPart,\n  formatDataStreamPart,\n  jsonSchema,\n  parseAssistantStreamPart,\n  parseDataStreamPart,\n  processDataStream,\n  processTextStream,\n  zodSchema,\n} from '@ai-sdk/ui-utils';\nexport type {\n  AssistantMessage,\n  AssistantStatus,\n  Attachment,\n  ChatRequest,\n  ChatRequestOptions,\n  CreateMessage,\n  DataMessage,\n  DataStreamPart,\n  DeepPartial,\n  IdGenerator,\n  JSONValue,\n  Message,\n  UIMessage,\n  RequestOptions,\n  Schema,\n  ToolInvocation,\n  UseAssistantOptions,\n} from '@ai-sdk/ui-utils';\n\n// directory exports:\nexport * from './data-stream';\nexport * from './embed';\nexport * from './generate-image';\nexport * from './generate-object';\nexport * from './generate-text';\nexport * from './generate-speech';\nexport * from './transcribe';\nexport * from './middleware';\nexport * from './prompt';\nexport * from './registry';\nexport * from './tool';\nexport * from './types';\n\n// telemetry types:\nexport type { TelemetrySettings } from './telemetry/telemetry-settings';\n\n// util exports:\nexport { cosineSimilarity } from './util/cosine-similarity';\nexport { simulateReadableStream } from './util/simulate-readable-stream';\n","import { DataStreamString, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function createDataStream({\n  execute,\n  onError = () => 'An error occurred.', // mask error messages for safety by default\n}: {\n  execute: (dataStream: DataStreamWriter) => Promise<void> | void;\n  onError?: (error: unknown) => string;\n}): ReadableStream<DataStreamString> {\n  let controller!: ReadableStreamDefaultController<string>;\n\n  const ongoingStreamPromises: Promise<void>[] = [];\n\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    },\n  });\n\n  function safeEnqueue(data: DataStreamString) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  }\n\n  try {\n    const result = execute({\n      write(data: DataStreamString) {\n        safeEnqueue(data);\n      },\n      writeData(data) {\n        safeEnqueue(formatDataStreamPart('data', [data]));\n      },\n      writeMessageAnnotation(annotation) {\n        safeEnqueue(formatDataStreamPart('message_annotations', [annotation]));\n      },\n      writeSource(source) {\n        safeEnqueue(formatDataStreamPart('source', source));\n      },\n      merge(streamArg) {\n        ongoingStreamPromises.push(\n          (async () => {\n            const reader = streamArg.getReader();\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              safeEnqueue(value);\n            }\n          })().catch(error => {\n            safeEnqueue(formatDataStreamPart('error', onError(error)));\n          }),\n        );\n      },\n      onError,\n    });\n\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch(error => {\n          safeEnqueue(formatDataStreamPart('error', onError(error)));\n        }),\n      );\n    }\n  } catch (error) {\n    safeEnqueue(formatDataStreamPart('error', onError(error)));\n  }\n\n  // Wait until all ongoing streams are done. This approach enables merging\n  // streams even after execute has returned, as long as there is still an\n  // open merged stream. This is important to e.g. forward new streams and\n  // from callbacks.\n  const waitForStreams: Promise<void> = new Promise(async resolve => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve();\n  });\n\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  });\n\n  return stream;\n}\n","export function prepareResponseHeaders(\n  headers: HeadersInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const responseHeaders = new Headers(headers ?? {});\n\n  if (!responseHeaders.has('Content-Type')) {\n    responseHeaders.set('Content-Type', contentType);\n  }\n\n  if (dataStreamVersion !== undefined) {\n    responseHeaders.set('X-Vercel-AI-Data-Stream', dataStreamVersion);\n  }\n\n  return responseHeaders;\n}\n","import { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { createDataStream } from './create-data-stream';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function createDataStreamResponse({\n  status,\n  statusText,\n  headers,\n  execute,\n  onError,\n}: ResponseInit & {\n  execute: (dataStream: DataStreamWriter) => Promise<void> | void;\n  onError?: (error: unknown) => string;\n}): Response {\n  return new Response(\n    createDataStream({ execute, onError }).pipeThrough(new TextEncoderStream()),\n    {\n      status,\n      statusText,\n      headers: prepareResponseHeaders(headers, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n    },\n  );\n}\n","export function prepareOutgoingHttpHeaders(\n  headers: HeadersInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const outgoingHeaders: Record<string, string | number | string[]> = {};\n\n  if (headers != null) {\n    for (const [key, value] of Object.entries(headers)) {\n      outgoingHeaders[key] = value;\n    }\n  }\n\n  if (outgoingHeaders['Content-Type'] == null) {\n    outgoingHeaders['Content-Type'] = contentType;\n  }\n\n  if (dataStreamVersion !== undefined) {\n    outgoingHeaders['X-Vercel-AI-Data-Stream'] = dataStreamVersion;\n  }\n\n  return outgoingHeaders;\n}\n","import { ServerResponse } from 'node:http';\n\n/**\n * Writes the content of a stream to a server response.\n */\nexport function writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n}: {\n  response: ServerResponse;\n  status?: number;\n  statusText?: string;\n  headers?: Record<string, string | number | string[]>;\n  stream: ReadableStream<Uint8Array>;\n}): void {\n  response.writeHead(status ?? 200, statusText, headers);\n\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n\n  read();\n}\n","import { ServerResponse } from 'node:http';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { createDataStream } from './create-data-stream';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function pipeDataStreamToResponse(\n  response: ServerResponse,\n  {\n    status,\n    statusText,\n    headers,\n    execute,\n    onError,\n  }: ResponseInit & {\n    execute: (writer: DataStreamWriter) => Promise<void> | void;\n    onError?: (error: unknown) => string;\n  },\n): void {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: prepareOutgoingHttpHeaders(headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n    stream: createDataStream({ execute, onError }).pipeThrough(\n      new TextEncoderStream(),\n    ),\n  });\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly parameter: string;\n  readonly value: unknown;\n\n  constructor({\n    parameter,\n    value,\n    message,\n  }: {\n    parameter: string;\n    value: unknown;\n    message: string;\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`,\n    });\n\n    this.parameter = parameter;\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { delay, getErrorMessage, isAbortError } from '@ai-sdk/provider-utils';\nimport { RetryError } from './retry-error';\n\nexport type RetryFunction = <OUTPUT>(\n  fn: () => PromiseLike<OUTPUT>,\n) => PromiseLike<OUTPUT>;\n\n/**\nThe `retryWithExponentialBackoff` strategy retries a failed API call with an exponential backoff.\nYou can configure the maximum number of retries, the initial delay, and the backoff factor.\n */\nexport const retryWithExponentialBackoff =\n  ({\n    maxRetries = 2,\n    initialDelayInMs = 2000,\n    backoffFactor = 2,\n  } = {}): RetryFunction =>\n  async <OUTPUT>(f: () => PromiseLike<OUTPUT>) =>\n    _retryWithExponentialBackoff(f, {\n      maxRetries,\n      delayInMs: initialDelayInMs,\n      backoffFactor,\n    });\n\nasync function _retryWithExponentialBackoff<OUTPUT>(\n  f: () => PromiseLike<OUTPUT>,\n  {\n    maxRetries,\n    delayInMs,\n    backoffFactor,\n  }: { maxRetries: number; delayInMs: number; backoffFactor: number },\n  errors: unknown[] = [],\n): Promise<OUTPUT> {\n  try {\n    return await f();\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error; // don't retry when the request was aborted\n    }\n\n    if (maxRetries === 0) {\n      throw error; // don't wrap the error when retries are disabled\n    }\n\n    const errorMessage = getErrorMessage(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: 'maxRetriesExceeded',\n        errors: newErrors,\n      });\n    }\n\n    if (\n      error instanceof Error &&\n      APICallError.isInstance(error) &&\n      error.isRetryable === true &&\n      tryNumber <= maxRetries\n    ) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors,\n      );\n    }\n\n    if (tryNumber === 1) {\n      throw error; // don't wrap the error when a non-retryable error occurs on the first try\n    }\n\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: 'errorNotRetryable',\n      errors: newErrors,\n    });\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_RetryError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport type RetryErrorReason =\n  | 'maxRetriesExceeded'\n  | 'errorNotRetryable'\n  | 'abort';\n\nexport class RetryError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  // note: property order determines debugging output\n  readonly reason: RetryErrorReason;\n  readonly lastError: unknown;\n  readonly errors: Array<unknown>;\n\n  constructor({\n    message,\n    reason,\n    errors,\n  }: {\n    message: string;\n    reason: RetryErrorReason;\n    errors: Array<unknown>;\n  }) {\n    super({ name, message });\n\n    this.reason = reason;\n    this.errors = errors;\n\n    // separate our last error to make debugging via log easier:\n    this.lastError = errors[errors.length - 1];\n  }\n\n  static isInstance(error: unknown): error is RetryError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport {\n  RetryFunction,\n  retryWithExponentialBackoff,\n} from '../../util/retry-with-exponential-backoff';\n\n/**\n * Validate and prepare retries.\n */\nexport function prepareRetries({\n  maxRetries,\n}: {\n  maxRetries: number | undefined;\n}): {\n  maxRetries: number;\n  retry: RetryFunction;\n} {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be an integer',\n      });\n    }\n\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be >= 0',\n      });\n    }\n  }\n\n  const maxRetriesResult = maxRetries ?? 2;\n\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult }),\n  };\n}\n","import { TelemetrySettings } from './telemetry-settings';\n\nexport function assembleOperationName({\n  operationId,\n  telemetry,\n}: {\n  operationId: string;\n  telemetry?: TelemetrySettings;\n}) {\n  return {\n    // standardized operation and resource name:\n    'operation.name': `${operationId}${\n      telemetry?.functionId != null ? ` ${telemetry.functionId}` : ''\n    }`,\n    'resource.name': telemetry?.functionId,\n\n    // detailed, AI SDK specific data:\n    'ai.operationId': operationId,\n    'ai.telemetry.functionId': telemetry?.functionId,\n  };\n}\n","import { Attributes } from '@opentelemetry/api';\nimport { CallSettings } from '../prompt/call-settings';\nimport { TelemetrySettings } from './telemetry-settings';\n\nexport function getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers,\n}: {\n  model: { modelId: string; provider: string };\n  settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n  telemetry: TelemetrySettings | undefined;\n  headers: Record<string, string | undefined> | undefined;\n}): Attributes {\n  return {\n    'ai.model.provider': model.provider,\n    'ai.model.id': model.modelId,\n\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {} as Attributes),\n\n    // add metadata as attributes:\n    ...Object.entries(telemetry?.metadata ?? {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {} as Attributes,\n    ),\n\n    // request headers\n    ...Object.entries(headers ?? {}).reduce((attributes, [key, value]) => {\n      if (value !== undefined) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {} as Attributes),\n  };\n}\n","import { Tracer, trace } from '@opentelemetry/api';\nimport { noopTracer } from './noop-tracer';\n\nexport function getTracer({\n  isEnabled = false,\n  tracer,\n}: {\n  isEnabled?: boolean;\n  tracer?: Tracer;\n} = {}): Tracer {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n\n  if (tracer) {\n    return tracer;\n  }\n\n  return trace.getTracer('ai');\n}\n","import { Span, SpanContext, Tracer } from '@opentelemetry/api';\n\n/**\n * Tracer implementation that does nothing (null object).\n */\nexport const noopTracer: Tracer = {\n  startSpan(): Span {\n    return noopSpan;\n  },\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: unknown,\n    arg1: unknown,\n    arg2?: unknown,\n    arg3?: F,\n  ): ReturnType<any> {\n    if (typeof arg1 === 'function') {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === 'function') {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === 'function') {\n      return arg3(noopSpan);\n    }\n  },\n};\n\nconst noopSpan: Span = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  },\n};\n\nconst noopSpanContext: SpanContext = {\n  traceId: '',\n  spanId: '',\n  traceFlags: 0,\n};\n","import { Attributes, Span, Tracer, SpanStatusCode } from '@opentelemetry/api';\n\nexport function recordSpan<T>({\n  name,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true,\n}: {\n  name: string;\n  tracer: Tracer;\n  attributes: Attributes;\n  fn: (span: Span) => Promise<T>;\n  endWhenDone?: boolean;\n}) {\n  return tracer.startActiveSpan(name, { attributes }, async span => {\n    try {\n      const result = await fn(span);\n\n      if (endWhenDone) {\n        span.end();\n      }\n\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          });\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: error.message,\n          });\n        } else {\n          span.setStatus({ code: SpanStatusCode.ERROR });\n        }\n      } finally {\n        // always stop the span when there is an error:\n        span.end();\n      }\n\n      throw error;\n    }\n  });\n}\n","import type { Attributes, AttributeValue } from '@opentelemetry/api';\nimport type { TelemetrySettings } from './telemetry-settings';\n\nexport function selectTelemetryAttributes({\n  telemetry,\n  attributes,\n}: {\n  telemetry?: TelemetrySettings;\n  attributes: {\n    [attributeKey: string]:\n      | AttributeValue\n      | { input: () => AttributeValue | undefined }\n      | { output: () => AttributeValue | undefined }\n      | undefined;\n  };\n}): Attributes {\n  // when telemetry is disabled, return an empty object to avoid serialization overhead:\n  if (telemetry?.isEnabled !== true) {\n    return {};\n  }\n\n  return Object.entries(attributes).reduce((attributes, [key, value]) => {\n    if (value === undefined) {\n      return attributes;\n    }\n\n    // input value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'input' in value &&\n      typeof value.input === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordInputs === false) {\n        return attributes;\n      }\n\n      const result = value.input();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // output value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'output' in value &&\n      typeof value.output === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordOutputs === false) {\n        return attributes;\n      }\n\n      const result = value.output();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // value is an attribute value already:\n    return { ...attributes, [key]: value };\n  }, {});\n}\n","import { prepareRetries } from '../prompt/prepare-retries';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { EmbeddingModel } from '../types';\nimport { EmbedResult } from './embed-result';\n\n/**\nEmbed a value using an embedding model. The type of the value is defined by the embedding model.\n\n@param model - The embedding model to use.\n@param value - The value that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embedding, the value, and additional information.\n */\nexport async function embed<VALUE>({\n  model,\n  value,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe value that should be embedded.\n   */\n  value: VALUE;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedResult<VALUE>> {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embed',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embed', telemetry }),\n        ...baseTelemetryAttributes,\n        'ai.value': { input: () => JSON.stringify(value) },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const { embedding, usage, rawResponse } = await retry(() =>\n        // nested spans to align with the embedMany telemetry data:\n        recordSpan({\n          name: 'ai.embed.doEmbed',\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: 'ai.embed.doEmbed',\n                telemetry,\n              }),\n              ...baseTelemetryAttributes,\n              // specific settings that only make sense on the outer level:\n              'ai.values': { input: () => [JSON.stringify(value)] },\n            },\n          }),\n          tracer,\n          fn: async doEmbedSpan => {\n            const modelResponse = await model.doEmbed({\n              values: [value],\n              abortSignal,\n              headers,\n            });\n\n            const embedding = modelResponse.embeddings[0];\n            const usage = modelResponse.usage ?? { tokens: NaN };\n\n            doEmbedSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  'ai.embeddings': {\n                    output: () =>\n                      modelResponse.embeddings.map(embedding =>\n                        JSON.stringify(embedding),\n                      ),\n                  },\n                  'ai.usage.tokens': usage.tokens,\n                },\n              }),\n            );\n\n            return {\n              embedding,\n              usage,\n              rawResponse: modelResponse.rawResponse,\n            };\n          },\n        }),\n      );\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embedding': { output: () => JSON.stringify(embedding) },\n            'ai.usage.tokens': usage.tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    },\n  });\n}\n\nclass DefaultEmbedResult<VALUE> implements EmbedResult<VALUE> {\n  readonly value: EmbedResult<VALUE>['value'];\n  readonly embedding: EmbedResult<VALUE>['embedding'];\n  readonly usage: EmbedResult<VALUE>['usage'];\n  readonly rawResponse: EmbedResult<VALUE>['rawResponse'];\n\n  constructor(options: {\n    value: EmbedResult<VALUE>['value'];\n    embedding: EmbedResult<VALUE>['embedding'];\n    usage: EmbedResult<VALUE>['usage'];\n    rawResponse?: EmbedResult<VALUE>['rawResponse'];\n  }) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n}\n","/**\n * Splits an array into chunks of a specified size.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to split.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {T[][]} - A new array containing the chunks.\n */\nexport function splitArray<T>(array: T[], chunkSize: number): T[][] {\n  if (chunkSize <= 0) {\n    throw new Error('chunkSize must be greater than 0');\n  }\n\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n","import { prepareRetries } from '../prompt/prepare-retries';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { Embedding, EmbeddingModel } from '../types';\nimport { splitArray } from '../util/split-array';\nimport { EmbedManyResult } from './embed-many-result';\n\n/**\nEmbed several values using an embedding model. The type of the value is defined\nby the embedding model.\n\n`embedMany` automatically splits large requests into smaller chunks if the model\nhas a limit on how many embeddings can be generated in a single call.\n\n@param model - The embedding model to use.\n@param values - The values that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embeddings, the value, and additional information.\n */\nexport async function embedMany<VALUE>({\n  model,\n  values,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe values that should be embedded.\n   */\n  values: Array<VALUE>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedManyResult<VALUE>> {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embedMany',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embedMany', telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.values': {\n          input: () => values.map(value => JSON.stringify(value)),\n        },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n\n      // the model has not specified limits on\n      // how many embeddings can be generated in a single call\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => values.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              'ai.embeddings': {\n                output: () =>\n                  embeddings.map(embedding => JSON.stringify(embedding)),\n              },\n              'ai.usage.tokens': usage.tokens,\n            },\n          }),\n        );\n\n        return new DefaultEmbedManyResult({ values, embeddings, usage });\n      }\n\n      // split the values into chunks that are small enough for the model:\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n\n      // serially embed the chunks:\n      const embeddings: Array<Embedding> = [];\n      let tokens = 0;\n\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => chunk.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embeddings': {\n              output: () =>\n                embeddings.map(embedding => JSON.stringify(embedding)),\n            },\n            'ai.usage.tokens': tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n      });\n    },\n  });\n}\n\nclass DefaultEmbedManyResult<VALUE> implements EmbedManyResult<VALUE> {\n  readonly values: EmbedManyResult<VALUE>['values'];\n  readonly embeddings: EmbedManyResult<VALUE>['embeddings'];\n  readonly usage: EmbedManyResult<VALUE>['usage'];\n\n  constructor(options: {\n    values: EmbedManyResult<VALUE>['values'];\n    embeddings: EmbedManyResult<VALUE>['embeddings'];\n    usage: EmbedManyResult<VALUE>['usage'];\n  }) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { ImageModelResponseMetadata } from '../core/types/image-model-response-metadata';\n\nconst name = 'AI_NoImageGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no image could be generated. This can have multiple causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n */\nexport class NoImageGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\nThe response metadata for each call.\n   */\n  readonly responses: Array<ImageModelResponseMetadata> | undefined;\n\n  constructor({\n    message = 'No image generated.',\n    cause,\n    responses,\n  }: {\n    message?: string;\n    cause?: Error;\n    responses?: Array<ImageModelResponseMetadata>;\n  }) {\n    super({ name, message, cause });\n\n    this.responses = responses;\n  }\n\n  static isInstance(error: unknown): error is NoImageGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\n\n/**\n * A generated file.\n */\nexport interface GeneratedFile {\n  /**\nFile as a base64 encoded string.\n     */\n  readonly base64: string;\n\n  /**\nFile as a Uint8Array.\n     */\n  readonly uint8Array: Uint8Array;\n\n  /**\nMIME type of the file\n   */\n  readonly mimeType: string;\n}\n\nexport class DefaultGeneratedFile implements GeneratedFile {\n  private base64Data: string | undefined;\n  private uint8ArrayData: Uint8Array | undefined;\n\n  readonly mimeType: string;\n\n  constructor({\n    data,\n    mimeType,\n  }: {\n    data: string | Uint8Array;\n    mimeType: string;\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? undefined : data;\n    this.uint8ArrayData = isUint8Array ? data : undefined;\n    this.mimeType = mimeType;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData!);\n    }\n    return this.base64Data;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data!);\n    }\n    return this.uint8ArrayData;\n  }\n}\n\nexport class DefaultGeneratedFileWithType extends DefaultGeneratedFile {\n  readonly type = 'file';\n\n  constructor(options: { data: string | Uint8Array; mimeType: string }) {\n    super(options);\n  }\n}\n","import { convertBase64ToUint8Array } from '@ai-sdk/provider-utils';\n\nexport const imageMimeTypeSignatures = [\n  {\n    mimeType: 'image/gif' as const,\n    bytesPrefix: [0x47, 0x49, 0x46],\n    base64Prefix: 'R0lG',\n  },\n  {\n    mimeType: 'image/png' as const,\n    bytesPrefix: [0x89, 0x50, 0x4e, 0x47],\n    base64Prefix: 'iVBORw',\n  },\n  {\n    mimeType: 'image/jpeg' as const,\n    bytesPrefix: [0xff, 0xd8],\n    base64Prefix: '/9j/',\n  },\n  {\n    mimeType: 'image/webp' as const,\n    bytesPrefix: [0x52, 0x49, 0x46, 0x46],\n    base64Prefix: 'UklGRg',\n  },\n  {\n    mimeType: 'image/bmp' as const,\n    bytesPrefix: [0x42, 0x4d],\n    base64Prefix: 'Qk',\n  },\n  {\n    mimeType: 'image/tiff' as const,\n    bytesPrefix: [0x49, 0x49, 0x2a, 0x00],\n    base64Prefix: 'SUkqAA',\n  },\n  {\n    mimeType: 'image/tiff' as const,\n    bytesPrefix: [0x4d, 0x4d, 0x00, 0x2a],\n    base64Prefix: 'TU0AKg',\n  },\n  {\n    mimeType: 'image/avif' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66,\n    ],\n    base64Prefix: 'AAAAIGZ0eXBhdmlm',\n  },\n  {\n    mimeType: 'image/heic' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63,\n    ],\n    base64Prefix: 'AAAAIGZ0eXBoZWlj',\n  },\n] as const;\n\nexport const audioMimeTypeSignatures = [\n  {\n    mimeType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xfb],\n    base64Prefix: '//s=',\n  },\n  {\n    mimeType: 'audio/wav' as const,\n    bytesPrefix: [0x52, 0x49, 0x46, 0x46],\n    base64Prefix: 'UklGR',\n  },\n  {\n    mimeType: 'audio/ogg' as const,\n    bytesPrefix: [0x4f, 0x67, 0x67, 0x53],\n    base64Prefix: 'T2dnUw',\n  },\n  {\n    mimeType: 'audio/flac' as const,\n    bytesPrefix: [0x66, 0x4c, 0x61, 0x43],\n    base64Prefix: 'ZkxhQw',\n  },\n  {\n    mimeType: 'audio/aac' as const,\n    bytesPrefix: [0x40, 0x15, 0x00, 0x00],\n    base64Prefix: 'QBUA',\n  },\n  {\n    mimeType: 'audio/mp4' as const,\n    bytesPrefix: [0x66, 0x74, 0x79, 0x70],\n    base64Prefix: 'ZnR5cA',\n  },\n] as const;\n\nconst stripID3 = (data: Uint8Array | string) => {\n  const bytes =\n    typeof data === 'string' ? convertBase64ToUint8Array(data) : data;\n  const id3Size =\n    ((bytes[6] & 0x7f) << 21) |\n    ((bytes[7] & 0x7f) << 14) |\n    ((bytes[8] & 0x7f) << 7) |\n    (bytes[9] & 0x7f);\n\n  // The raw MP3 starts here\n  return bytes.slice(id3Size + 10);\n};\n\nfunction stripID3TagsIfPresent(data: Uint8Array | string): Uint8Array | string {\n  const hasId3 =\n    (typeof data === 'string' && data.startsWith('SUQz')) ||\n    (typeof data !== 'string' &&\n      data.length > 10 &&\n      data[0] === 0x49 && // 'I'\n      data[1] === 0x44 && // 'D'\n      data[2] === 0x33); // '3'\n\n  return hasId3 ? stripID3(data) : data;\n}\n\nexport function detectMimeType({\n  data,\n  signatures,\n}: {\n  data: Uint8Array | string;\n  signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n}): (typeof signatures)[number]['mimeType'] | undefined {\n  const processedData = stripID3TagsIfPresent(data);\n\n  for (const signature of signatures) {\n    if (\n      typeof processedData === 'string'\n        ? processedData.startsWith(signature.base64Prefix)\n        : processedData.length >= signature.bytesPrefix.length &&\n          signature.bytesPrefix.every(\n            (byte, index) => processedData[index] === byte,\n          )\n    ) {\n      return signature.mimeType;\n    }\n  }\n\n  return undefined;\n}\n","import { AISDKError, ImageModelV1, JSONValue } from '@ai-sdk/provider';\nimport { NoImageGeneratedError } from '../../errors/no-image-generated-error';\nimport {\n  DefaultGeneratedFile,\n  GeneratedFile,\n} from '../generate-text/generated-file';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ImageGenerationWarning } from '../types/image-model';\nimport { ImageModelResponseMetadata } from '../types/image-model-response-metadata';\nimport { GenerateImageResult } from './generate-image-result';\nimport {\n  detectMimeType,\n  imageMimeTypeSignatures,\n} from '../util/detect-mimetype';\n\n/**\nGenerates images using an image model.\n\n@param model - The image model to use.\n@param prompt - The prompt that should be used to generate the image.\n@param n - Number of images to generate. Default: 1.\n@param size - Size of the images to generate. Must have the format `{width}x{height}`.\n@param aspectRatio - Aspect ratio of the images to generate. Must have the format `{width}:{height}`.\n@param seed - Seed for the image generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated images.\n */\nexport async function generateImage({\n  model,\n  prompt,\n  n = 1,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe image model to use.\n     */\n  model: ImageModelV1;\n\n  /**\nThe prompt that should be used to generate the image.\n   */\n  prompt: string;\n\n  /**\nNumber of images to generate.\n   */\n  n?: number;\n\n  /**\nSize of the images to generate. Must have the format `{width}x{height}`. If not provided, the default size will be used.\n   */\n  size?: `${number}x${number}`;\n\n  /**\nAspect ratio of the images to generate. Must have the format `{width}:{height}`. If not provided, the default aspect ratio will be used.\n   */\n  aspectRatio?: `${number}:${number}`;\n\n  /**\nSeed for the image generation. If not provided, the default seed will be used.\n   */\n  seed?: number;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"style\": \"vivid\"\n  }\n}\n```\n     */\n  providerOptions?: Record<string, Record<string, JSONValue>>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<GenerateImageResult> {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  // default to 1 if the model has not specified limits on\n  // how many images can be generated in a single call\n  const maxImagesPerCall = model.maxImagesPerCall ?? 1;\n\n  // parallelize calls to the model:\n  const callCount = Math.ceil(n / maxImagesPerCall);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCall;\n    }\n\n    const remainder = n % maxImagesPerCall;\n    return remainder === 0 ? maxImagesPerCall : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(async callImageCount =>\n      retry(() =>\n        model.doGenerate({\n          prompt,\n          n: callImageCount,\n          abortSignal,\n          headers,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions ?? {},\n        }),\n      ),\n    ),\n  );\n\n  // collect result images, warnings, and response metadata\n  const images: Array<DefaultGeneratedFile> = [];\n  const warnings: Array<ImageGenerationWarning> = [];\n  const responses: Array<ImageModelResponseMetadata> = [];\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        image =>\n          new DefaultGeneratedFile({\n            data: image,\n            mimeType:\n              detectMimeType({\n                data: image,\n                signatures: imageMimeTypeSignatures,\n              }) ?? 'image/png',\n          }),\n      ),\n    );\n    warnings.push(...result.warnings);\n    responses.push(result.response);\n  }\n\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n\n  return new DefaultGenerateImageResult({ images, warnings, responses });\n}\n\nclass DefaultGenerateImageResult implements GenerateImageResult {\n  readonly images: Array<GeneratedFile>;\n  readonly warnings: Array<ImageGenerationWarning>;\n  readonly responses: Array<ImageModelResponseMetadata>;\n\n  constructor(options: {\n    images: Array<GeneratedFile>;\n    warnings: Array<ImageGenerationWarning>;\n    responses: Array<ImageModelResponseMetadata>;\n  }) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n  }\n\n  get image() {\n    return this.images[0];\n  }\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport { createIdGenerator, safeParseJSON } from '@ai-sdk/provider-utils';\nimport { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { GenerateObjectResult } from './generate-object-result';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { getOutputStrategy } from './output-strategy';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n\nShould return the repaired text or null if the text cannot be repaired.\n     */\nexport type RepairTextFunction = (options: {\n  text: string;\n  error: JSONParseError | TypeValidationError;\n}) => Promise<string | null>;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n     */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n     */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<OBJECT>>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@return\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<Array<ELEMENT>>>;\n/**\nGenerate a value from an enum (limited list of string values) using a language model.\n\nThis function does not stream the output.\n\n@return\nA result object that contains the generated value, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ENUM extends string>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'enum';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe enum values that the model should use.\n     */\n      enum: Array<ENUM>;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<ENUM>>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<JSONValue>>;\nexport async function generateObject<SCHEMA, RESULT>({\n  model,\n  enum: enumValues, // rename bc enum is reserved by typescript\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_repairText: repairText,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'enum' | 'no-schema';\n\n    model: LanguageModel;\n    enum?: Array<SCHEMA>;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_repairText?: RepairTextFunction;\n    experimental_telemetry?: TelemetrySettings;\n    experimental_providerMetadata?: ProviderMetadata;\n    providerOptions?: ProviderOptions;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateObjectResult<RESULT>> {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues,\n  });\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues,\n  });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateObject',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateObject',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.schema':\n          outputStrategy.jsonSchema != null\n            ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n            : undefined,\n        'ai.schema.name': schemaName,\n        'ai.schema.description': schemaDescription,\n        'ai.settings.output': outputStrategy.type,\n        'ai.settings.mode': mode,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      // use the default provider mode when the mode is set to 'auto' or unspecified\n      if (mode === 'auto' || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n\n      let result: string;\n      let finishReason: FinishReason;\n      let usage: Parameters<typeof calculateLanguageModelUsage>[0];\n      let warnings: CallWarning[] | undefined;\n      let rawResponse:\n        | { headers?: Record<string, string>; body?: unknown }\n        | undefined;\n      let response: LanguageModelResponseMetadata;\n      let request: LanguageModelRequestMetadata;\n      let logprobs: LogProbs | undefined;\n      let resultProviderMetadata: ProviderMetadata | undefined;\n\n      switch (mode) {\n        case 'json': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: {\n              system:\n                outputStrategy.jsonSchema == null\n                  ? injectJsonInstruction({ prompt: system })\n                  : model.supportsStructuredOutputs\n                    ? system\n                    : injectJsonInstruction({\n                        prompt: system,\n                        schema: outputStrategy.jsonSchema,\n                      }),\n              prompt,\n              messages,\n            },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => standardizedPrompt.type,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => JSON.stringify(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-json',\n                    schema: outputStrategy.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription,\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat: standardizedPrompt.type,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (result.text === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message:\n                      'No object generated: the model did not return a response.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => result.text },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.prompt_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.completion_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText: result.text, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case 'tool': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: { system, prompt, messages },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n          });\n          const inputFormat = standardizedPrompt.type;\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => inputFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-tool',\n                    tool: {\n                      type: 'function',\n                      name: schemaName ?? 'json',\n                      description:\n                        schemaDescription ?? 'Respond with a JSON object.',\n                      parameters: outputStrategy.jsonSchema!,\n                    },\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const objectText = result.toolCalls?.[0]?.args;\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (objectText === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message: 'No object generated: the tool was not called.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => objectText },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.output_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case undefined: {\n          throw new Error(\n            'Model does not have a default object generation mode.',\n          );\n        }\n\n        default: {\n          const _exhaustiveCheck: never = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n\n      function processResult(result: string): RESULT {\n        const parseResult = safeParseJSON({ text: result });\n\n        if (!parseResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: could not parse the response.',\n            cause: parseResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        const validationResult = outputStrategy.validateFinalResult(\n          parseResult.value,\n          {\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n          },\n        );\n\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            cause: validationResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        return validationResult.value;\n      }\n\n      let object: RESULT;\n      try {\n        object = processResult(result);\n      } catch (error) {\n        if (\n          repairText != null &&\n          NoObjectGeneratedError.isInstance(error) &&\n          (JSONParseError.isInstance(error.cause) ||\n            TypeValidationError.isInstance(error.cause))\n        ) {\n          const repairedText = await repairText({\n            text: result,\n            error: error.cause,\n          });\n\n          if (repairedText === null) {\n            throw error;\n          }\n\n          object = processResult(repairedText);\n        } else {\n          throw error;\n        }\n      }\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': finishReason,\n            'ai.response.object': {\n              output: () => JSON.stringify(object),\n            },\n\n            'ai.usage.promptTokens': usage.promptTokens,\n            'ai.usage.completionTokens': usage.completionTokens,\n          },\n        }),\n      );\n\n      return new DefaultGenerateObjectResult({\n        object,\n        finishReason,\n        usage: calculateLanguageModelUsage(usage),\n        warnings,\n        request,\n        response: {\n          ...response,\n          headers: rawResponse?.headers,\n          body: rawResponse?.body,\n        },\n        logprobs,\n        providerMetadata: resultProviderMetadata,\n      });\n    },\n  });\n}\n\nclass DefaultGenerateObjectResult<T> implements GenerateObjectResult<T> {\n  readonly object: GenerateObjectResult<T>['object'];\n  readonly finishReason: GenerateObjectResult<T>['finishReason'];\n  readonly usage: GenerateObjectResult<T>['usage'];\n  readonly warnings: GenerateObjectResult<T>['warnings'];\n  readonly logprobs: GenerateObjectResult<T>['logprobs'];\n  readonly experimental_providerMetadata: GenerateObjectResult<T>['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n  readonly response: GenerateObjectResult<T>['response'];\n  readonly request: GenerateObjectResult<T>['request'];\n\n  constructor(options: {\n    object: GenerateObjectResult<T>['object'];\n    finishReason: GenerateObjectResult<T>['finishReason'];\n    usage: GenerateObjectResult<T>['usage'];\n    warnings: GenerateObjectResult<T>['warnings'];\n    logprobs: GenerateObjectResult<T>['logprobs'];\n    providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n    response: GenerateObjectResult<T>['response'];\n    request: GenerateObjectResult<T>['request'];\n  }) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.logprobs = options.logprobs;\n  }\n\n  toJsonResponse(init?: ResponseInit): Response {\n    return new Response(JSON.stringify(this.object), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'application/json; charset=utf-8',\n      }),\n    });\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { LanguageModelResponseMetadata } from '../core/types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../core/types/usage';\nimport { FinishReason } from '../core';\n\nconst name = 'AI_NoObjectGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no object could be generated. This can have several causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n- The model generated a response that could not be validated against the schema.\n\nThe error contains the following properties:\n\n- `text`: The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n */\nexport class NoObjectGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n  The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n   */\n  readonly text: string | undefined;\n\n  /**\n  The response metadata.\n   */\n  readonly response: LanguageModelResponseMetadata | undefined;\n\n  /**\n  The usage of the model.\n   */\n  readonly usage: LanguageModelUsage | undefined;\n\n  /**\n  Reason why the model finished generating a response.\n   */\n  readonly finishReason: FinishReason | undefined;\n\n  constructor({\n    message = 'No object generated.',\n    cause,\n    text,\n    response,\n    usage,\n    finishReason,\n  }: {\n    message?: string;\n    cause?: Error;\n    text?: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  }) {\n    super({ name, message, cause });\n\n    this.text = text;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n\n  static isInstance(error: unknown): error is NoObjectGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n\nexport function verifyNoObjectGeneratedError(\n  error: unknown,\n  expected: {\n    message: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  },\n) {\n  expect(NoObjectGeneratedError.isInstance(error)).toBeTruthy();\n  const noObjectGeneratedError = error as NoObjectGeneratedError;\n  expect(noObjectGeneratedError.message).toStrictEqual(expected.message);\n  expect(noObjectGeneratedError.response).toStrictEqual(expected.response);\n  expect(noObjectGeneratedError.usage).toStrictEqual(expected.usage);\n  expect(noObjectGeneratedError.finishReason).toStrictEqual(\n    expected.finishReason,\n  );\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_DownloadError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class DownloadError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly statusCode?: number;\n  readonly statusText?: string;\n\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null\n      ? `Failed to download ${url}: ${statusCode} ${statusText}`\n      : `Failed to download ${url}: ${cause}`,\n  }: {\n    url: string;\n    statusCode?: number;\n    statusText?: string;\n    message?: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n\n  static isInstance(error: unknown): error is DownloadError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { DownloadError } from './download-error';\n\nexport async function download({ url }: { url: URL }): Promise<{\n  data: Uint8Array;\n  mimeType: string | undefined;\n}> {\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText);\n\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText,\n      });\n    }\n\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: response.headers.get('content-type') ?? undefined,\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n","import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\nimport { InvalidDataContentError } from './invalid-data-content-error';\nimport { z } from 'zod';\n\n/**\nData content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.\n */\nexport type DataContent = string | Uint8Array | ArrayBuffer | Buffer;\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer =>\n      globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n\n/**\nConverts data content to a Uint8Array.\n\n@param content - Data content to convert.\n@returns Uint8Array.\n */\nexport function convertDataContentToUint8Array(\n  content: DataContent,\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === 'string') {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message:\n          'Invalid data content. Content string is not a base64-encoded media.',\n        content,\n        cause: error,\n      });\n    }\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new InvalidDataContentError({ content });\n}\n\n/**\n * Converts a Uint8Array to a string of text.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The converted string.\n */\nexport function convertUint8ArrayToText(uint8Array: Uint8Array): string {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error('Error decoding Uint8Array to text');\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidDataContentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidDataContentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly content: unknown;\n\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`,\n  }: {\n    content: unknown;\n    cause?: unknown;\n    message?: string;\n  }) {\n    super({ name, message, cause });\n\n    this.content = content;\n  }\n\n  static isInstance(error: unknown): error is InvalidDataContentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidMessageRoleError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidMessageRoleError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly role: string;\n\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`,\n  }: {\n    role: string;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.role = role;\n  }\n\n  static isInstance(error: unknown): error is InvalidMessageRoleError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export function splitDataUrl(dataUrl: string): {\n  mimeType: string | undefined;\n  base64Content: string | undefined;\n} {\n  try {\n    const [header, base64Content] = dataUrl.split(',');\n    return {\n      mimeType: header.split(';')[0].split(':')[1],\n      base64Content,\n    };\n  } catch (error) {\n    return {\n      mimeType: undefined,\n      base64Content: undefined,\n    };\n  }\n}\n","import {\n  LanguageModelV1FilePart,\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1TextPart,\n} from '@ai-sdk/provider';\nimport { download } from '../../util/download';\nimport { CoreMessage } from '../prompt/message';\nimport {\n  detectMimeType,\n  imageMimeTypeSignatures,\n} from '../util/detect-mimetype';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToBase64String,\n  convertDataContentToUint8Array,\n  DataContent,\n} from './data-content';\nimport { InvalidMessageRoleError } from './invalid-message-role-error';\nimport { splitDataUrl } from './split-data-url';\nimport { StandardizedPrompt } from './standardize-prompt';\n\nexport async function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  modelSupportsUrl = () => false,\n  downloadImplementation = download,\n}: {\n  prompt: StandardizedPrompt;\n  modelSupportsImageUrls: boolean | undefined;\n  modelSupportsUrl: undefined | ((url: URL) => boolean);\n  downloadImplementation?: typeof download;\n}): Promise<LanguageModelV1Prompt> {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    downloadImplementation,\n    modelSupportsImageUrls,\n    modelSupportsUrl,\n  );\n\n  return [\n    ...(prompt.system != null\n      ? [{ role: 'system' as const, content: prompt.system }]\n      : []),\n    ...prompt.messages.map(message =>\n      convertToLanguageModelMessage(message, downloadedAssets),\n    ),\n  ];\n}\n\n/**\n * Convert a CoreMessage to a LanguageModelV1Message.\n *\n * @param message The CoreMessage to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *   available if the model does not support URLs, null otherwise.\n */\nexport function convertToLanguageModelMessage(\n  message: CoreMessage,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n): LanguageModelV1Message {\n  const role = message.role;\n  switch (role) {\n    case 'system': {\n      return {\n        role: 'system',\n        content: message.content,\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'user': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'user',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata:\n            message.providerOptions ?? message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'user',\n        content: message.content\n          .map(part => convertPartToLanguageModelPart(part, downloadedAssets))\n          // remove empty text parts:\n          .filter(part => part.type !== 'text' || part.text !== ''),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'assistant': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'assistant',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata:\n            message.providerOptions ?? message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'assistant',\n        content: message.content\n          .filter(\n            // remove empty text parts:\n            part => part.type !== 'text' || part.text !== '',\n          )\n          .map(part => {\n            const providerOptions =\n              part.providerOptions ?? part.experimental_providerMetadata;\n\n            switch (part.type) {\n              case 'file': {\n                return {\n                  type: 'file',\n                  data:\n                    part.data instanceof URL\n                      ? part.data\n                      : convertDataContentToBase64String(part.data),\n                  filename: part.filename,\n                  mimeType: part.mimeType,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'reasoning': {\n                return {\n                  type: 'reasoning',\n                  text: part.text,\n                  signature: part.signature,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'redacted-reasoning': {\n                return {\n                  type: 'redacted-reasoning',\n                  data: part.data,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'text': {\n                return {\n                  type: 'text' as const,\n                  text: part.text,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'tool-call': {\n                return {\n                  type: 'tool-call' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  args: part.args,\n                  providerMetadata: providerOptions,\n                };\n              }\n            }\n          }),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'tool': {\n      return {\n        role: 'tool',\n        content: message.content.map(part => ({\n          type: 'tool-result',\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          content: part.experimental_content,\n          isError: part.isError,\n          providerMetadata:\n            part.providerOptions ?? part.experimental_providerMetadata,\n        })),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    default: {\n      const _exhaustiveCheck: never = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\n\n/**\n * Downloads images and files from URLs in the messages.\n */\nasync function downloadAssets(\n  messages: CoreMessage[],\n  downloadImplementation: typeof download,\n  modelSupportsImageUrls: boolean | undefined,\n  modelSupportsUrl: (url: URL) => boolean,\n): Promise<Record<string, { mimeType: string | undefined; data: Uint8Array }>> {\n  const urls = messages\n    .filter(message => message.role === 'user')\n    .map(message => message.content)\n    .filter((content): content is Array<TextPart | ImagePart | FilePart> =>\n      Array.isArray(content),\n    )\n    .flat()\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        part.type === 'image' || part.type === 'file',\n    )\n    /**\n     * Filter out image parts if the model supports image URLs, before letting it\n     * decide if it supports a particular URL.\n     */\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        !(part.type === 'image' && modelSupportsImageUrls === true),\n    )\n    .map(part => (part.type === 'image' ? part.image : part.data))\n    .map(part =>\n      // support string urls:\n      typeof part === 'string' &&\n      (part.startsWith('http:') || part.startsWith('https:'))\n        ? new URL(part)\n        : part,\n    )\n    .filter((image): image is URL => image instanceof URL)\n    /**\n     * Filter out URLs that the model supports natively, so we don't download them.\n     */\n    .filter(url => !modelSupportsUrl(url));\n\n  // download in parallel:\n  const downloadedImages = await Promise.all(\n    urls.map(async url => ({\n      url,\n      data: await downloadImplementation({ url }),\n    })),\n  );\n\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data]),\n  );\n}\n\n/**\n * Convert part of a message to a LanguageModelV1Part.\n * @param part The part to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *  available if the model does not support URLs, null otherwise.\n *\n * @returns The converted part.\n */\nfunction convertPartToLanguageModelPart(\n  part: TextPart | ImagePart | FilePart,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n):\n  | LanguageModelV1TextPart\n  | LanguageModelV1ImagePart\n  | LanguageModelV1FilePart {\n  if (part.type === 'text') {\n    return {\n      type: 'text',\n      text: part.text,\n      providerMetadata:\n        part.providerOptions ?? part.experimental_providerMetadata,\n    };\n  }\n\n  let mimeType: string | undefined = part.mimeType;\n  let data: DataContent | URL;\n  let content: URL | ArrayBuffer | string;\n  let normalizedData: Uint8Array | URL;\n\n  const type = part.type;\n  switch (type) {\n    case 'image':\n      data = part.image;\n      break;\n    case 'file':\n      data = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n\n  // Attempt to create a URL from the data. If it fails, we can assume the data\n  // is not a URL and likely some other sort of data.\n  try {\n    content = typeof data === 'string' ? new URL(data) : data;\n  } catch (error) {\n    content = data;\n  }\n\n  // If we successfully created a URL, we can use that to normalize the data\n  // either by passing it through or converting normalizing the base64 content\n  // to a Uint8Array.\n  if (content instanceof URL) {\n    // If the content is a data URL, we want to convert that to a Uint8Array\n    if (content.protocol === 'data:') {\n      const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(\n        content.toString(),\n      );\n\n      if (dataUrlMimeType == null || base64Content == null) {\n        throw new Error(`Invalid data URL format in part ${type}`);\n      }\n\n      mimeType = dataUrlMimeType;\n      normalizedData = convertDataContentToUint8Array(base64Content);\n    } else {\n      /**\n       * If the content is a URL, we should first see if it was downloaded. And if not,\n       * we can let the model decide if it wants to support the URL. This also allows\n       * for non-HTTP URLs to be passed through (e.g. gs://).\n       */\n      const downloadedFile = downloadedAssets[content.toString()];\n      if (downloadedFile) {\n        normalizedData = downloadedFile.data;\n        mimeType ??= downloadedFile.mimeType;\n      } else {\n        normalizedData = content;\n      }\n    }\n  } else {\n    // Since we know now the content is not a URL, we can attempt to normalize\n    // the data assuming it is some sort of data.\n    normalizedData = convertDataContentToUint8Array(content);\n  }\n\n  // Now that we have the normalized data either as a URL or a Uint8Array,\n  // we can create the LanguageModelV1Part.\n  switch (type) {\n    case 'image': {\n      // When possible, try to detect the mimetype automatically\n      // to deal with incorrect mimetype inputs.\n      // When detection fails, use provided mimetype.\n\n      if (normalizedData instanceof Uint8Array) {\n        mimeType =\n          detectMimeType({\n            data: normalizedData,\n            signatures: imageMimeTypeSignatures,\n          }) ?? mimeType;\n      }\n      return {\n        type: 'image',\n        image: normalizedData,\n        mimeType,\n        providerMetadata:\n          part.providerOptions ?? part.experimental_providerMetadata,\n      };\n    }\n\n    case 'file': {\n      // We should have a mimeType at this point, if not, throw an error.\n      if (mimeType == null) {\n        throw new Error(`Mime type is missing for file part`);\n      }\n\n      return {\n        type: 'file',\n        data:\n          normalizedData instanceof Uint8Array\n            ? convertDataContentToBase64String(normalizedData)\n            : normalizedData,\n        filename: part.filename,\n        mimeType,\n        providerMetadata:\n          part.providerOptions ?? part.experimental_providerMetadata,\n      };\n    }\n  }\n}\n","import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { CallSettings } from './call-settings';\n\n/**\n * Validates call settings and sets default values.\n */\nexport function prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n}: Omit<CallSettings, 'abortSignal' | 'headers' | 'maxRetries'>): Omit<\n  CallSettings,\n  'abortSignal' | 'headers' | 'maxRetries'\n> {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be an integer',\n      });\n    }\n\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be >= 1',\n      });\n    }\n  }\n\n  if (temperature != null) {\n    if (typeof temperature !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'temperature',\n        value: temperature,\n        message: 'temperature must be a number',\n      });\n    }\n  }\n\n  if (topP != null) {\n    if (typeof topP !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topP',\n        value: topP,\n        message: 'topP must be a number',\n      });\n    }\n  }\n\n  if (topK != null) {\n    if (typeof topK !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topK',\n        value: topK,\n        message: 'topK must be a number',\n      });\n    }\n  }\n\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'presencePenalty',\n        value: presencePenalty,\n        message: 'presencePenalty must be a number',\n      });\n    }\n  }\n\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'frequencyPenalty',\n        value: frequencyPenalty,\n        message: 'frequencyPenalty must be a number',\n      });\n    }\n  }\n\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: 'seed',\n        value: seed,\n        message: 'seed must be an integer',\n      });\n    }\n  }\n\n  return {\n    maxTokens,\n    // TODO v5 remove default 0 for temperature\n    temperature: temperature ?? 0,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences:\n      stopSequences != null && stopSequences.length > 0\n        ? stopSequences\n        : undefined,\n    seed,\n  };\n}\n","import { InvalidPromptError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { Message } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { ToolSet } from '../generate-text/tool-set';\nimport { convertToCoreMessages } from './convert-to-core-messages';\nimport { CoreMessage, coreMessageSchema } from './message';\nimport { Prompt } from './prompt';\n\nexport type StandardizedPrompt = {\n  /**\n   * Original prompt type. This is forwarded to the providers and can be used\n   * to write send raw text to providers that support it.\n   */\n  type: 'prompt' | 'messages';\n\n  /**\n   * System message.\n   */\n  system?: string;\n\n  /**\n   * Messages.\n   */\n  messages: CoreMessage[];\n};\n\nexport function standardizePrompt<TOOLS extends ToolSet>({\n  prompt,\n  tools,\n}: {\n  prompt: Prompt;\n  tools: undefined | TOOLS;\n}): StandardizedPrompt {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt and messages cannot be defined at the same time',\n    });\n  }\n\n  // validate that system is a string\n  if (prompt.system != null && typeof prompt.system !== 'string') {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'system must be a string',\n    });\n  }\n\n  // type: prompt\n  if (prompt.prompt != null) {\n    // validate that prompt is a string\n    if (typeof prompt.prompt !== 'string') {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'prompt must be a string',\n      });\n    }\n\n    return {\n      type: 'prompt',\n      system: prompt.system,\n      messages: [\n        {\n          role: 'user',\n          content: prompt.prompt,\n        },\n      ],\n    };\n  }\n\n  // type: messages\n  if (prompt.messages != null) {\n    const promptType = detectPromptType(prompt.messages);\n\n    const messages: CoreMessage[] =\n      promptType === 'ui-messages'\n        ? convertToCoreMessages(prompt.messages as Omit<Message, 'id'>[], {\n            tools,\n          })\n        : (prompt.messages as CoreMessage[]);\n\n    if (messages.length === 0) {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'messages must not be empty',\n      });\n    }\n\n    const validationResult = safeValidateTypes({\n      value: messages,\n      schema: z.array(coreMessageSchema),\n    });\n\n    if (!validationResult.success) {\n      throw new InvalidPromptError({\n        prompt,\n        message: [\n          'message must be a CoreMessage or a UI message',\n          `Validation error: ${validationResult.error.message}`,\n        ].join('\\n'),\n        cause: validationResult.error,\n      });\n    }\n\n    return {\n      type: 'messages',\n      messages,\n      system: prompt.system,\n    };\n  }\n\n  throw new Error('unreachable');\n}\n\nfunction detectPromptType(\n  prompt: Array<any>,\n): 'ui-messages' | 'messages' | 'other' {\n  if (!Array.isArray(prompt)) {\n    throw new InvalidPromptError({\n      prompt,\n      message: [\n        'messages must be an array of CoreMessage or UIMessage',\n        `Received non-array value: ${JSON.stringify(prompt)}`,\n      ].join('\\n'),\n      cause: prompt,\n    });\n  }\n\n  if (prompt.length === 0) {\n    return 'messages';\n  }\n\n  const characteristics = prompt.map(detectSingleMessageCharacteristics);\n\n  if (characteristics.some(c => c === 'has-ui-specific-parts')) {\n    return 'ui-messages';\n  }\n\n  const nonMessageIndex = characteristics.findIndex(\n    c => c !== 'has-core-specific-parts' && c !== 'message',\n  );\n\n  if (nonMessageIndex === -1) {\n    return 'messages';\n  }\n\n  throw new InvalidPromptError({\n    prompt,\n    message: [\n      'messages must be an array of CoreMessage or UIMessage',\n      `Received message of type: \"${characteristics[nonMessageIndex]}\" at index ${nonMessageIndex}`,\n      `messages[${nonMessageIndex}]: ${JSON.stringify(prompt[nonMessageIndex])}`,\n    ].join('\\n'),\n    cause: prompt,\n  });\n}\n\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'parts' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message ||\n      'providerOptions' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n","import { Attachment } from '@ai-sdk/ui-utils';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToUint8Array,\n  convertUint8ArrayToText,\n} from './data-content';\n\ntype ContentPart = TextPart | ImagePart | FilePart;\n\n/**\n * Converts a list of attachments to a list of content parts\n * for consumption by `ai/core` functions.\n * Currently only supports images and text attachments.\n */\nexport function attachmentsToParts(attachments: Attachment[]): ContentPart[] {\n  const parts: ContentPart[] = [];\n\n  for (const attachment of attachments) {\n    let url;\n\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n\n    switch (url.protocol) {\n      case 'http:':\n      case 'https:': {\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({ type: 'image', image: url });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: url,\n            mimeType: attachment.contentType,\n          });\n        }\n        break;\n      }\n\n      case 'data:': {\n        let header;\n        let base64Content;\n        let mimeType;\n\n        try {\n          [header, base64Content] = attachment.url.split(',');\n          mimeType = header.split(';')[0].split(':')[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({\n            type: 'image',\n            image: convertDataContentToUint8Array(base64Content),\n          });\n        } else if (attachment.contentType?.startsWith('text/')) {\n          parts.push({\n            type: 'text',\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content),\n            ),\n          });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image or text, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: base64Content,\n            mimeType: attachment.contentType,\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n\n  return parts;\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { Message } from '@ai-sdk/ui-utils';\n\nconst name = 'AI_MessageConversionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class MessageConversionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalMessage: Omit<Message, 'id'>;\n\n  constructor({\n    originalMessage,\n    message,\n  }: {\n    originalMessage: Omit<Message, 'id'>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.originalMessage = originalMessage;\n  }\n\n  static isInstance(error: unknown): error is MessageConversionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import {\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolInvocationUIPart,\n} from '@ai-sdk/ui-utils';\nimport { ToolSet } from '../generate-text/tool-set';\nimport {\n  AssistantContent,\n  CoreMessage,\n  ToolCallPart,\n  ToolResultPart,\n} from '../prompt';\nimport { attachmentsToParts } from './attachments-to-parts';\nimport { MessageConversionError } from './message-conversion-error';\n\n/**\nConverts an array of messages from useChat into an array of CoreMessages that can be used\nwith the AI core functions (e.g. `streamText`).\n */\nexport function convertToCoreMessages<TOOLS extends ToolSet = never>(\n  messages: Array<Omit<Message, 'id'>>,\n  options?: { tools?: TOOLS },\n) {\n  const tools = options?.tools ?? ({} as TOOLS);\n  const coreMessages: CoreMessage[] = [];\n\n  for (let i = 0; i < messages.length; i++) {\n    const message = messages[i];\n    const isLastMessage = i === messages.length - 1;\n    const { role, content, experimental_attachments } = message;\n\n    switch (role) {\n      case 'system': {\n        coreMessages.push({\n          role: 'system',\n          content,\n        });\n        break;\n      }\n\n      case 'user': {\n        if (message.parts == null) {\n          coreMessages.push({\n            role: 'user',\n            content: experimental_attachments\n              ? [\n                  { type: 'text', text: content },\n                  ...attachmentsToParts(experimental_attachments),\n                ]\n              : content,\n          });\n        } else {\n          const textParts = message.parts\n            .filter(part => part.type === 'text')\n            .map(part => ({\n              type: 'text' as const,\n              text: part.text,\n            }));\n\n          coreMessages.push({\n            role: 'user',\n            content: experimental_attachments\n              ? [...textParts, ...attachmentsToParts(experimental_attachments)]\n              : textParts,\n          });\n        }\n        break;\n      }\n\n      case 'assistant': {\n        if (message.parts != null) {\n          let currentStep = 0;\n          let blockHasToolInvocations = false;\n          let block: Array<\n            TextUIPart | ToolInvocationUIPart | ReasoningUIPart | FileUIPart\n          > = [];\n\n          function processBlock() {\n            const content: AssistantContent = [];\n\n            for (const part of block) {\n              switch (part.type) {\n                case 'file':\n                case 'text': {\n                  content.push(part);\n                  break;\n                }\n                case 'reasoning': {\n                  for (const detail of part.details) {\n                    switch (detail.type) {\n                      case 'text':\n                        content.push({\n                          type: 'reasoning' as const,\n                          text: detail.text,\n                          signature: detail.signature,\n                        });\n                        break;\n                      case 'redacted':\n                        content.push({\n                          type: 'redacted-reasoning' as const,\n                          data: detail.data,\n                        });\n                        break;\n                    }\n                  }\n                  break;\n                }\n                case 'tool-invocation':\n                  content.push({\n                    type: 'tool-call' as const,\n                    toolCallId: part.toolInvocation.toolCallId,\n                    toolName: part.toolInvocation.toolName,\n                    args: part.toolInvocation.args,\n                  });\n                  break;\n                default: {\n                  const _exhaustiveCheck: never = part;\n                  throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n                }\n              }\n            }\n\n            coreMessages.push({\n              role: 'assistant',\n              content,\n            });\n\n            // check if there are tool invocations with results in the block\n            const stepInvocations = block\n              .filter(\n                (\n                  part:\n                    | TextUIPart\n                    | ToolInvocationUIPart\n                    | ReasoningUIPart\n                    | FileUIPart,\n                ): part is ToolInvocationUIPart =>\n                  part.type === 'tool-invocation',\n              )\n              .map(part => part.toolInvocation);\n\n            // tool message with tool results\n            if (stepInvocations.length > 0) {\n              coreMessages.push({\n                role: 'tool',\n                content: stepInvocations.map(\n                  (toolInvocation): ToolResultPart => {\n                    if (!('result' in toolInvocation)) {\n                      throw new MessageConversionError({\n                        originalMessage: message,\n                        message:\n                          'ToolInvocation must have a result: ' +\n                          JSON.stringify(toolInvocation),\n                      });\n                    }\n\n                    const { toolCallId, toolName, result } = toolInvocation;\n\n                    const tool = tools[toolName];\n                    return tool?.experimental_toToolResultContent != null\n                      ? {\n                          type: 'tool-result',\n                          toolCallId,\n                          toolName,\n                          result: tool.experimental_toToolResultContent(result),\n                          experimental_content:\n                            tool.experimental_toToolResultContent(result),\n                        }\n                      : {\n                          type: 'tool-result',\n                          toolCallId,\n                          toolName,\n                          result,\n                        };\n                  },\n                ),\n              });\n            }\n\n            // updates for next block\n            block = [];\n            blockHasToolInvocations = false;\n            currentStep++;\n          }\n\n          for (const part of message.parts) {\n            switch (part.type) {\n              case 'text': {\n                if (blockHasToolInvocations) {\n                  processBlock(); // text must come before tool invocations\n                }\n                block.push(part);\n                break;\n              }\n              case 'file':\n              case 'reasoning': {\n                block.push(part);\n                break;\n              }\n              case 'tool-invocation': {\n                if ((part.toolInvocation.step ?? 0) !== currentStep) {\n                  processBlock();\n                }\n                block.push(part);\n                blockHasToolInvocations = true;\n                break;\n              }\n            }\n          }\n\n          processBlock();\n\n          break;\n        }\n\n        const toolInvocations = message.toolInvocations;\n\n        if (toolInvocations == null || toolInvocations.length === 0) {\n          coreMessages.push({ role: 'assistant', content });\n          break;\n        }\n\n        const maxStep = toolInvocations.reduce((max, toolInvocation) => {\n          return Math.max(max, toolInvocation.step ?? 0);\n        }, 0);\n\n        for (let i = 0; i <= maxStep; i++) {\n          const stepInvocations = toolInvocations.filter(\n            toolInvocation => (toolInvocation.step ?? 0) === i,\n          );\n\n          if (stepInvocations.length === 0) {\n            continue;\n          }\n\n          // assistant message with tool calls\n          coreMessages.push({\n            role: 'assistant',\n            content: [\n              ...(isLastMessage && content && i === 0\n                ? [{ type: 'text' as const, text: content }]\n                : []),\n              ...stepInvocations.map(\n                ({ toolCallId, toolName, args }): ToolCallPart => ({\n                  type: 'tool-call' as const,\n                  toolCallId,\n                  toolName,\n                  args,\n                }),\n              ),\n            ],\n          });\n\n          // tool message with tool results\n          coreMessages.push({\n            role: 'tool',\n            content: stepInvocations.map((toolInvocation): ToolResultPart => {\n              if (!('result' in toolInvocation)) {\n                throw new MessageConversionError({\n                  originalMessage: message,\n                  message:\n                    'ToolInvocation must have a result: ' +\n                    JSON.stringify(toolInvocation),\n                });\n              }\n\n              const { toolCallId, toolName, result } = toolInvocation;\n\n              const tool = tools[toolName];\n              return tool?.experimental_toToolResultContent != null\n                ? {\n                    type: 'tool-result',\n                    toolCallId,\n                    toolName,\n                    result: tool.experimental_toToolResultContent(result),\n                    experimental_content:\n                      tool.experimental_toToolResultContent(result),\n                  }\n                : {\n                    type: 'tool-result',\n                    toolCallId,\n                    toolName,\n                    result,\n                  };\n            }),\n          });\n        }\n\n        if (content && !isLastMessage) {\n          coreMessages.push({ role: 'assistant', content });\n        }\n\n        break;\n      }\n\n      case 'data': {\n        // ignore\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`,\n        });\n      }\n    }\n  }\n\n  return coreMessages;\n}\n","import { z } from 'zod';\nimport { ProviderMetadata } from '../types';\nimport {\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport {\n  FilePart,\n  filePartSchema,\n  ImagePart,\n  imagePartSchema,\n  ReasoningPart,\n  reasoningPartSchema,\n  RedactedReasoningPart,\n  redactedReasoningPartSchema,\n  TextPart,\n  textPartSchema,\n  ToolCallPart,\n  toolCallPartSchema,\n  ToolResultPart,\n  toolResultPartSchema,\n} from './content-part';\n\n/**\n A system message. It can contain system information.\n\n Note: using the \"system\" part of the prompt is strongly preferred\n to increase the resilience against prompt injection attacks,\n and because not all providers support several system messages.\n */\nexport type CoreSystemMessage = {\n  role: 'system';\n  content: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreSystemMessageSchema: z.ZodType<CoreSystemMessage> = z.object({\n  role: z.literal('system'),\n  content: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nA user message. It can contain text or a combination of text and images.\n */\nexport type CoreUserMessage = {\n  role: 'user';\n  content: UserContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreUserMessageSchema: z.ZodType<CoreUserMessage> = z.object({\n  role: z.literal('user'),\n  content: z.union([\n    z.string(),\n    z.array(z.union([textPartSchema, imagePartSchema, filePartSchema])),\n  ]),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a user message. It can be a string or an array of text and image parts.\n */\nexport type UserContent = string | Array<TextPart | ImagePart | FilePart>;\n\n/**\nAn assistant message. It can contain text, tool calls, or a combination of text and tool calls.\n */\nexport type CoreAssistantMessage = {\n  role: 'assistant';\n  content: AssistantContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreAssistantMessageSchema: z.ZodType<CoreAssistantMessage> =\n  z.object({\n    role: z.literal('assistant'),\n    content: z.union([\n      z.string(),\n      z.array(\n        z.union([\n          textPartSchema,\n          filePartSchema,\n          reasoningPartSchema,\n          redactedReasoningPartSchema,\n          toolCallPartSchema,\n        ]),\n      ),\n    ]),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nContent of an assistant message.\nIt can be a string or an array of text, image, reasoning, redacted reasoning, and tool call parts.\n */\nexport type AssistantContent =\n  | string\n  | Array<\n      TextPart | FilePart | ReasoningPart | RedactedReasoningPart | ToolCallPart\n    >;\n\n/**\nA tool message. It contains the result of one or more tool calls.\n */\nexport type CoreToolMessage = {\n  role: 'tool';\n  content: ToolContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreToolMessageSchema: z.ZodType<CoreToolMessage> = z.object({\n  role: z.literal('tool'),\n  content: z.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a tool message. It is an array of tool result parts.\n */\nexport type ToolContent = Array<ToolResultPart>;\n\n/**\nA message that can be used in the `messages` field of a prompt.\nIt can be a user message, an assistant message, or a tool message.\n */\nexport type CoreMessage =\n  | CoreSystemMessage\n  | CoreUserMessage\n  | CoreAssistantMessage\n  | CoreToolMessage;\n\nexport const coreMessageSchema: z.ZodType<CoreMessage> = z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema,\n]);\n","import { LanguageModelV1ProviderMetadata } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { jsonValueSchema } from './json-value';\n\n/**\nAdditional provider-specific metadata that is returned from the provider.\n\nThis is needed to enable provider-specific functionality that can be\nfully encapsulated in the provider.\n */\nexport type ProviderMetadata = LanguageModelV1ProviderMetadata;\n\n/**\nAdditional provider-specific options.\n\nThey are passed through to the provider from the AI SDK and enable\nprovider-specific functionality that can be fully encapsulated in the provider.\n */\n// TODO change to LanguageModelV2ProviderOptions in language model v2\nexport type ProviderOptions = LanguageModelV1ProviderMetadata;\n\nexport const providerMetadataSchema: z.ZodType<ProviderMetadata> = z.record(\n  z.string(),\n  z.record(z.string(), jsonValueSchema),\n);\n","import { JSONValue } from '@ai-sdk/provider';\nimport { z } from 'zod';\n\nexport const jsonValueSchema: z.ZodType<JSONValue> = z.lazy(() =>\n  z.union([\n    z.null(),\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.string(), jsonValueSchema),\n    z.array(jsonValueSchema),\n  ]),\n);\n","import { z } from 'zod';\nimport {\n  ProviderMetadata,\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport { DataContent, dataContentSchema } from './data-content';\nimport {\n  ToolResultContent,\n  toolResultContentSchema,\n} from './tool-result-content';\n\n/**\nText content part of a prompt. It contains a string of text.\n */\nexport interface TextPart {\n  type: 'text';\n\n  /**\nThe text content.\n   */\n  text: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const textPartSchema: z.ZodType<TextPart> = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nImage content part of a prompt. It contains an image.\n */\nexport interface ImagePart {\n  type: 'image';\n\n  /**\nImage data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  image: DataContent | URL;\n\n  /**\nOptional mime type of the image.\n   */\n  mimeType?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const imagePartSchema: z.ZodType<ImagePart> = z.object({\n  type: z.literal('image'),\n  image: z.union([dataContentSchema, z.instanceof(URL)]),\n  mimeType: z.string().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nFile content part of a prompt. It contains a file.\n */\nexport interface FilePart {\n  type: 'file';\n\n  /**\nFile data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  data: DataContent | URL;\n\n  /**\nOptional filename of the file.\n   */\n  filename?: string;\n\n  /**\nMime type of the file.\n   */\n  mimeType: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const filePartSchema: z.ZodType<FilePart> = z.object({\n  type: z.literal('file'),\n  data: z.union([dataContentSchema, z.instanceof(URL)]),\n  filename: z.string().optional(),\n  mimeType: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * Reasoning content part of a prompt. It contains a reasoning.\n */\nexport interface ReasoningPart {\n  type: 'reasoning';\n\n  /**\nThe reasoning text.\n   */\n  text: string;\n\n  /**\nAn optional signature for verifying that the reasoning originated from the model.\n   */\n  signature?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const reasoningPartSchema: z.ZodType<ReasoningPart> = z.object({\n  type: z.literal('reasoning'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nRedacted reasoning content part of a prompt.\n */\nexport interface RedactedReasoningPart {\n  type: 'redacted-reasoning';\n\n  /**\nRedacted reasoning data.\n   */\n  data: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const redactedReasoningPartSchema: z.ZodType<RedactedReasoningPart> =\n  z.object({\n    type: z.literal('redacted-reasoning'),\n    data: z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nTool call content part of a prompt. It contains a tool call (usually generated by the AI model).\n */\nexport interface ToolCallPart {\n  type: 'tool-call';\n\n  /**\nID of the tool call. This ID is used to match the tool call with the tool result.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that is being called.\n */\n  toolName: string;\n\n  /**\nArguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\n   */\n  args: unknown;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolCallPartSchema: z.ZodType<ToolCallPart> = z.object({\n  type: z.literal('tool-call'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  args: z.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolCallPart>; // necessary bc args is optional on Zod type\n\n/**\nTool result content part of a prompt. It contains the result of the tool call with the matching ID.\n */\nexport interface ToolResultPart {\n  type: 'tool-result';\n\n  /**\nID of the tool call that this result is associated with.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that generated this result.\n  */\n  toolName: string;\n\n  /**\nResult of the tool call. This is a JSON-serializable object.\n   */\n  result: unknown;\n\n  /**\nMulti-part content of the tool result. Only for tools that support multipart results.\n   */\n  experimental_content?: ToolResultContent;\n\n  /**\nOptional flag if the result is an error or an error message.\n   */\n  isError?: boolean;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolResultPartSchema: z.ZodType<ToolResultPart> = z.object({\n  type: z.literal('tool-result'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  result: z.unknown(),\n  content: toolResultContentSchema.optional(),\n  isError: z.boolean().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolResultPart>; // necessary bc result is optional on Zod type\n","import { z } from 'zod';\n\nexport type ToolResultContent = Array<\n  | {\n      type: 'text';\n      text: string;\n    }\n  | {\n      type: 'image';\n      data: string; // base64 encoded png image, e.g. screenshot\n      mimeType?: string; // e.g. 'image/png';\n    }\n>;\n\nexport const toolResultContentSchema: z.ZodType<ToolResultContent> = z.array(\n  z.union([\n    z.object({ type: z.literal('text'), text: z.string() }),\n    z.object({\n      type: z.literal('image'),\n      data: z.string(),\n      mimeType: z.string().optional(),\n    }),\n  ]),\n);\n\nexport function isToolResultContent(\n  value: unknown,\n): value is ToolResultContent {\n  if (!Array.isArray(value) || value.length === 0) {\n    return false;\n  }\n\n  return value.every(part => {\n    if (typeof part !== 'object' || part === null) {\n      return false;\n    }\n\n    if (part.type === 'text') {\n      return typeof part.text === 'string';\n    }\n\n    if (part.type === 'image') {\n      return (\n        typeof part.data === 'string' &&\n        (part.mimeType === undefined || typeof part.mimeType === 'string')\n      );\n    }\n\n    return false;\n  });\n}\n","/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens,\n}: {\n  promptTokens: number;\n  completionTokens: number;\n}): LanguageModelUsage {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens,\n  };\n}\n\nexport function addLanguageModelUsage(\n  usage1: LanguageModelUsage,\n  usage2: LanguageModelUsage,\n): LanguageModelUsage {\n  return {\n    promptTokens: usage1.promptTokens + usage2.promptTokens,\n    completionTokens: usage1.completionTokens + usage2.completionTokens,\n    totalTokens: usage1.totalTokens + usage2.totalTokens,\n  };\n}\n","import { JSONSchema7 } from '@ai-sdk/provider';\n\nconst DEFAULT_SCHEMA_PREFIX = 'JSON schema:';\nconst DEFAULT_SCHEMA_SUFFIX =\n  'You MUST answer with a JSON object that matches the JSON schema above.';\nconst DEFAULT_GENERIC_SUFFIX = 'You MUST answer with JSON.';\n\nexport function injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : undefined,\n  schemaSuffix = schema != null\n    ? DEFAULT_SCHEMA_SUFFIX\n    : DEFAULT_GENERIC_SUFFIX,\n}: {\n  prompt?: string;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): string {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : undefined,\n    prompt != null && prompt.length > 0 ? '' : undefined, // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : undefined,\n    schemaSuffix,\n  ]\n    .filter(line => line != null)\n    .join('\\n');\n}\n","import {\n  isJSONArray,\n  isJSONObject,\n  JSONObject,\n  JSONSchema7,\n  JSONValue,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { safeValidateTypes, ValidationResult } from '@ai-sdk/provider-utils';\nimport { asSchema, DeepPartial, Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { ObjectStreamPart } from './stream-object-result';\nimport {\n  FinishReason,\n  LanguageModelResponseMetadata,\n  LanguageModelUsage,\n} from '../types';\n\nexport interface OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM> {\n  readonly type: 'object' | 'array' | 'enum' | 'no-schema';\n  readonly jsonSchema: JSONSchema7 | undefined;\n\n  validatePartialResult({\n    value,\n    textDelta,\n    isFinalDelta,\n  }: {\n    value: JSONValue;\n    textDelta: string;\n    isFirstDelta: boolean;\n    isFinalDelta: boolean;\n    latestObject: PARTIAL | undefined;\n  }): ValidationResult<{\n    partial: PARTIAL;\n    textDelta: string;\n  }>;\n  validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n    },\n  ): ValidationResult<RESULT>;\n\n  createElementStream(\n    originalStream: ReadableStream<ObjectStreamPart<PARTIAL>>,\n  ): ELEMENT_STREAM;\n}\n\nconst noSchemaOutputStrategy: OutputStrategy<JSONValue, JSONValue, never> = {\n  type: 'no-schema',\n  jsonSchema: undefined,\n\n  validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n\n  validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): ValidationResult<JSONValue> {\n    return value === undefined\n      ? {\n          success: false,\n          error: new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            text: context.text,\n            response: context.response,\n            usage: context.usage,\n            finishReason: context.finishReason,\n          }),\n        }\n      : { success: true, value };\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in no-schema mode',\n    });\n  },\n};\n\nconst objectOutputStrategy = <OBJECT>(\n  schema: Schema<OBJECT>,\n): OutputStrategy<DeepPartial<OBJECT>, OBJECT, never> => ({\n  type: 'object',\n  jsonSchema: schema.jsonSchema,\n\n  validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value as DeepPartial<OBJECT>,\n        textDelta,\n      },\n    };\n  },\n\n  validateFinalResult(value: JSONValue | undefined): ValidationResult<OBJECT> {\n    return safeValidateTypes({ value, schema });\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in object mode',\n    });\n  },\n});\n\nconst arrayOutputStrategy = <ELEMENT>(\n  schema: Schema<ELEMENT>,\n): OutputStrategy<ELEMENT[], ELEMENT[], AsyncIterableStream<ELEMENT>> => {\n  // remove $schema from schema.jsonSchema:\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n\n  return {\n    type: 'enum',\n\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        elements: { type: 'array', items: itemSchema },\n      },\n      required: ['elements'],\n      additionalProperties: false,\n    },\n\n    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n      const resultArray: Array<ELEMENT> = [];\n\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = safeValidateTypes({ value: element, schema });\n\n        // special treatment for last processed element:\n        // ignore parse or validation failures, since they indicate that the\n        // last element is incomplete and should not be included in the result,\n        // unless it is the final delta\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n\n        if (!result.success) {\n          return result;\n        }\n\n        resultArray.push(result.value);\n      }\n\n      // calculate delta:\n      const publishedElementCount = latestObject?.length ?? 0;\n\n      let textDelta = '';\n\n      if (isFirstDelta) {\n        textDelta += '[';\n      }\n\n      if (publishedElementCount > 0) {\n        textDelta += ',';\n      }\n\n      textDelta += resultArray\n        .slice(publishedElementCount) // only new elements\n        .map(element => JSON.stringify(element))\n        .join(',');\n\n      if (isFinalDelta) {\n        textDelta += ']';\n      }\n\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta,\n        },\n      };\n    },\n\n    validateFinalResult(\n      value: JSONValue | undefined,\n    ): ValidationResult<Array<ELEMENT>> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n\n      // check that each element in the array is of the correct type:\n      for (const element of inputArray) {\n        const result = safeValidateTypes({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n\n      return { success: true, value: inputArray as Array<ELEMENT> };\n    },\n\n    createElementStream(\n      originalStream: ReadableStream<ObjectStreamPart<ELEMENT[]>>,\n    ) {\n      let publishedElements = 0;\n\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream<ObjectStreamPart<ELEMENT[]>, ELEMENT>({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case 'object': {\n                  const array = chunk.object;\n\n                  // publish new elements one by one:\n                  for (\n                    ;\n                    publishedElements < array.length;\n                    publishedElements++\n                  ) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n\n                  break;\n                }\n\n                case 'text-delta':\n                case 'finish':\n                case 'error': // suppress error (use onError instead)\n                  break;\n\n                default: {\n                  const _exhaustiveCheck: never = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`,\n                  );\n                }\n              }\n            },\n          }),\n        ),\n      );\n    },\n  };\n};\n\nconst enumOutputStrategy = <ENUM extends string>(\n  enumValues: Array<ENUM>,\n): OutputStrategy<ENUM, ENUM, never> => {\n  return {\n    type: 'enum',\n\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        result: { type: 'string', enum: enumValues },\n      },\n      required: ['result'],\n      additionalProperties: false,\n    },\n\n    validateFinalResult(value: JSONValue | undefined): ValidationResult<ENUM> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || typeof value.result !== 'string') {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause:\n              'value must be an object that contains a string in the \"result\" property.',\n          }),\n        };\n      }\n\n      const result = value.result as string;\n\n      return enumValues.includes(result as ENUM)\n        ? { success: true, value: result as ENUM }\n        : {\n            success: false,\n            error: new TypeValidationError({\n              value,\n              cause: 'value must be a string in the enum',\n            }),\n          };\n    },\n\n    validatePartialResult() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'partial results in enum mode',\n      });\n    },\n\n    createElementStream() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'element streams in enum mode',\n      });\n    },\n  };\n};\n\nexport function getOutputStrategy<SCHEMA>({\n  output,\n  schema,\n  enumValues,\n}: {\n  output: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n  enumValues?: Array<SCHEMA>;\n}): OutputStrategy<any, any, any> {\n  switch (output) {\n    case 'object':\n      return objectOutputStrategy(asSchema(schema!));\n    case 'array':\n      return arrayOutputStrategy(asSchema(schema!));\n    case 'enum':\n      return enumOutputStrategy(enumValues! as Array<string>);\n    case 'no-schema':\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck: never = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n","export type AsyncIterableStream<T> = AsyncIterable<T> & ReadableStream<T>;\n\nexport function createAsyncIterableStream<T>(\n  source: ReadableStream<T>,\n): AsyncIterableStream<T> {\n  const stream = source.pipeThrough(new TransformStream<T, T>());\n\n  (stream as AsyncIterableStream<T>)[Symbol.asyncIterator] = () => {\n    const reader = stream.getReader();\n    return {\n      async next(): Promise<IteratorResult<T>> {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: undefined } : { done: false, value };\n      },\n    };\n  };\n\n  return stream as AsyncIterableStream<T>;\n}\n","import { z } from 'zod';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { Schema } from '@ai-sdk/ui-utils';\n\nexport function validateObjectGenerationInput({\n  output,\n  mode,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues,\n}: {\n  output?: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<any, z.ZodTypeDef, any> | Schema<any>;\n  schemaName?: string;\n  schemaDescription?: string;\n  enumValues?: Array<unknown>;\n  mode?: 'auto' | 'json' | 'tool';\n}) {\n  if (\n    output != null &&\n    output !== 'object' &&\n    output !== 'array' &&\n    output !== 'enum' &&\n    output !== 'no-schema'\n  ) {\n    throw new InvalidArgumentError({\n      parameter: 'output',\n      value: output,\n      message: 'Invalid output type.',\n    });\n  }\n\n  if (output === 'no-schema') {\n    if (mode === 'auto' || mode === 'tool') {\n      throw new InvalidArgumentError({\n        parameter: 'mode',\n        value: mode,\n        message: 'Mode must be \"json\" for no-schema output.',\n      });\n    }\n\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for no-schema output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for no-schema output.',\n      });\n    }\n  }\n\n  if (output === 'object') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is required for object output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for object output.',\n      });\n    }\n  }\n\n  if (output === 'array') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Element schema is required for array output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for array output.',\n      });\n    }\n  }\n\n  if (output === 'enum') {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for enum output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for enum output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for enum output.',\n      });\n    }\n\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are required for enum output.',\n      });\n    }\n\n    for (const value of enumValues) {\n      if (typeof value !== 'string') {\n        throw new InvalidArgumentError({\n          parameter: 'enumValues',\n          value,\n          message: 'Enum values must be strings.',\n        });\n      }\n    }\n  }\n}\n","/**\n * Helper utility to serialize prompt content for OpenTelemetry tracing.\n * It is initially created because normalized LanguageModelV1Prompt carries\n * images as Uint8Arrays, on which JSON.stringify acts weirdly, converting\n * them to objects with stringified indices as keys, e.g. {\"0\": 42, \"1\": 69 }.\n */\n\nimport {\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1ProviderMetadata,\n} from '@ai-sdk/provider';\nimport { convertDataContentToBase64String } from './data-content';\n\nexport function stringifyForTelemetry(prompt: LanguageModelV1Prompt): string {\n  const processedPrompt = prompt.map((message: LanguageModelV1Message) => {\n    return {\n      ...message,\n      content:\n        typeof message.content === 'string'\n          ? message.content\n          : message.content.map(processPart),\n    };\n  });\n\n  return JSON.stringify(processedPrompt);\n}\n\ntype MessageContentPart = Exclude<\n  LanguageModelV1Message['content'],\n  string\n>[number];\ntype ProcessedMessageContentPart =\n  | Exclude<MessageContentPart, LanguageModelV1ImagePart>\n  | {\n      type: 'image';\n      image: string | URL;\n      mimeType?: string;\n      providerMetadata?: LanguageModelV1ProviderMetadata;\n    };\n\nfunction processPart(part: MessageContentPart): ProcessedMessageContentPart {\n  if (part.type === 'image') {\n    return {\n      ...part,\n      image:\n        part.image instanceof Uint8Array\n          ? convertDataContentToBase64String(part.image)\n          : part.image,\n    };\n  }\n  return part;\n}\n","import {\n  JSONValue,\n  LanguageModelV1CallOptions,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport { createIdGenerator } from '@ai-sdk/provider-utils';\nimport {\n  DeepPartial,\n  Schema,\n  isDeepEqualData,\n  parsePartialJson,\n} from '@ai-sdk/ui-utils';\nimport { ServerResponse } from 'http';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n} from '../types/language-model';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  LanguageModelUsage,\n  calculateLanguageModelUsage,\n} from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { OutputStrategy, getOutputStrategy } from './output-strategy';\nimport { ObjectStreamPart, StreamObjectResult } from './stream-object-result';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnFinishCallback<RESULT> = (event: {\n  /**\nThe token usage of the generated response.\n*/\n  usage: LanguageModelUsage;\n\n  /**\nThe generated object. Can be undefined if the final object does not match the schema.\n*/\n  object: RESULT | undefined;\n\n  /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n*/\n  error: unknown | undefined;\n\n  /**\nResponse metadata.\n */\n  response: LanguageModelResponseMetadata;\n\n  /**\nWarnings from the model provider (e.g. unsupported settings).\n*/\n  warnings?: CallWarning[];\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n*/\n  providerMetadata: ProviderMetadata | undefined;\n\n  /**\n@deprecated Use `providerMetadata` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n}) => Promise<void> | void;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<OBJECT>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<DeepPartial<OBJECT>, OBJECT, never>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<Array<ELEMENT>>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<\n  Array<ELEMENT>,\n  Array<ELEMENT>,\n  AsyncIterableStream<ELEMENT>\n>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<JSONValue>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<JSONValue, JSONValue, never>;\nexport function streamObject<SCHEMA, PARTIAL, RESULT, ELEMENT_STREAM>({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  onError,\n  onFinish,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n    now = originalNow,\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'no-schema';\n\n    model: LanguageModel;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_telemetry?: TelemetrySettings;\n    providerOptions?: ProviderOptions;\n    experimental_providerMetadata?: ProviderMetadata;\n    onError?: StreamObjectOnErrorCallback;\n    onFinish?: StreamObjectOnFinishCallback<RESULT>;\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n      now?: () => number;\n    };\n  }): StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM> {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n  });\n\n  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  });\n}\n\nclass DefaultStreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n  implements StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n{\n  private readonly objectPromise = new DelayedPromise<RESULT>();\n  private readonly usagePromise = new DelayedPromise<LanguageModelUsage>();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    ProviderMetadata | undefined\n  >();\n  private readonly warningsPromise = new DelayedPromise<\n    CallWarning[] | undefined\n  >();\n  private readonly requestPromise =\n    new DelayedPromise<LanguageModelRequestMetadata>();\n  private readonly responsePromise =\n    new DelayedPromise<LanguageModelResponseMetadata>();\n\n  private readonly baseStream: ReadableStream<ObjectStreamPart<PARTIAL>>;\n\n  private readonly outputStrategy: OutputStrategy<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >;\n\n  constructor({\n    model,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    outputStrategy: OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM>;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    schemaName: string | undefined;\n    schemaDescription: string | undefined;\n    providerOptions: ProviderOptions | undefined;\n    mode: 'auto' | 'json' | 'tool' | undefined;\n    onError: StreamObjectOnErrorCallback | undefined;\n    onFinish: StreamObjectOnFinishCallback<RESULT> | undefined;\n    generateId: () => string;\n    currentDate: () => Date;\n    now: () => number;\n  }) {\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const tracer = getTracer(telemetry);\n    const self = this;\n\n    const stitchableStream =\n      createStitchableStream<ObjectStreamPart<PARTIAL>>();\n\n    const eventProcessor = new TransformStream<\n      ObjectStreamPart<PARTIAL>,\n      ObjectStreamPart<PARTIAL>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n\n        if (chunk.type === 'error') {\n          onError?.({ error: chunk.error });\n        }\n      },\n    });\n\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n\n    recordSpan({\n      name: 'ai.streamObject',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: 'ai.streamObject',\n            telemetry,\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.schema':\n            outputStrategy.jsonSchema != null\n              ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n              : undefined,\n          'ai.schema.name': schemaName,\n          'ai.schema.description': schemaDescription,\n          'ai.settings.output': outputStrategy.type,\n          'ai.settings.mode': mode,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpan => {\n        // use the default provider mode when the mode is set to 'auto' or unspecified\n        if (mode === 'auto' || mode == null) {\n          mode = model.defaultObjectGenerationMode;\n        }\n\n        let callOptions: LanguageModelV1CallOptions;\n        let transformer: Transformer<\n          LanguageModelV1StreamPart,\n          string | Omit<LanguageModelV1StreamPart, 'text-delta'>\n        >;\n\n        switch (mode) {\n          case 'json': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: {\n                system:\n                  outputStrategy.jsonSchema == null\n                    ? injectJsonInstruction({ prompt: system })\n                    : model.supportsStructuredOutputs\n                      ? system\n                      : injectJsonInstruction({\n                          prompt: system,\n                          schema: outputStrategy.jsonSchema,\n                        }),\n                prompt,\n                messages,\n              },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-json',\n                schema: outputStrategy.jsonSchema,\n                name: schemaName,\n                description: schemaDescription,\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform: (chunk, controller) => {\n                switch (chunk.type) {\n                  case 'text-delta':\n                    controller.enqueue(chunk.textDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case 'tool': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: { system, prompt, messages },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-tool',\n                tool: {\n                  type: 'function',\n                  name: schemaName ?? 'json',\n                  description:\n                    schemaDescription ?? 'Respond with a JSON object.',\n                  parameters: outputStrategy.jsonSchema!,\n                },\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform(chunk, controller) {\n                switch (chunk.type) {\n                  case 'tool-call-delta':\n                    controller.enqueue(chunk.argsTextDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case undefined: {\n            throw new Error(\n              'Model does not have a default object generation mode.',\n            );\n          }\n\n          default: {\n            const _exhaustiveCheck: never = mode;\n            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n          }\n        }\n\n        const {\n          result: { stream, warnings, rawResponse, request },\n          doStreamSpan,\n          startTimestampMs,\n        } = await retry(() =>\n          recordSpan({\n            name: 'ai.streamObject.doStream',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.streamObject.doStream',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                'ai.prompt.format': {\n                  input: () => callOptions.inputFormat,\n                },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(callOptions.prompt),\n                },\n                'ai.settings.mode': mode,\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': model.provider,\n                'gen_ai.request.model': model.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async doStreamSpan => ({\n              startTimestampMs: now(),\n              doStreamSpan,\n              result: await model.doStream(callOptions),\n            }),\n          }),\n        );\n\n        self.requestPromise.resolve(request ?? {});\n\n        // store information for onFinish callback:\n        let usage: LanguageModelUsage | undefined;\n        let finishReason: LanguageModelV1FinishReason | undefined;\n        let providerMetadata: ProviderMetadata | undefined;\n        let object: RESULT | undefined;\n        let error: unknown | undefined;\n\n        // pipe chunks through a transformation stream that extracts metadata:\n        let accumulatedText = '';\n        let textDelta = '';\n        let response: {\n          id: string;\n          timestamp: Date;\n          modelId: string;\n        } = {\n          id: generateId(),\n          timestamp: currentDate(),\n          modelId: model.modelId,\n        };\n\n        // Keep track of raw parse result before type validation, since e.g. Zod might\n        // change the object by mapping properties.\n        let latestObjectJson: JSONValue | undefined = undefined;\n        let latestObject: PARTIAL | undefined = undefined;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n\n        const transformedStream = stream\n          .pipeThrough(new TransformStream(transformer))\n          .pipeThrough(\n            new TransformStream<\n              string | ObjectStreamInputPart,\n              ObjectStreamPart<PARTIAL>\n            >({\n              async transform(chunk, controller): Promise<void> {\n                // Telemetry event for first chunk:\n                if (isFirstChunk) {\n                  const msToFirstChunk = now() - startTimestampMs;\n\n                  isFirstChunk = false;\n\n                  doStreamSpan.addEvent('ai.stream.firstChunk', {\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n\n                  doStreamSpan.setAttributes({\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n                }\n\n                // process partial text chunks\n                if (typeof chunk === 'string') {\n                  accumulatedText += chunk;\n                  textDelta += chunk;\n\n                  const { value: currentObjectJson, state: parseState } =\n                    parsePartialJson(accumulatedText);\n\n                  if (\n                    currentObjectJson !== undefined &&\n                    !isDeepEqualData(latestObjectJson, currentObjectJson)\n                  ) {\n                    const validationResult =\n                      outputStrategy.validatePartialResult({\n                        value: currentObjectJson,\n                        textDelta,\n                        latestObject,\n                        isFirstDelta,\n                        isFinalDelta: parseState === 'successful-parse',\n                      });\n\n                    if (\n                      validationResult.success &&\n                      !isDeepEqualData(\n                        latestObject,\n                        validationResult.value.partial,\n                      )\n                    ) {\n                      // inside inner check to correctly parse the final element in array mode:\n                      latestObjectJson = currentObjectJson;\n                      latestObject = validationResult.value.partial;\n\n                      controller.enqueue({\n                        type: 'object',\n                        object: latestObject,\n                      });\n\n                      controller.enqueue({\n                        type: 'text-delta',\n                        textDelta: validationResult.value.textDelta,\n                      });\n\n                      textDelta = '';\n                      isFirstDelta = false;\n                    }\n                  }\n\n                  return;\n                }\n\n                switch (chunk.type) {\n                  case 'response-metadata': {\n                    response = {\n                      id: chunk.id ?? response.id,\n                      timestamp: chunk.timestamp ?? response.timestamp,\n                      modelId: chunk.modelId ?? response.modelId,\n                    };\n                    break;\n                  }\n\n                  case 'finish': {\n                    // send final text delta:\n                    if (textDelta !== '') {\n                      controller.enqueue({ type: 'text-delta', textDelta });\n                    }\n\n                    // store finish reason for telemetry:\n                    finishReason = chunk.finishReason;\n\n                    // store usage and metadata for promises and onFinish callback:\n                    usage = calculateLanguageModelUsage(chunk.usage);\n                    providerMetadata = chunk.providerMetadata;\n\n                    controller.enqueue({ ...chunk, usage, response });\n\n                    // resolve promises that can be resolved now:\n                    self.usagePromise.resolve(usage);\n                    self.providerMetadataPromise.resolve(providerMetadata);\n                    self.responsePromise.resolve({\n                      ...response,\n                      headers: rawResponse?.headers,\n                    });\n\n                    // resolve the object promise with the latest object:\n                    const validationResult = outputStrategy.validateFinalResult(\n                      latestObjectJson,\n                      {\n                        text: accumulatedText,\n                        response,\n                        usage,\n                      },\n                    );\n\n                    if (validationResult.success) {\n                      object = validationResult.value;\n                      self.objectPromise.resolve(object);\n                    } else {\n                      error = new NoObjectGeneratedError({\n                        message:\n                          'No object generated: response did not match schema.',\n                        cause: validationResult.error,\n                        text: accumulatedText,\n                        response,\n                        usage,\n                        finishReason: finishReason,\n                      });\n                      self.objectPromise.reject(error);\n                    }\n\n                    break;\n                  }\n\n                  default: {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                }\n              },\n\n              // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n              async flush(controller) {\n                try {\n                  const finalUsage = usage ?? {\n                    promptTokens: NaN,\n                    completionTokens: NaN,\n                    totalTokens: NaN,\n                  };\n\n                  doStreamSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.response.finishReason': finishReason,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                        'ai.response.id': response.id,\n                        'ai.response.model': response.modelId,\n                        'ai.response.timestamp':\n                          response.timestamp.toISOString(),\n\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n\n                        // standardized gen-ai llm span attributes:\n                        'gen_ai.response.finish_reasons': [finishReason],\n                        'gen_ai.response.id': response.id,\n                        'gen_ai.response.model': response.modelId,\n                        'gen_ai.usage.input_tokens': finalUsage.promptTokens,\n                        'gen_ai.usage.output_tokens':\n                          finalUsage.completionTokens,\n                      },\n                    }),\n                  );\n\n                  // finish doStreamSpan before other operations for correct timing:\n                  doStreamSpan.end();\n\n                  // Add response information to the root span:\n                  rootSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                      },\n                    }),\n                  );\n\n                  // call onFinish callback:\n                  await onFinish?.({\n                    usage: finalUsage,\n                    object,\n                    error,\n                    response: {\n                      ...response,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    providerMetadata,\n                    experimental_providerMetadata: providerMetadata,\n                  });\n                } catch (error) {\n                  controller.enqueue({ type: 'error', error });\n                } finally {\n                  rootSpan.end();\n                }\n              },\n            }),\n          );\n\n        stitchableStream.addStream(transformedStream);\n      },\n    })\n      .catch(error => {\n        // add an empty stream with an error to break the stream:\n        stitchableStream.addStream(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue({ type: 'error', error });\n              controller.close();\n            },\n          }),\n        );\n      })\n      .finally(() => {\n        stitchableStream.close();\n      });\n\n    this.outputStrategy = outputStrategy;\n  }\n\n  get object() {\n    return this.objectPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get partialObjectStream(): AsyncIterableStream<PARTIAL> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, PARTIAL>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'object':\n                controller.enqueue(chunk.object);\n                break;\n\n              case 'text-delta':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get elementStream(): ELEMENT_STREAM {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, string>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'text-delta':\n                controller.enqueue(chunk.textDelta);\n                break;\n\n              case 'object':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<ObjectStreamPart<PARTIAL>> {\n    return createAsyncIterableStream(this.baseStream);\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n\nexport type ObjectStreamInputPart =\n  | {\n      type: 'error';\n      error: unknown;\n    }\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      providerMetadata?: ProviderMetadata;\n    };\n","/**\n * Delayed promise. It is only constructed once the value is accessed.\n * This is useful to avoid unhandled promise rejections when the promise is created\n * but not accessed.\n */\nexport class DelayedPromise<T> {\n  private status:\n    | { type: 'pending' }\n    | { type: 'resolved'; value: T }\n    | { type: 'rejected'; error: unknown } = { type: 'pending' };\n  private promise: Promise<T> | undefined;\n  private _resolve: undefined | ((value: T) => void) = undefined;\n  private _reject: undefined | ((error: unknown) => void) = undefined;\n\n  get value(): Promise<T> {\n    if (this.promise) {\n      return this.promise;\n    }\n\n    this.promise = new Promise<T>((resolve, reject) => {\n      if (this.status.type === 'resolved') {\n        resolve(this.status.value);\n      } else if (this.status.type === 'rejected') {\n        reject(this.status.error);\n      }\n\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    return this.promise;\n  }\n\n  resolve(value: T): void {\n    this.status = { type: 'resolved', value };\n\n    if (this.promise) {\n      this._resolve?.(value);\n    }\n  }\n\n  reject(error: unknown): void {\n    this.status = { type: 'rejected', error };\n\n    if (this.promise) {\n      this._reject?.(error);\n    }\n  }\n}\n","/**\n * Creates a Promise with externally accessible resolve and reject functions.\n *\n * @template T - The type of the value that the Promise will resolve to.\n * @returns An object containing:\n *   - promise: A Promise that can be resolved or rejected externally.\n *   - resolve: A function to resolve the Promise with a value of type T.\n *   - reject: A function to reject the Promise with an error.\n */\nexport function createResolvablePromise<T = any>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (error: unknown) => void;\n} {\n  let resolve: (value: T) => void;\n  let reject: (error: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n}\n","import { createResolvablePromise } from '../../util/create-resolvable-promise';\n\n/**\n * Creates a stitchable stream that can pipe one stream at a time.\n *\n * @template T - The type of values emitted by the streams.\n * @returns {Object} An object containing the stitchable stream and control methods.\n */\nexport function createStitchableStream<T>(): {\n  stream: ReadableStream<T>;\n  addStream: (innerStream: ReadableStream<T>) => void;\n  close: () => void;\n  terminate: () => void;\n} {\n  let innerStreamReaders: ReadableStreamDefaultReader<T>[] = [];\n  let controller: ReadableStreamDefaultController<T> | null = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise<void>();\n\n  const processPull = async () => {\n    // Case 1: Outer stream is closed and no more inner streams\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller?.close();\n      return;\n    }\n\n    // Case 2: No inner streams available, but outer stream is open\n    // wait for a new inner stream to be added or the outer stream to close\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise<void>();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n\n      if (done) {\n        // Case 3: Current inner stream is done\n        innerStreamReaders.shift(); // Remove the finished stream\n\n        // Continue pulling from the next stream if available\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller?.close();\n        }\n      } else {\n        // Case 4: Current inner stream returns an item\n        controller?.enqueue(value);\n      }\n    } catch (error) {\n      // Case 5: Current inner stream throws an error\n      controller?.error(error);\n      innerStreamReaders.shift(); // Remove the errored stream\n\n      if (isClosed && innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    }\n  };\n\n  return {\n    stream: new ReadableStream<T>({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      },\n    }),\n    addStream: (innerStream: ReadableStream<T>) => {\n      if (isClosed) {\n        throw new Error('Cannot add inner stream: outer stream is closed');\n      }\n\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n\n      if (innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    },\n\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n\n      innerStreamReaders.forEach(reader => reader.cancel());\n      innerStreamReaders = [];\n      controller?.close();\n    },\n  };\n}\n","// Shim for performance.now() to support environments that don't have it:\nexport function now(): number {\n  return globalThis?.performance?.now() ?? Date.now();\n}\n","import { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { ToolExecutionError } from '../../errors/tool-execution-error';\nimport { CoreAssistantMessage, CoreMessage } from '../prompt';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { LanguageModel, ToolChoice } from '../types';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  addLanguageModelUsage,\n  calculateLanguageModelUsage,\n  LanguageModelUsage,\n} from '../types/usage';\nimport { removeTextAfterLastWhitespace } from '../util/remove-text-after-last-whitespace';\nimport { GenerateTextResult } from './generate-text-result';\nimport { DefaultGeneratedFile, GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { parseToolCall } from './parse-tool-call';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport { ResponseMessage, StepResult } from './step-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallArray } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultArray } from './tool-result';\nimport { ToolSet } from './tool-set';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type GenerateTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamText` instead.\n\n@param model - The language model to use.\n\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n@param toolChoice - The tool choice strategy. Default: 'auto'.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n\n@returns\nA result object that contains the generated text, the results of the tool calls, and additional information.\n */\nexport async function generateText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  OUTPUT_PARTIAL = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_activeTools: activeTools,\n  experimental_prepareStep: prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  onStepFinish,\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n*/\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n     */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n     */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, OUTPUT_PARTIAL>;\n\n    /**\nOptional function that you can use to provide different settings for a step.\n\n@param options - The options for the step.\n@param options.steps - The steps that have been executed so far.\n@param options.stepNumber - The number of the step that is being executed.\n@param options.maxSteps - The maximum number of steps.\n@param options.model - The model that is being used.\n\n@returns An object that contains the settings for the step.\nIf you return undefined (or for undefined settings), the settings from the outer level will be used.\n    */\n    experimental_prepareStep?: (options: {\n      steps: Array<StepResult<TOOLS>>;\n      stepNumber: number;\n      maxSteps: number;\n      model: LanguageModel;\n    }) => PromiseLike<\n      | {\n          model?: LanguageModel;\n          toolChoice?: ToolChoice<TOOLS>;\n          experimental_activeTools?: Array<keyof TOOLS>;\n        }\n      | undefined\n    >;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\n    Callback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: GenerateTextOnStepFinishCallback<TOOLS>;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateTextResult<TOOLS, OUTPUT>> {\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: 'maxSteps',\n      value: maxSteps,\n      message: 'maxSteps must be at least 1',\n    });\n  }\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const initialPrompt = standardizePrompt({\n    prompt: {\n      system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n      prompt,\n      messages,\n    },\n    tools,\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateText',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateText',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // model:\n        'ai.model.provider': model.provider,\n        'ai.model.id': model.modelId,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.settings.maxSteps': maxSteps,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const callSettings = prepareCallSettings(settings);\n\n      let currentModelResponse: Awaited<\n        ReturnType<LanguageModel['doGenerate']>\n      > & { response: { id: string; timestamp: Date; modelId: string } };\n      let currentToolCalls: ToolCallArray<TOOLS> = [];\n      let currentToolResults: ToolResultArray<TOOLS> = [];\n      let currentReasoningDetails: Array<ReasoningDetail> = [];\n      let stepCount = 0;\n      const responseMessages: Array<ResponseMessage> = [];\n      let text = '';\n      const sources: GenerateTextResult<TOOLS, OUTPUT>['sources'] = [];\n      const steps: GenerateTextResult<TOOLS, OUTPUT>['steps'] = [];\n      let usage: LanguageModelUsage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0,\n      };\n\n      let stepType: 'initial' | 'tool-result' | 'continue' | 'done' = 'initial';\n\n      do {\n        // after the 1st step, we need to switch to messages format:\n        const promptFormat = stepCount === 0 ? initialPrompt.type : 'messages';\n\n        const stepInputMessages = [\n          ...initialPrompt.messages,\n          ...responseMessages,\n        ];\n\n        const prepareStepResult = await prepareStep?.({\n          model,\n          steps,\n          maxSteps,\n          stepNumber: stepCount,\n        });\n\n        const stepToolChoice = prepareStepResult?.toolChoice ?? toolChoice;\n        const stepActiveTools =\n          prepareStepResult?.experimental_activeTools ?? activeTools;\n        const stepModel = prepareStepResult?.model ?? model;\n\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: {\n            type: promptFormat,\n            system: initialPrompt.system,\n            messages: stepInputMessages,\n          },\n          modelSupportsImageUrls: stepModel.supportsImageUrls,\n          modelSupportsUrl: stepModel.supportsUrl?.bind(stepModel), // support 'this' context\n        });\n\n        const mode = {\n          type: 'regular' as const,\n          ...prepareToolsAndToolChoice({\n            tools,\n            toolChoice: stepToolChoice,\n            activeTools: stepActiveTools,\n          }),\n        };\n\n        currentModelResponse = await retry(() =>\n          recordSpan({\n            name: 'ai.generateText.doGenerate',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.generateText.doGenerate',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // model:\n                'ai.model.provider': stepModel.provider,\n                'ai.model.id': stepModel.modelId,\n                // prompt:\n                'ai.prompt.format': { input: () => promptFormat },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(promptMessages),\n                },\n                'ai.prompt.tools': {\n                  // convert the language model level tools:\n                  input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                },\n                'ai.prompt.toolChoice': {\n                  input: () =>\n                    mode.toolChoice != null\n                      ? JSON.stringify(mode.toolChoice)\n                      : undefined,\n                },\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': stepModel.provider,\n                'gen_ai.request.model': stepModel.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.stop_sequences': settings.stopSequences,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            fn: async span => {\n              const result = await stepModel.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: promptFormat,\n                responseFormat: output?.responseFormat({ model }),\n                prompt: promptMessages,\n                providerMetadata: providerOptions,\n                abortSignal,\n                headers,\n              });\n\n              // Fill in default values:\n              const responseData = {\n                id: result.response?.id ?? generateId(),\n                timestamp: result.response?.timestamp ?? currentDate(),\n                modelId: result.response?.modelId ?? stepModel.modelId,\n              };\n\n              // Add response information to the span:\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.response.finishReason': result.finishReason,\n                    'ai.response.text': {\n                      output: () => result.text,\n                    },\n                    'ai.response.toolCalls': {\n                      output: () => JSON.stringify(result.toolCalls),\n                    },\n                    'ai.response.id': responseData.id,\n                    'ai.response.model': responseData.modelId,\n                    'ai.response.timestamp':\n                      responseData.timestamp.toISOString(),\n\n                    'ai.usage.promptTokens': result.usage.promptTokens,\n                    'ai.usage.completionTokens': result.usage.completionTokens,\n\n                    // standardized gen-ai llm span attributes:\n                    'gen_ai.response.finish_reasons': [result.finishReason],\n                    'gen_ai.response.id': responseData.id,\n                    'gen_ai.response.model': responseData.modelId,\n                    'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                    'gen_ai.usage.output_tokens': result.usage.completionTokens,\n                  },\n                }),\n              );\n\n              return { ...result, response: responseData };\n            },\n          }),\n        );\n\n        // parse tool calls:\n        currentToolCalls = await Promise.all(\n          (currentModelResponse.toolCalls ?? []).map(toolCall =>\n            parseToolCall({\n              toolCall,\n              tools,\n              repairToolCall,\n              system,\n              messages: stepInputMessages,\n            }),\n          ),\n        );\n\n        // execute tools:\n        currentToolResults =\n          tools == null\n            ? []\n            : await executeTools({\n                toolCalls: currentToolCalls,\n                tools,\n                tracer,\n                telemetry,\n                messages: stepInputMessages,\n                abortSignal,\n              });\n\n        // token usage:\n        const currentUsage = calculateLanguageModelUsage(\n          currentModelResponse.usage,\n        );\n        usage = addLanguageModelUsage(usage, currentUsage);\n\n        // check if another step is needed:\n        let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n        if (++stepCount < maxSteps) {\n          if (\n            continueSteps &&\n            currentModelResponse.finishReason === 'length' &&\n            // only use continue when there are no tool calls:\n            currentToolCalls.length === 0\n          ) {\n            nextStepType = 'continue';\n          } else if (\n            // there are tool calls:\n            currentToolCalls.length > 0 &&\n            // all current tool calls have results:\n            currentToolResults.length === currentToolCalls.length\n          ) {\n            nextStepType = 'tool-result';\n          }\n        }\n\n        // text:\n        const originalText = currentModelResponse.text ?? '';\n        const stepTextLeadingWhitespaceTrimmed =\n          stepType === 'continue' && // only for continue steps\n          text.trimEnd() !== text // only trim when there is preceding whitespace\n            ? originalText.trimStart()\n            : originalText;\n        const stepText =\n          nextStepType === 'continue'\n            ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed)\n            : stepTextLeadingWhitespaceTrimmed;\n\n        text =\n          nextStepType === 'continue' || stepType === 'continue'\n            ? text + stepText\n            : stepText;\n\n        currentReasoningDetails = asReasoningDetails(\n          currentModelResponse.reasoning,\n        );\n\n        // sources:\n        sources.push(...(currentModelResponse.sources ?? []));\n\n        // append to messages for potential next step:\n        if (stepType === 'continue') {\n          // continue step: update the last assistant message\n          // continue is only possible when there are no tool calls,\n          // so we can assume that there is a single last assistant message:\n          const lastMessage = responseMessages[\n            responseMessages.length - 1\n          ] as CoreAssistantMessage;\n\n          if (typeof lastMessage.content === 'string') {\n            lastMessage.content += stepText;\n          } else {\n            lastMessage.content.push({\n              text: stepText,\n              type: 'text',\n            });\n          }\n        } else {\n          responseMessages.push(\n            ...toResponseMessages({\n              text,\n              files: asFiles(currentModelResponse.files),\n              reasoning: asReasoningDetails(currentModelResponse.reasoning),\n              tools: tools ?? ({} as TOOLS),\n              toolCalls: currentToolCalls,\n              toolResults: currentToolResults,\n              messageId: generateMessageId(),\n              generateMessageId,\n            }),\n          );\n        }\n\n        // Add step information (after response messages are updated):\n        const currentStepResult: StepResult<TOOLS> = {\n          stepType,\n          text: stepText,\n          // TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)\n          reasoning: asReasoningText(currentReasoningDetails),\n          reasoningDetails: currentReasoningDetails,\n          files: asFiles(currentModelResponse.files),\n          sources: currentModelResponse.sources ?? [],\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs,\n          request: currentModelResponse.request ?? {},\n          response: {\n            ...currentModelResponse.response,\n            headers: currentModelResponse.rawResponse?.headers,\n            body: currentModelResponse.rawResponse?.body,\n\n            // deep clone msgs to avoid mutating past messages in multi-step:\n            messages: structuredClone(responseMessages),\n          },\n          providerMetadata: currentModelResponse.providerMetadata,\n          experimental_providerMetadata: currentModelResponse.providerMetadata,\n          isContinued: nextStepType === 'continue',\n        };\n        steps.push(currentStepResult);\n        await onStepFinish?.(currentStepResult);\n\n        stepType = nextStepType;\n      } while (stepType !== 'done');\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': currentModelResponse.finishReason,\n            'ai.response.text': {\n              output: () => currentModelResponse.text,\n            },\n            'ai.response.toolCalls': {\n              output: () => JSON.stringify(currentModelResponse.toolCalls),\n            },\n\n            'ai.usage.promptTokens': currentModelResponse.usage.promptTokens,\n            'ai.usage.completionTokens':\n              currentModelResponse.usage.completionTokens,\n          },\n        }),\n      );\n\n      return new DefaultGenerateTextResult({\n        text,\n        files: asFiles(currentModelResponse.files),\n        reasoning: asReasoningText(currentReasoningDetails),\n        reasoningDetails: currentReasoningDetails,\n        sources,\n        outputResolver: () => {\n          if (output == null) {\n            throw new NoOutputSpecifiedError();\n          }\n\n          return output.parseOutput(\n            { text },\n            {\n              response: currentModelResponse.response,\n              usage,\n              finishReason: currentModelResponse.finishReason,\n            },\n          );\n        },\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        request: currentModelResponse.request ?? {},\n        response: {\n          ...currentModelResponse.response,\n          headers: currentModelResponse.rawResponse?.headers,\n          body: currentModelResponse.rawResponse?.body,\n          messages: responseMessages,\n        },\n        logprobs: currentModelResponse.logprobs,\n        steps,\n        providerMetadata: currentModelResponse.providerMetadata,\n      });\n    },\n  });\n}\n\nasync function executeTools<TOOLS extends ToolSet>({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n}: {\n  toolCalls: ToolCallArray<TOOLS>;\n  tools: TOOLS;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  messages: CoreMessage[];\n  abortSignal: AbortSignal | undefined;\n}): Promise<ToolResultArray<TOOLS>> {\n  const toolResults = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, args }) => {\n      const tool = tools[toolName];\n\n      if (tool?.execute == null) {\n        return undefined;\n      }\n\n      const result = await recordSpan({\n        name: 'ai.toolCall',\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: 'ai.toolCall',\n              telemetry,\n            }),\n            'ai.toolCall.name': toolName,\n            'ai.toolCall.id': toolCallId,\n            'ai.toolCall.args': {\n              output: () => JSON.stringify(args),\n            },\n          },\n        }),\n        tracer,\n        fn: async span => {\n          try {\n            const result = await tool.execute!(args, {\n              toolCallId,\n              messages,\n              abortSignal,\n            });\n\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.toolCall.result': {\n                      output: () => JSON.stringify(result),\n                    },\n                  },\n                }),\n              );\n            } catch (ignored) {\n              // JSON stringify might fail if the result is not serializable,\n              // in which case we just ignore it. In the future we might want to\n              // add an optional serialize method to the tool interface and warn\n              // if the result is not serializable.\n            }\n\n            return result;\n          } catch (error) {\n            throw new ToolExecutionError({\n              toolCallId,\n              toolName,\n              toolArgs: args,\n              cause: error,\n            });\n          }\n        },\n      });\n\n      return {\n        type: 'tool-result',\n        toolCallId,\n        toolName,\n        args,\n        result,\n      } as ToolResultArray<TOOLS>[number];\n    }),\n  );\n\n  return toolResults.filter(\n    (result): result is NonNullable<typeof result> => result != null,\n  );\n}\n\nclass DefaultGenerateTextResult<TOOLS extends ToolSet, OUTPUT>\n  implements GenerateTextResult<TOOLS, OUTPUT>\n{\n  readonly text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n  readonly files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n  readonly reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n  readonly reasoningDetails: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['reasoningDetails'];\n  readonly toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n  readonly toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n  readonly finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n  readonly usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n  readonly warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n  readonly steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n  readonly logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n  readonly experimental_providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['providerMetadata'];\n  readonly response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n  readonly request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n  readonly sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n\n  private readonly outputResolver: () => GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_output'];\n\n  constructor(options: {\n    text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n    files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n    reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n    reasoningDetails: GenerateTextResult<TOOLS, OUTPUT>['reasoningDetails'];\n    toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n    toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n    finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n    usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n    warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n    logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n    steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n    providerMetadata: GenerateTextResult<TOOLS, OUTPUT>['providerMetadata'];\n    response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n    request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n    outputResolver: () => GenerateTextResult<\n      TOOLS,\n      OUTPUT\n    >['experimental_output'];\n    sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n  }) {\n    this.text = options.text;\n    this.files = options.files;\n    this.reasoning = options.reasoning;\n    this.reasoningDetails = options.reasoningDetails;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.request = options.request;\n    this.response = options.response;\n    this.steps = options.steps;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.providerMetadata = options.providerMetadata;\n    this.logprobs = options.logprobs;\n    this.outputResolver = options.outputResolver;\n    this.sources = options.sources;\n  }\n\n  get experimental_output() {\n    return this.outputResolver();\n  }\n}\n\nfunction asReasoningDetails(\n  reasoning:\n    | string\n    | Array<\n        | { type: 'text'; text: string; signature?: string }\n        | { type: 'redacted'; data: string }\n      >\n    | undefined,\n): Array<\n  | { type: 'text'; text: string; signature?: string }\n  | { type: 'redacted'; data: string }\n> {\n  if (reasoning == null) {\n    return [];\n  }\n\n  if (typeof reasoning === 'string') {\n    return [{ type: 'text', text: reasoning }];\n  }\n\n  return reasoning;\n}\n\nfunction asFiles(\n  files:\n    | Array<{\n        data: string | Uint8Array;\n        mimeType: string;\n      }>\n    | undefined,\n): Array<GeneratedFile> {\n  return files?.map(file => new DefaultGeneratedFile(file)) ?? [];\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoOutputSpecifiedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no output type is specified and output-related methods are called.\n */\nexport class NoOutputSpecifiedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'No output specified.' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoOutputSpecifiedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError, getErrorMessage, JSONValue } from '@ai-sdk/provider';\n\nconst name = 'AI_ToolExecutionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolExecutionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: JSONValue;\n  readonly toolCallId: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    toolCallId,\n    cause,\n    message = `Error executing tool ${toolName}: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    toolArgs: JSONValue;\n    toolName: string;\n    toolCallId: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n    this.toolCallId = toolCallId;\n  }\n\n  static isInstance(error: unknown): error is ToolExecutionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import {\n  LanguageModelV1FunctionTool,\n  LanguageModelV1ProviderDefinedTool,\n  LanguageModelV1ToolChoice,\n} from '@ai-sdk/provider';\nimport { asSchema } from '@ai-sdk/ui-utils';\nimport { ToolSet } from '../generate-text';\nimport { ToolChoice } from '../types/language-model';\nimport { isNonEmptyObject } from '../util/is-non-empty-object';\n\nexport function prepareToolsAndToolChoice<TOOLS extends ToolSet>({\n  tools,\n  toolChoice,\n  activeTools,\n}: {\n  tools: TOOLS | undefined;\n  toolChoice: ToolChoice<TOOLS> | undefined;\n  activeTools: Array<keyof TOOLS> | undefined;\n}): {\n  tools:\n    | Array<LanguageModelV1FunctionTool | LanguageModelV1ProviderDefinedTool>\n    | undefined;\n  toolChoice: LanguageModelV1ToolChoice | undefined;\n} {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: undefined,\n      toolChoice: undefined,\n    };\n  }\n\n  // when activeTools is provided, we only include the tools that are in the list:\n  const filteredTools =\n    activeTools != null\n      ? Object.entries(tools).filter(([name]) =>\n          activeTools.includes(name as keyof TOOLS),\n        )\n      : Object.entries(tools);\n\n  return {\n    tools: filteredTools.map(([name, tool]) => {\n      const toolType = tool.type;\n      switch (toolType) {\n        case undefined:\n        case 'function':\n          return {\n            type: 'function' as const,\n            name,\n            description: tool.description,\n            parameters: asSchema(tool.parameters).jsonSchema,\n          };\n        case 'provider-defined':\n          return {\n            type: 'provider-defined' as const,\n            name,\n            id: tool.id,\n            args: tool.args,\n          };\n        default: {\n          const exhaustiveCheck: never = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice:\n      toolChoice == null\n        ? { type: 'auto' }\n        : typeof toolChoice === 'string'\n          ? { type: toolChoice }\n          : { type: 'tool' as const, toolName: toolChoice.toolName as string },\n  };\n}\n","export function isNonEmptyObject(\n  object: Record<string, unknown> | undefined | null,\n): object is Record<string, unknown> {\n  return object != null && Object.keys(object).length > 0;\n}\n","const lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\n\n/**\n * Splits the text on the last whitespace.\n *\n * Whitespace is defined as one or more whitespace characters,\n * e.g. space, tab, newline, etc.\n *\n * @param text - The text to split.\n * @returns The prefix, whitespace, and suffix. Undefined if there is no whitespace.\n */\nexport function splitOnLastWhitespace(text: string):\n  | {\n      prefix: string;\n      whitespace: string;\n      suffix: string;\n    }\n  | undefined {\n  const match = text.match(lastWhitespaceRegexp);\n  return match\n    ? { prefix: match[1], whitespace: match[2], suffix: match[3] }\n    : undefined;\n}\n","import { splitOnLastWhitespace } from './split-on-last-whitespace';\n\nexport function removeTextAfterLastWhitespace(text: string): string {\n  const match = splitOnLastWhitespace(text);\n  return match ? match.prefix + match.whitespace : text;\n}\n","import { LanguageModelV1FunctionToolCall } from '@ai-sdk/provider';\nimport { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { Schema, asSchema } from '@ai-sdk/ui-utils';\nimport { InvalidToolArgumentsError } from '../../errors/invalid-tool-arguments-error';\nimport { NoSuchToolError } from '../../errors/no-such-tool-error';\nimport { ToolCallRepairError } from '../../errors/tool-call-repair-error';\nimport { CoreMessage } from '../prompt';\nimport { inferParameters } from '../tool/tool';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolSet } from './tool-set';\n\nexport async function parseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages,\n}: {\n  toolCall: LanguageModelV1FunctionToolCall;\n  tools: TOOLS | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n  system: string | undefined;\n  messages: CoreMessage[];\n}): Promise<ToolCallUnion<TOOLS>> {\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n\n  try {\n    return await doParseToolCall({ toolCall, tools });\n  } catch (error) {\n    if (\n      repairToolCall == null ||\n      !(\n        NoSuchToolError.isInstance(error) ||\n        InvalidToolArgumentsError.isInstance(error)\n      )\n    ) {\n      throw error;\n    }\n\n    let repairedToolCall: LanguageModelV1FunctionToolCall | null = null;\n\n    try {\n      repairedToolCall = await repairToolCall({\n        toolCall,\n        tools,\n        parameterSchema: ({ toolName }) =>\n          asSchema(tools[toolName].parameters).jsonSchema,\n        system,\n        messages,\n        error,\n      });\n    } catch (repairError) {\n      throw new ToolCallRepairError({\n        cause: repairError,\n        originalError: error,\n      });\n    }\n\n    // no repaired tool call returned\n    if (repairedToolCall == null) {\n      throw error;\n    }\n\n    return await doParseToolCall({ toolCall: repairedToolCall, tools });\n  }\n}\n\nasync function doParseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n}: {\n  toolCall: LanguageModelV1FunctionToolCall;\n  tools: TOOLS;\n}): Promise<ToolCallUnion<TOOLS>> {\n  const toolName = toolCall.toolName as keyof TOOLS & string;\n\n  const tool = tools[toolName];\n\n  if (tool == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools),\n    });\n  }\n\n  const schema = asSchema(tool.parameters) as Schema<\n    inferParameters<TOOLS[keyof TOOLS]['parameters']>\n  >;\n\n  // when the tool call has no arguments, we try passing an empty object to the schema\n  // (many LLMs generate empty strings for tool calls with no arguments)\n  const parseResult =\n    toolCall.args.trim() === ''\n      ? safeValidateTypes({ value: {}, schema })\n      : safeParseJSON({ text: toolCall.args, schema });\n\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error,\n    });\n  }\n\n  return {\n    type: 'tool-call',\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value,\n  };\n}\n","import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidToolArgumentsError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidToolArgumentsError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${getErrorMessage(\n      cause,\n    )}`,\n  }: {\n    message?: string;\n    toolArgs: string;\n    toolName: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n\n  static isInstance(error: unknown): error is InvalidToolArgumentsError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchToolError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchToolError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly availableTools: string[] | undefined;\n\n  constructor({\n    toolName,\n    availableTools = undefined,\n    message = `Model tried to call unavailable tool '${toolName}'. ${\n      availableTools === undefined\n        ? 'No tools are available.'\n        : `Available tools: ${availableTools.join(', ')}.`\n    }`,\n  }: {\n    toolName: string;\n    availableTools?: string[] | undefined;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n\n  static isInstance(error: unknown): error is NoSuchToolError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\nimport { InvalidToolArgumentsError } from './invalid-tool-arguments-error';\nimport { NoSuchToolError } from './no-such-tool-error';\n\nconst name = 'AI_ToolCallRepairError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolCallRepairError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalError: NoSuchToolError | InvalidToolArgumentsError;\n\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    cause: unknown;\n    originalError: NoSuchToolError | InvalidToolArgumentsError;\n  }) {\n    super({ name, message, cause });\n    this.originalError = originalError;\n  }\n\n  static isInstance(error: unknown): error is ToolCallRepairError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export type ReasoningDetail =\n  | { type: 'text'; text: string; signature?: string }\n  | { type: 'redacted'; data: string };\n\nexport function asReasoningText(\n  reasoning: Array<ReasoningDetail>,\n): string | undefined {\n  const reasoningText = reasoning\n    .filter(part => part.type === 'text')\n    .map(part => part.text)\n    .join('');\n\n  return reasoningText.length > 0 ? reasoningText : undefined;\n}\n","import { ToolResultPart } from '../prompt';\nimport { GeneratedFile } from './generated-file';\nimport { ReasoningDetail } from './reasoning-detail';\nimport { ResponseMessage } from './step-result';\nimport { ToolCallArray } from './tool-call';\nimport { ToolResultArray } from './tool-result';\nimport { ToolSet } from './tool-set';\n\n/**\nConverts the result of a `generateText` or `streamText` call to a list of response messages.\n */\nexport function toResponseMessages<TOOLS extends ToolSet>({\n  text = '',\n  files,\n  reasoning,\n  tools,\n  toolCalls,\n  toolResults,\n  messageId,\n  generateMessageId,\n}: {\n  text: string | undefined;\n  files: Array<GeneratedFile>;\n  reasoning: Array<ReasoningDetail>;\n  tools: TOOLS;\n  toolCalls: ToolCallArray<TOOLS>;\n  toolResults: ToolResultArray<TOOLS>;\n  messageId: string;\n  generateMessageId: () => string;\n}): Array<ResponseMessage> {\n  const responseMessages: Array<ResponseMessage> = [];\n\n  const content = [];\n\n  // TODO language model v2: switch to order response content (instead of type-based ordering)\n\n  if (reasoning.length > 0) {\n    content.push(\n      ...reasoning.map(part =>\n        part.type === 'text'\n          ? { ...part, type: 'reasoning' as const }\n          : { ...part, type: 'redacted-reasoning' as const },\n      ),\n    );\n  }\n\n  if (files.length > 0) {\n    content.push(\n      ...files.map(file => ({\n        type: 'file' as const,\n        data: file.base64,\n        mimeType: file.mimeType,\n      })),\n    );\n  }\n\n  if (text.length > 0) {\n    content.push({ type: 'text' as const, text });\n  }\n\n  if (toolCalls.length > 0) {\n    content.push(...toolCalls);\n  }\n\n  if (content.length > 0) {\n    responseMessages.push({\n      role: 'assistant',\n      content,\n      id: messageId,\n    });\n  }\n\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: 'tool',\n      id: generateMessageId(),\n      content: toolResults.map((toolResult): ToolResultPart => {\n        const tool = tools[toolResult.toolName];\n        return tool?.experimental_toToolResultContent != null\n          ? {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: tool.experimental_toToolResultContent(toolResult.result),\n              experimental_content: tool.experimental_toToolResultContent(\n                toolResult.result,\n              ),\n            }\n          : {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: toolResult.result,\n            };\n      }),\n    });\n  }\n\n  return responseMessages;\n}\n","import { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport {\n  asSchema,\n  DeepPartial,\n  parsePartialJson,\n  Schema,\n} from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors';\nimport { injectJsonInstruction } from '../generate-object/inject-json-instruction';\nimport {\n  FinishReason,\n  LanguageModel,\n  LanguageModelV1CallOptions,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../types/usage';\n\nexport interface Output<OUTPUT, PARTIAL> {\n  readonly type: 'object' | 'text';\n  injectIntoSystemPrompt(options: {\n    system: string | undefined;\n    model: LanguageModel;\n  }): string | undefined;\n\n  responseFormat: (options: {\n    model: LanguageModel;\n  }) => LanguageModelV1CallOptions['responseFormat'];\n\n  parsePartial(options: { text: string }): { partial: PARTIAL } | undefined;\n\n  parseOutput(\n    options: { text: string },\n    context: {\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): OUTPUT;\n}\n\nexport const text = (): Output<string, string> => ({\n  type: 'text',\n\n  responseFormat: () => ({ type: 'text' }),\n\n  injectIntoSystemPrompt({ system }: { system: string | undefined }) {\n    return system;\n  },\n\n  parsePartial({ text }: { text: string }) {\n    return { partial: text };\n  },\n\n  parseOutput({ text }: { text: string }) {\n    return text;\n  },\n});\n\nexport const object = <OUTPUT>({\n  schema: inputSchema,\n}: {\n  schema: z.Schema<OUTPUT, z.ZodTypeDef, any> | Schema<OUTPUT>;\n}): Output<OUTPUT, DeepPartial<OUTPUT>> => {\n  const schema = asSchema(inputSchema);\n\n  return {\n    type: 'object',\n\n    responseFormat: ({ model }) => ({\n      type: 'json',\n      schema: model.supportsStructuredOutputs ? schema.jsonSchema : undefined,\n    }),\n\n    injectIntoSystemPrompt({ system, model }) {\n      // when the model supports structured outputs,\n      // we can use the system prompt as is:\n      return model.supportsStructuredOutputs\n        ? system\n        : injectJsonInstruction({\n            prompt: system,\n            schema: schema.jsonSchema,\n          });\n    },\n\n    parsePartial({ text }: { text: string }) {\n      const result = parsePartialJson(text);\n\n      switch (result.state) {\n        case 'failed-parse':\n        case 'undefined-input':\n          return undefined;\n\n        case 'repaired-parse':\n        case 'successful-parse':\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value as DeepPartial<OUTPUT>,\n          };\n\n        default: {\n          const _exhaustiveCheck: never = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    parseOutput(\n      { text }: { text: string },\n      context: {\n        response: LanguageModelResponseMetadata;\n        usage: LanguageModelUsage;\n        finishReason: FinishReason;\n      },\n    ) {\n      const parseResult = safeParseJSON({ text });\n\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: could not parse the response.',\n          cause: parseResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      const validationResult = safeValidateTypes({\n        value: parseResult.value,\n        schema,\n      });\n\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: response did not match schema.',\n          cause: validationResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      return validationResult.value;\n    },\n  };\n};\n","export {\n  AISDKError,\n  APICallError,\n  EmptyResponseBodyError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  JSONParseError,\n  LoadAPIKeyError,\n  NoContentGeneratedError,\n  NoSuchModelError,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport { InvalidArgumentError } from './invalid-argument-error';\nexport { InvalidStreamPartError } from './invalid-stream-part-error';\nexport { InvalidToolArgumentsError } from './invalid-tool-arguments-error';\nexport { NoImageGeneratedError } from './no-image-generated-error';\nexport { NoObjectGeneratedError } from './no-object-generated-error';\nexport { NoOutputSpecifiedError } from './no-output-specified-error';\nexport { NoSuchToolError } from './no-such-tool-error';\nexport { ToolCallRepairError } from './tool-call-repair-error';\nexport { ToolExecutionError } from './tool-execution-error';\nexport { MCPClientError } from './mcp-client-error';\n\nexport { InvalidDataContentError } from '../core/prompt/invalid-data-content-error';\nexport { InvalidMessageRoleError } from '../core/prompt/invalid-message-role-error';\nexport { MessageConversionError } from '../core/prompt/message-conversion-error';\nexport { DownloadError } from '../util/download-error';\nexport { RetryError } from '../util/retry-error';\n","import { AISDKError } from '@ai-sdk/provider';\nimport { SingleRequestTextStreamPart } from '../core/generate-text/run-tools-transformation';\n\nconst name = 'AI_InvalidStreamPartError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidStreamPartError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly chunk: SingleRequestTextStreamPart<any>;\n\n  constructor({\n    chunk,\n    message,\n  }: {\n    chunk: SingleRequestTextStreamPart<any>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.chunk = chunk;\n  }\n\n  static isInstance(error: unknown): error is InvalidStreamPartError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_MCPClientError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * An error occurred with the MCP client.\n */\nexport class MCPClientError extends AISDKError {\n  private readonly [symbol] = true;\n\n  constructor({\n    name = 'MCPClientError',\n    message,\n    cause,\n  }: {\n    name?: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n  }\n\n  static isInstance(error: unknown): error is MCPClientError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { delay as originalDelay } from '@ai-sdk/provider-utils';\nimport { TextStreamPart } from './stream-text-result';\nimport { ToolSet } from './tool-set';\nimport { InvalidArgumentError } from '@ai-sdk/provider';\n\nconst CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m,\n};\n\n/**\n * Detects the first chunk in a buffer.\n *\n * @param buffer - The buffer to detect the first chunk in.\n *\n * @returns The first detected chunk, or `undefined` if no chunk was detected.\n */\nexport type ChunkDetector = (buffer: string) => string | undefined | null;\n\n/**\n * Smooths text streaming output.\n *\n * @param delayInMs - The delay in milliseconds between each chunk. Defaults to 10ms. Can be set to `null` to skip the delay.\n * @param chunking - Controls how the text is chunked for streaming. Use \"word\" to stream word by word (default), \"line\" to stream line by line, or provide a custom RegExp pattern for custom chunking.\n *\n * @returns A transform stream that smooths text streaming output.\n */\nexport function smoothStream<TOOLS extends ToolSet>({\n  delayInMs = 10,\n  chunking = 'word',\n  _internal: { delay = originalDelay } = {},\n}: {\n  delayInMs?: number | null;\n  chunking?: 'word' | 'line' | RegExp | ChunkDetector;\n  /**\n   * Internal. For test use only. May change without notice.\n   */\n  _internal?: {\n    delay?: (delayInMs: number | null) => Promise<void>;\n  };\n} = {}): (options: {\n  tools: TOOLS;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>> {\n  let detectChunk: ChunkDetector;\n\n  if (typeof chunking === 'function') {\n    detectChunk = buffer => {\n      const match = chunking(buffer);\n\n      if (match == null) {\n        return null;\n      }\n\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`,\n        );\n      }\n\n      return match;\n    };\n  } else {\n    const chunkingRegex =\n      typeof chunking === 'string' ? CHUNKING_REGEXPS[chunking] : chunking;\n\n    if (chunkingRegex == null) {\n      throw new InvalidArgumentError({\n        argument: 'chunking',\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`,\n      });\n    }\n\n    detectChunk = buffer => {\n      const match = chunkingRegex.exec(buffer);\n\n      if (!match) {\n        return null;\n      }\n\n      return buffer.slice(0, match.index) + match?.[0];\n    };\n  }\n\n  return () => {\n    let buffer = '';\n\n    return new TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>({\n      async transform(chunk, controller) {\n        if (chunk.type !== 'text-delta') {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: 'text-delta', textDelta: buffer });\n            buffer = '';\n          }\n\n          controller.enqueue(chunk);\n          return;\n        }\n\n        buffer += chunk.textDelta;\n\n        let match;\n\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: 'text-delta', textDelta: match });\n          buffer = buffer.slice(match.length);\n\n          await delay(delayInMs);\n        }\n      },\n    });\n  };\n}\n","import { AISDKError, LanguageModelV1Source } from '@ai-sdk/provider';\nimport { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { DataStreamString, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { Span } from '@opentelemetry/api';\nimport { ServerResponse } from 'node:http';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { InvalidStreamPartError } from '../../errors/invalid-stream-part-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { StreamData } from '../../streams/stream-data';\nimport { asArray } from '../../util/as-array';\nimport { consumeStream } from '../../util/consume-stream';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { DataStreamWriter } from '../data-stream/data-stream-writer';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { CoreAssistantMessage } from '../prompt/message';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ToolChoice,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport { addLanguageModelUsage, LanguageModelUsage } from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { mergeStreams } from '../util/merge-streams';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { splitOnLastWhitespace } from '../util/split-on-last-whitespace';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport {\n  runToolsTransformation,\n  SingleRequestTextStreamPart,\n} from './run-tools-transformation';\nimport { ResponseMessage, StepResult } from './step-result';\nimport {\n  ConsumeStreamOptions,\n  DataStreamOptions,\n  StreamTextResult,\n  TextStreamPart,\n} from './stream-text-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultUnion } from './tool-result';\nimport { ToolSet } from './tool-set';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nA transformation that is applied to the stream.\n\n@param stopStream - A function that stops the source stream.\n@param tools - The tools that are accessible to and can be called by the model. The model needs to support calling tools.\n */\nexport type StreamTextTransform<TOOLS extends ToolSet> = (options: {\n  tools: TOOLS; // for type inference\n  stopStream: () => void;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>;\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type StreamTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nCallback that is set using the `onChunk` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnChunkCallback<TOOLS extends ToolSet> = (event: {\n  chunk: Extract<\n    TextStreamPart<TOOLS>,\n    {\n      type:\n        | 'text-delta'\n        | 'reasoning'\n        | 'source'\n        | 'tool-call'\n        | 'tool-call-streaming-start'\n        | 'tool-call-delta'\n        | 'tool-result';\n    }\n  >;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnFinishCallback<TOOLS extends ToolSet> = (\n  event: Omit<StepResult<TOOLS>, 'stepType' | 'isContinued'> & {\n    /**\nDetails for all steps.\n   */\n    readonly steps: StepResult<TOOLS>[];\n  },\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateText` instead.\n\n@param model - The language model to use.\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onChunk - Callback that is called for each chunk of the stream. The stream processing will pause until the callback promise is resolved.\n@param onError - Callback that is called when an error occurs during streaming. You can use it to log errors.\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n@param onFinish - Callback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\n@return\nA result object for accessing different stream types and additional information.\n */\nexport function streamText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  PARTIAL_OUTPUT = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_toolCallStreaming = false,\n  toolCallStreaming = experimental_toolCallStreaming,\n  experimental_activeTools: activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  onChunk,\n  onError,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now = originalNow,\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n    */\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, PARTIAL_OUTPUT>;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\nEnable streaming of tool call deltas as they are generated. Disabled by default.\n     */\n    toolCallStreaming?: boolean;\n\n    /**\n@deprecated Use `toolCallStreaming` instead.\n     */\n    experimental_toolCallStreaming?: boolean;\n\n    /**\nOptional stream transformations.\nThey are applied in the order they are provided.\nThe stream transformations must maintain the stream structure for streamText to work correctly.\n     */\n    experimental_transform?:\n      | StreamTextTransform<TOOLS>\n      | Array<StreamTextTransform<TOOLS>>;\n\n    /**\nCallback that is called for each chunk of the stream.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onChunk?: StreamTextOnChunkCallback<TOOLS>;\n\n    /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onError?: StreamTextOnErrorCallback;\n\n    /**\nCallback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\nThe usage is the combined usage of all steps.\n     */\n    onFinish?: StreamTextOnFinishCallback<TOOLS>;\n\n    /**\nCallback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: StreamTextOnStepFinishCallback<TOOLS>;\n\n    /**\nInternal. For test use only. May change without notice.\n     */\n    _internal?: {\n      now?: () => number;\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): StreamTextResult<TOOLS, PARTIAL_OUTPUT> {\n  return new DefaultStreamTextResult<TOOLS, OUTPUT, PARTIAL_OUTPUT>({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n  });\n}\n\ntype EnrichedStreamPart<TOOLS extends ToolSet, PARTIAL_OUTPUT> = {\n  part: TextStreamPart<TOOLS>;\n  partialOutput: PARTIAL_OUTPUT | undefined;\n};\n\nfunction createOutputTransformStream<\n  TOOLS extends ToolSet,\n  OUTPUT,\n  PARTIAL_OUTPUT,\n>(\n  output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined,\n): TransformStream<\n  TextStreamPart<TOOLS>,\n  EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n> {\n  if (!output) {\n    return new TransformStream<\n      TextStreamPart<TOOLS>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n      },\n    });\n  }\n\n  let text = '';\n  let textChunk = '';\n  let lastPublishedJson = '';\n\n  function publishTextChunk({\n    controller,\n    partialOutput = undefined,\n  }: {\n    controller: TransformStreamDefaultController<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >;\n    partialOutput?: PARTIAL_OUTPUT;\n  }) {\n    controller.enqueue({\n      part: { type: 'text-delta', textDelta: textChunk },\n      partialOutput,\n    });\n    textChunk = '';\n  }\n\n  return new TransformStream<\n    TextStreamPart<TOOLS>,\n    EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n  >({\n    transform(chunk, controller) {\n      // ensure that we publish the last text chunk before the step finish:\n      if (chunk.type === 'step-finish') {\n        publishTextChunk({ controller });\n      }\n\n      if (chunk.type !== 'text-delta') {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n        return;\n      }\n\n      text += chunk.textDelta;\n      textChunk += chunk.textDelta;\n\n      // only publish if partial json can be parsed:\n      const result = output.parsePartial({ text });\n      if (result != null) {\n        // only send new json if it has changed:\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    },\n\n    flush(controller) {\n      // publish remaining text (there should be none if the content was correctly formatted):\n      if (textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n    },\n  });\n}\n\nclass DefaultStreamTextResult<TOOLS extends ToolSet, OUTPUT, PARTIAL_OUTPUT>\n  implements StreamTextResult<TOOLS, PARTIAL_OUTPUT>\n{\n  private readonly warningsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['warnings']>\n  >();\n  private readonly usagePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['usage']>\n  >();\n  private readonly finishReasonPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['finishReason']>\n  >();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    Awaited<\n      StreamTextResult<TOOLS, PARTIAL_OUTPUT>['experimental_providerMetadata']\n    >\n  >();\n  private readonly textPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['text']>\n  >();\n  private readonly reasoningPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoning']>\n  >();\n  private readonly reasoningDetailsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoningDetails']>\n  >();\n  private readonly sourcesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['sources']>\n  >();\n  private readonly filesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['files']>\n  >();\n  private readonly toolCallsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolCalls']>\n  >();\n  private readonly toolResultsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolResults']>\n  >();\n  private readonly requestPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['request']>\n  >();\n  private readonly responsePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['response']>\n  >();\n  private readonly stepsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['steps']>\n  >();\n\n  private readonly addStream: (\n    stream: ReadableStream<TextStreamPart<TOOLS>>,\n  ) => void;\n\n  private readonly closeStream: () => void;\n\n  private baseStream: ReadableStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>>;\n\n  private output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms,\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    tools: TOOLS | undefined;\n    toolChoice: ToolChoice<TOOLS> | undefined;\n    toolCallStreaming: boolean;\n    transforms: Array<StreamTextTransform<TOOLS>>;\n    activeTools: Array<keyof TOOLS> | undefined;\n    repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n    maxSteps: number;\n    output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n    continueSteps: boolean;\n    providerOptions: ProviderOptions | undefined;\n    now: () => number;\n    currentDate: () => Date;\n    generateId: () => string;\n    generateMessageId: () => string;\n\n    // callbacks:\n    onChunk: undefined | StreamTextOnChunkCallback<TOOLS>;\n    onError: undefined | StreamTextOnErrorCallback;\n    onFinish: undefined | StreamTextOnFinishCallback<TOOLS>;\n    onStepFinish: undefined | StreamTextOnStepFinishCallback<TOOLS>;\n  }) {\n    if (maxSteps < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxSteps',\n        value: maxSteps,\n        message: 'maxSteps must be at least 1',\n      });\n    }\n\n    this.output = output;\n\n    // event processor for telemetry, invoking callbacks, etc.\n    // The event processor reads the transformed stream to enable correct\n    // recording of the final transformed outputs.\n    let recordedStepText = '';\n    let recordedContinuationText = '';\n    let recordedFullText = '';\n\n    let stepReasoning: Array<ReasoningDetail> = [];\n    let stepFiles: Array<GeneratedFile> = [];\n    let activeReasoningText: undefined | (ReasoningDetail & { type: 'text' }) =\n      undefined;\n\n    let recordedStepSources: LanguageModelV1Source[] = [];\n    const recordedSources: LanguageModelV1Source[] = [];\n\n    const recordedResponse: LanguageModelResponseMetadata & {\n      messages: Array<ResponseMessage>;\n    } = {\n      id: generateId(),\n      timestamp: currentDate(),\n      modelId: model.modelId,\n      messages: [],\n    };\n    let recordedToolCalls: ToolCallUnion<TOOLS>[] = [];\n    let recordedToolResults: ToolResultUnion<TOOLS>[] = [];\n    let recordedFinishReason: FinishReason | undefined = undefined;\n    let recordedUsage: LanguageModelUsage | undefined = undefined;\n    let stepType: 'initial' | 'continue' | 'tool-result' = 'initial';\n    const recordedSteps: StepResult<TOOLS>[] = [];\n    let rootSpan!: Span;\n\n    const eventProcessor = new TransformStream<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      async transform(chunk, controller) {\n        controller.enqueue(chunk); // forward the chunk to the next stream\n\n        const { part } = chunk;\n\n        if (\n          part.type === 'text-delta' ||\n          part.type === 'reasoning' ||\n          part.type === 'source' ||\n          part.type === 'tool-call' ||\n          part.type === 'tool-result' ||\n          part.type === 'tool-call-streaming-start' ||\n          part.type === 'tool-call-delta'\n        ) {\n          await onChunk?.({ chunk: part });\n        }\n\n        if (part.type === 'error') {\n          await onError?.({ error: part.error });\n        }\n\n        if (part.type === 'text-delta') {\n          recordedStepText += part.textDelta;\n          recordedContinuationText += part.textDelta;\n          recordedFullText += part.textDelta;\n        }\n\n        if (part.type === 'reasoning') {\n          if (activeReasoningText == null) {\n            activeReasoningText = { type: 'text', text: part.textDelta };\n            stepReasoning.push(activeReasoningText);\n          } else {\n            activeReasoningText.text += part.textDelta;\n          }\n        }\n\n        if (part.type === 'reasoning-signature') {\n          if (activeReasoningText == null) {\n            throw new AISDKError({\n              name: 'InvalidStreamPart',\n              message: 'reasoning-signature without reasoning',\n            });\n          }\n\n          activeReasoningText.signature = part.signature;\n          activeReasoningText = undefined; // signature concludes reasoning part\n        }\n\n        if (part.type === 'redacted-reasoning') {\n          stepReasoning.push({ type: 'redacted', data: part.data });\n        }\n\n        if (part.type === 'file') {\n          stepFiles.push(part);\n        }\n\n        if (part.type === 'source') {\n          recordedSources.push(part.source);\n          recordedStepSources.push(part.source);\n        }\n\n        if (part.type === 'tool-call') {\n          recordedToolCalls.push(part);\n        }\n\n        if (part.type === 'tool-result') {\n          recordedToolResults.push(part);\n        }\n\n        if (part.type === 'step-finish') {\n          const stepMessages = toResponseMessages({\n            text: recordedContinuationText,\n            files: stepFiles,\n            reasoning: stepReasoning,\n            tools: tools ?? ({} as TOOLS),\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            messageId: part.messageId,\n            generateMessageId,\n          });\n\n          // determine the next step type\n          const currentStep = recordedSteps.length;\n          let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n          if (currentStep + 1 < maxSteps) {\n            if (\n              continueSteps &&\n              part.finishReason === 'length' &&\n              // only use continue when there are no tool calls:\n              recordedToolCalls.length === 0\n            ) {\n              nextStepType = 'continue';\n            } else if (\n              // there are tool calls:\n              recordedToolCalls.length > 0 &&\n              // all current tool calls have results:\n              recordedToolResults.length === recordedToolCalls.length\n            ) {\n              nextStepType = 'tool-result';\n            }\n          }\n\n          // Add step information (after response messages are updated):\n          const currentStepResult: StepResult<TOOLS> = {\n            stepType,\n            text: recordedStepText,\n            reasoning: asReasoningText(stepReasoning),\n            reasoningDetails: stepReasoning,\n            files: stepFiles,\n            sources: recordedStepSources,\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: part.warnings,\n            logprobs: part.logprobs,\n            request: part.request,\n            response: {\n              ...part.response,\n              messages: [...recordedResponse.messages, ...stepMessages],\n            },\n            providerMetadata: part.experimental_providerMetadata,\n            experimental_providerMetadata: part.experimental_providerMetadata,\n            isContinued: part.isContinued,\n          };\n\n          await onStepFinish?.(currentStepResult);\n\n          recordedSteps.push(currentStepResult);\n\n          recordedToolCalls = [];\n          recordedToolResults = [];\n          recordedStepText = '';\n          recordedStepSources = [];\n          stepReasoning = [];\n          stepFiles = [];\n          activeReasoningText = undefined;\n\n          if (nextStepType !== 'done') {\n            stepType = nextStepType;\n          }\n\n          if (nextStepType !== 'continue') {\n            recordedResponse.messages.push(...stepMessages);\n            recordedContinuationText = '';\n          }\n        }\n\n        if (part.type === 'finish') {\n          recordedResponse.id = part.response.id;\n          recordedResponse.timestamp = part.response.timestamp;\n          recordedResponse.modelId = part.response.modelId;\n          recordedResponse.headers = part.response.headers;\n          recordedUsage = part.usage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            return; // no steps recorded (e.g. in error scenario)\n          }\n\n          // from last step (when there are errors there may be no last step)\n          const lastStep = recordedSteps[recordedSteps.length - 1];\n\n          self.warningsPromise.resolve(lastStep.warnings);\n          self.requestPromise.resolve(lastStep.request);\n          self.responsePromise.resolve(lastStep.response);\n          self.toolCallsPromise.resolve(lastStep.toolCalls);\n          self.toolResultsPromise.resolve(lastStep.toolResults);\n          self.providerMetadataPromise.resolve(\n            lastStep.experimental_providerMetadata,\n          );\n          self.reasoningPromise.resolve(lastStep.reasoning);\n          self.reasoningDetailsPromise.resolve(lastStep.reasoningDetails);\n\n          // derived:\n          const finishReason = recordedFinishReason ?? 'unknown';\n          const usage = recordedUsage ?? {\n            completionTokens: NaN,\n            promptTokens: NaN,\n            totalTokens: NaN,\n          };\n\n          // from finish:\n          self.finishReasonPromise.resolve(finishReason);\n          self.usagePromise.resolve(usage);\n\n          // aggregate results:\n          self.textPromise.resolve(recordedFullText);\n          self.sourcesPromise.resolve(recordedSources);\n          self.filesPromise.resolve(lastStep.files);\n          self.stepsPromise.resolve(recordedSteps);\n\n          // call onFinish callback:\n          await onFinish?.({\n            finishReason,\n            logprobs: undefined,\n            usage,\n            text: recordedFullText,\n            reasoning: lastStep.reasoning,\n            reasoningDetails: lastStep.reasoningDetails,\n            files: lastStep.files,\n            sources: lastStep.sources,\n            toolCalls: lastStep.toolCalls,\n            toolResults: lastStep.toolResults,\n            request: lastStep.request ?? {},\n            response: lastStep.response,\n            warnings: lastStep.warnings,\n            providerMetadata: lastStep.providerMetadata,\n            experimental_providerMetadata:\n              lastStep.experimental_providerMetadata,\n            steps: recordedSteps,\n          });\n\n          // Add response information to the root span:\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                'ai.response.finishReason': finishReason,\n                'ai.response.text': { output: () => recordedFullText },\n                'ai.response.toolCalls': {\n                  output: () =>\n                    lastStep.toolCalls?.length\n                      ? JSON.stringify(lastStep.toolCalls)\n                      : undefined,\n                },\n\n                'ai.usage.promptTokens': usage.promptTokens,\n                'ai.usage.completionTokens': usage.completionTokens,\n              },\n            }),\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      },\n    });\n\n    // initialize the stitchable stream and the transformed stream:\n    const stitchableStream = createStitchableStream<TextStreamPart<TOOLS>>();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n\n    let stream = stitchableStream.stream;\n\n    // transform the stream before output parsing\n    // to enable replacement of stream segments:\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools: tools as TOOLS,\n          stopStream() {\n            stitchableStream.terminate();\n          },\n        }),\n      );\n    }\n\n    this.baseStream = stream\n      .pipeThrough(createOutputTransformStream(output))\n      .pipeThrough(eventProcessor);\n\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const tracer = getTracer(telemetry);\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const initialPrompt = standardizePrompt({\n      prompt: {\n        system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n        prompt,\n        messages,\n      },\n      tools,\n    });\n\n    const self = this;\n\n    recordSpan({\n      name: 'ai.streamText',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: 'ai.streamText', telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.settings.maxSteps': maxSteps,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpanArg => {\n        rootSpan = rootSpanArg;\n\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage,\n          stepType,\n          previousStepText,\n          hasLeadingWhitespace,\n          messageId,\n        }: {\n          currentStep: number;\n          responseMessages: Array<ResponseMessage>;\n          usage: LanguageModelUsage;\n          stepType: 'initial' | 'continue' | 'tool-result';\n          previousStepText: string;\n          hasLeadingWhitespace: boolean;\n          messageId: string;\n        }) {\n          // after the 1st step, we need to switch to messages format:\n          const promptFormat =\n            responseMessages.length === 0 ? initialPrompt.type : 'messages';\n\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages,\n          ];\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              type: promptFormat,\n              system: initialPrompt.system,\n              messages: stepInputMessages,\n            },\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const mode = {\n            type: 'regular' as const,\n            ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools }),\n          };\n\n          const {\n            result: { stream, warnings, rawResponse, request },\n            doStreamSpan,\n            startTimestampMs,\n          } = await retry(() =>\n            recordSpan({\n              name: 'ai.streamText.doStream',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.streamText.doStream',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => promptFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.prompt.tools': {\n                    // convert the language model level tools:\n                    input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                  },\n                  'ai.prompt.toolChoice': {\n                    input: () =>\n                      mode.toolChoice != null\n                        ? JSON.stringify(mode.toolChoice)\n                        : undefined,\n                  },\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.stop_sequences': settings.stopSequences,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async doStreamSpan => ({\n                startTimestampMs: now(), // get before the call\n                doStreamSpan,\n                result: await model.doStream({\n                  mode,\n                  ...prepareCallSettings(settings),\n                  inputFormat: promptFormat,\n                  responseFormat: output?.responseFormat({ model }),\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                }),\n              }),\n            }),\n          );\n\n          const transformedStream = runToolsTransformation({\n            tools,\n            generatorStream: stream,\n            toolCallStreaming,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n          });\n\n          const stepRequest = request ?? {};\n          const stepToolCalls: ToolCallUnion<TOOLS>[] = [];\n          const stepToolResults: ToolResultUnion<TOOLS>[] = [];\n\n          const stepReasoning: Array<ReasoningDetail> = [];\n          const stepFiles: Array<GeneratedFile> = [];\n          let activeReasoningText:\n            | undefined\n            | (ReasoningDetail & { type: 'text' }) = undefined;\n\n          let stepFinishReason: FinishReason = 'unknown';\n          let stepUsage: LanguageModelUsage = {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          };\n          let stepProviderMetadata: ProviderMetadata | undefined;\n          let stepFirstChunk = true;\n          let stepText = '';\n          let fullStepText = stepType === 'continue' ? previousStepText : '';\n          let stepLogProbs: LogProbs | undefined;\n          let stepResponse: { id: string; timestamp: Date; modelId: string } = {\n            id: generateId(),\n            timestamp: currentDate(),\n            modelId: model.modelId,\n          };\n\n          // chunk buffer when using continue:\n          let chunkBuffer = '';\n          let chunkTextPublished = false;\n          let inWhitespacePrefix = true;\n          let hasWhitespaceSuffix = false; // for next step. when true, step ended with whitespace\n\n          async function publishTextChunk({\n            controller,\n            chunk,\n          }: {\n            controller: TransformStreamDefaultController<TextStreamPart<TOOLS>>;\n            chunk: TextStreamPart<TOOLS> & { type: 'text-delta' };\n          }) {\n            controller.enqueue(chunk);\n\n            stepText += chunk.textDelta;\n            fullStepText += chunk.textDelta;\n            chunkTextPublished = true;\n            hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n          }\n\n          self.addStream(\n            transformedStream.pipeThrough(\n              new TransformStream<\n                SingleRequestTextStreamPart<TOOLS>,\n                TextStreamPart<TOOLS>\n              >({\n                async transform(chunk, controller): Promise<void> {\n                  if (stepFirstChunk) {\n                    // Telemetry for first chunk:\n                    const msToFirstChunk = now() - startTimestampMs;\n\n                    stepFirstChunk = false;\n\n                    doStreamSpan.addEvent('ai.stream.firstChunk', {\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    doStreamSpan.setAttributes({\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    // Step start:\n                    controller.enqueue({\n                      type: 'step-start',\n                      messageId,\n                      request: stepRequest,\n                      warnings: warnings ?? [],\n                    });\n                  }\n\n                  // Filter out empty text deltas\n                  if (\n                    chunk.type === 'text-delta' &&\n                    chunk.textDelta.length === 0\n                  ) {\n                    return;\n                  }\n\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case 'text-delta': {\n                      if (continueSteps) {\n                        // when a new step starts, leading whitespace is to be discarded\n                        // when there is already preceding whitespace in the chunk buffer\n                        const trimmedChunkText =\n                          inWhitespacePrefix && hasLeadingWhitespace\n                            ? chunk.textDelta.trimStart()\n                            : chunk.textDelta;\n\n                        if (trimmedChunkText.length === 0) {\n                          break;\n                        }\n\n                        inWhitespacePrefix = false;\n                        chunkBuffer += trimmedChunkText;\n\n                        const split = splitOnLastWhitespace(chunkBuffer);\n\n                        // publish the text until the last whitespace:\n                        if (split != null) {\n                          chunkBuffer = split.suffix;\n\n                          await publishTextChunk({\n                            controller,\n                            chunk: {\n                              type: 'text-delta',\n                              textDelta: split.prefix + split.whitespace,\n                            },\n                          });\n                        }\n                      } else {\n                        await publishTextChunk({ controller, chunk });\n                      }\n                      break;\n                    }\n\n                    case 'reasoning': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        activeReasoningText = {\n                          type: 'text',\n                          text: chunk.textDelta,\n                        };\n                        stepReasoning.push(activeReasoningText);\n                      } else {\n                        activeReasoningText.text += chunk.textDelta;\n                      }\n\n                      break;\n                    }\n\n                    case 'reasoning-signature': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        throw new InvalidStreamPartError({\n                          chunk,\n                          message: 'reasoning-signature without reasoning',\n                        });\n                      }\n\n                      activeReasoningText.signature = chunk.signature;\n                      activeReasoningText = undefined; // signature concludes reasoning part\n                      break;\n                    }\n\n                    case 'redacted-reasoning': {\n                      controller.enqueue(chunk);\n                      stepReasoning.push({\n                        type: 'redacted',\n                        data: chunk.data,\n                      });\n\n                      break;\n                    }\n\n                    case 'tool-call': {\n                      controller.enqueue(chunk);\n                      // store tool calls for onFinish callback and toolCalls promise:\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n\n                    case 'tool-result': {\n                      controller.enqueue(chunk);\n                      // store tool results for onFinish callback and toolResults promise:\n                      stepToolResults.push(chunk);\n                      break;\n                    }\n\n                    case 'response-metadata': {\n                      stepResponse = {\n                        id: chunk.id ?? stepResponse.id,\n                        timestamp: chunk.timestamp ?? stepResponse.timestamp,\n                        modelId: chunk.modelId ?? stepResponse.modelId,\n                      };\n                      break;\n                    }\n\n                    case 'finish': {\n                      // Note: tool executions might not be finished yet when the finish event is emitted.\n                      // store usage and finish reason for promises and onFinish callback:\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata =\n                        chunk.experimental_providerMetadata;\n                      stepLogProbs = chunk.logprobs;\n\n                      // Telemetry for finish event timing\n                      // (since tool executions can take longer and distort calculations)\n                      const msToFinish = now() - startTimestampMs;\n                      doStreamSpan.addEvent('ai.stream.finish');\n                      doStreamSpan.setAttributes({\n                        'ai.response.msToFinish': msToFinish,\n                        'ai.response.avgCompletionTokensPerSecond':\n                          (1000 * stepUsage.completionTokens) / msToFinish,\n                      });\n\n                      break;\n                    }\n\n                    case 'file': {\n                      stepFiles.push(chunk);\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    // forward:\n                    case 'source':\n                    case 'tool-call-streaming-start':\n                    case 'tool-call-delta': {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'error': {\n                      controller.enqueue(chunk);\n                      stepFinishReason = 'error';\n                      break;\n                    }\n\n                    default: {\n                      const exhaustiveCheck: never = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson =\n                    stepToolCalls.length > 0\n                      ? JSON.stringify(stepToolCalls)\n                      : undefined;\n\n                  // determine the next step type\n                  let nextStepType: 'done' | 'continue' | 'tool-result' =\n                    'done';\n                  if (currentStep + 1 < maxSteps) {\n                    if (\n                      continueSteps &&\n                      stepFinishReason === 'length' &&\n                      // only use continue when there are no tool calls:\n                      stepToolCalls.length === 0\n                    ) {\n                      nextStepType = 'continue';\n                    } else if (\n                      // there are tool calls:\n                      stepToolCalls.length > 0 &&\n                      // all current tool calls have results:\n                      stepToolResults.length === stepToolCalls.length\n                    ) {\n                      nextStepType = 'tool-result';\n                    }\n                  }\n\n                  // when using continuation, publish buffer on final step or if there\n                  // was no whitespace in the step:\n                  if (\n                    continueSteps &&\n                    chunkBuffer.length > 0 &&\n                    (nextStepType !== 'continue' || // when the next step is a regular step, publish the buffer\n                      (stepType === 'continue' && !chunkTextPublished)) // when the next step is a continue step, publish the buffer if no text was published in the step\n                  ) {\n                    await publishTextChunk({\n                      controller,\n                      chunk: {\n                        type: 'text-delta',\n                        textDelta: chunkBuffer,\n                      },\n                    });\n                    chunkBuffer = '';\n                  }\n\n                  // record telemetry information first to ensure best effort timing\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          'ai.response.finishReason': stepFinishReason,\n                          'ai.response.text': { output: () => stepText },\n                          'ai.response.toolCalls': {\n                            output: () => stepToolCallsJson,\n                          },\n                          'ai.response.id': stepResponse.id,\n                          'ai.response.model': stepResponse.modelId,\n                          'ai.response.timestamp':\n                            stepResponse.timestamp.toISOString(),\n\n                          'ai.usage.promptTokens': stepUsage.promptTokens,\n                          'ai.usage.completionTokens':\n                            stepUsage.completionTokens,\n\n                          // standardized gen-ai llm span attributes:\n                          'gen_ai.response.finish_reasons': [stepFinishReason],\n                          'gen_ai.response.id': stepResponse.id,\n                          'gen_ai.response.model': stepResponse.modelId,\n                          'gen_ai.usage.input_tokens': stepUsage.promptTokens,\n                          'gen_ai.usage.output_tokens':\n                            stepUsage.completionTokens,\n                        },\n                      }),\n                    );\n                  } catch (error) {\n                    // ignore error setting telemetry attributes\n                  } finally {\n                    // finish doStreamSpan before other operations for correct timing:\n                    doStreamSpan.end();\n                  }\n\n                  controller.enqueue({\n                    type: 'step-finish',\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    experimental_providerMetadata: stepProviderMetadata,\n                    logprobs: stepLogProbs,\n                    request: stepRequest,\n                    response: {\n                      ...stepResponse,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    isContinued: nextStepType === 'continue',\n                    messageId,\n                  });\n\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n\n                  if (nextStepType === 'done') {\n                    controller.enqueue({\n                      type: 'finish',\n                      finishReason: stepFinishReason,\n                      usage: combinedUsage,\n                      providerMetadata: stepProviderMetadata,\n                      experimental_providerMetadata: stepProviderMetadata,\n                      logprobs: stepLogProbs,\n                      response: {\n                        ...stepResponse,\n                        headers: rawResponse?.headers,\n                      },\n                    });\n\n                    self.closeStream(); // close the stitchable stream\n                  } else {\n                    // append to messages for the next step:\n                    if (stepType === 'continue') {\n                      // continue step: update the last assistant message\n                      // continue is only possible when there are no tool calls,\n                      // so we can assume that there is a single last assistant message:\n                      const lastMessage = responseMessages[\n                        responseMessages.length - 1\n                      ] as CoreAssistantMessage;\n\n                      if (typeof lastMessage.content === 'string') {\n                        lastMessage.content += stepText;\n                      } else {\n                        lastMessage.content.push({\n                          text: stepText,\n                          type: 'text',\n                        });\n                      }\n                    } else {\n                      responseMessages.push(\n                        ...toResponseMessages({\n                          text: stepText,\n                          files: stepFiles,\n                          reasoning: stepReasoning,\n                          tools: tools ?? ({} as TOOLS),\n                          toolCalls: stepToolCalls,\n                          toolResults: stepToolResults,\n                          messageId,\n                          generateMessageId,\n                        }),\n                      );\n                    }\n\n                    await streamStep({\n                      currentStep: currentStep + 1,\n                      responseMessages,\n                      usage: combinedUsage,\n                      stepType: nextStepType,\n                      previousStepText: fullStepText,\n                      hasLeadingWhitespace: hasWhitespaceSuffix,\n                      messageId:\n                        // keep the same id when continuing a step:\n                        nextStepType === 'continue'\n                          ? messageId\n                          : generateMessageId(),\n                    });\n                  }\n                },\n              }),\n            ),\n          );\n        }\n\n        // add the initial stream to the stitchable stream\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          },\n          previousStepText: '',\n          stepType: 'initial',\n          hasLeadingWhitespace: false,\n          messageId: generateMessageId(),\n        });\n      },\n    }).catch(error => {\n      // add an error stream part and close the streams:\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: 'error', error });\n            controller.close();\n          },\n        }),\n      );\n      self.closeStream();\n    });\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get finishReason() {\n    return this.finishReasonPromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get text() {\n    return this.textPromise.value;\n  }\n\n  get reasoning() {\n    return this.reasoningPromise.value;\n  }\n\n  get reasoningDetails() {\n    return this.reasoningDetailsPromise.value;\n  }\n\n  get sources() {\n    return this.sourcesPromise.value;\n  }\n\n  get files() {\n    return this.filesPromise.value;\n  }\n\n  get toolCalls() {\n    return this.toolCallsPromise.value;\n  }\n\n  get toolResults() {\n    return this.toolResultsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get steps() {\n    return this.stepsPromise.value;\n  }\n\n  /**\nSplit out a new stream from the original stream.\nThe original stream is replaced to allow for further splitting,\nsince we do not know how many times the stream will be split.\n\nNote: this leads to buffering the stream content on the server.\nHowever, the LLM results are expected to be small enough to not cause issues.\n   */\n  private teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>, string>({\n          transform({ part }, controller) {\n            if (part.type === 'text-delta') {\n              controller.enqueue(part.textDelta);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<TextStreamPart<TOOLS>> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          TextStreamPart<TOOLS>\n        >({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          },\n        }),\n      ),\n    );\n  }\n\n  async consumeStream(options?: ConsumeStreamOptions): Promise<void> {\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options?.onError,\n      });\n    } catch (error) {\n      options?.onError?.(error);\n    }\n  }\n\n  get experimental_partialOutputStream(): AsyncIterableStream<PARTIAL_OUTPUT> {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          PARTIAL_OUTPUT\n        >({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  private toDataStreamInternal({\n    getErrorMessage = () => 'An error occurred.', // mask error messages for safety by default\n    sendUsage = true,\n    sendReasoning = false,\n    sendSources = false,\n    experimental_sendFinish = true,\n  }: {\n    getErrorMessage: ((error: unknown) => string) | undefined;\n    sendUsage: boolean | undefined;\n    sendReasoning: boolean | undefined;\n    sendSources: boolean | undefined;\n    experimental_sendFinish: boolean | undefined;\n  }): ReadableStream<DataStreamString> {\n    return this.fullStream.pipeThrough(\n      new TransformStream<TextStreamPart<TOOLS>, DataStreamString>({\n        transform: async (chunk, controller) => {\n          const chunkType = chunk.type;\n          switch (chunkType) {\n            case 'text-delta': {\n              controller.enqueue(formatDataStreamPart('text', chunk.textDelta));\n              break;\n            }\n\n            case 'reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning', chunk.textDelta),\n                );\n              }\n              break;\n            }\n\n            case 'redacted-reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('redacted_reasoning', {\n                    data: chunk.data,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'reasoning-signature': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning_signature', {\n                    signature: chunk.signature,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'file': {\n              controller.enqueue(\n                formatDataStreamPart('file', {\n                  mimeType: chunk.mimeType,\n                  data: chunk.base64,\n                }),\n              );\n              break;\n            }\n\n            case 'source': {\n              if (sendSources) {\n                controller.enqueue(\n                  formatDataStreamPart('source', chunk.source),\n                );\n              }\n              break;\n            }\n\n            case 'tool-call-streaming-start': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_streaming_start', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call-delta': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_delta', {\n                  toolCallId: chunk.toolCallId,\n                  argsTextDelta: chunk.argsTextDelta,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  args: chunk.args,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-result': {\n              controller.enqueue(\n                formatDataStreamPart('tool_result', {\n                  toolCallId: chunk.toolCallId,\n                  result: chunk.result,\n                }),\n              );\n              break;\n            }\n\n            case 'error': {\n              controller.enqueue(\n                formatDataStreamPart('error', getErrorMessage(chunk.error)),\n              );\n              break;\n            }\n\n            case 'step-start': {\n              controller.enqueue(\n                formatDataStreamPart('start_step', {\n                  messageId: chunk.messageId,\n                }),\n              );\n              break;\n            }\n\n            case 'step-finish': {\n              controller.enqueue(\n                formatDataStreamPart('finish_step', {\n                  finishReason: chunk.finishReason,\n                  usage: sendUsage\n                    ? {\n                        promptTokens: chunk.usage.promptTokens,\n                        completionTokens: chunk.usage.completionTokens,\n                      }\n                    : undefined,\n                  isContinued: chunk.isContinued,\n                }),\n              );\n              break;\n            }\n\n            case 'finish': {\n              if (experimental_sendFinish) {\n                controller.enqueue(\n                  formatDataStreamPart('finish_message', {\n                    finishReason: chunk.finishReason,\n                    usage: sendUsage\n                      ? {\n                          promptTokens: chunk.usage.promptTokens,\n                          completionTokens: chunk.usage.completionTokens,\n                        }\n                      : undefined,\n                  }),\n                );\n              }\n              break;\n            }\n\n            default: {\n              const exhaustiveCheck: never = chunkType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n      }),\n    );\n  }\n\n  pipeDataStreamToResponse(\n    response: ServerResponse,\n    {\n      status,\n      statusText,\n      headers,\n      data,\n      getErrorMessage,\n      sendUsage,\n      sendReasoning,\n      sendSources,\n      experimental_sendFinish,\n    }: ResponseInit &\n      DataStreamOptions & {\n        data?: StreamData;\n        getErrorMessage?: (error: unknown) => string;\n      } = {},\n  ) {\n    writeToServerResponse({\n      response,\n      status,\n      statusText,\n      headers: prepareOutgoingHttpHeaders(headers, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n      stream: this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n    });\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())\n  toDataStream(\n    options?: DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    },\n  ) {\n    const stream = this.toDataStreamInternal({\n      getErrorMessage: options?.getErrorMessage,\n      sendUsage: options?.sendUsage,\n      sendReasoning: options?.sendReasoning,\n      sendSources: options?.sendSources,\n      experimental_sendFinish: options?.experimental_sendFinish,\n    }).pipeThrough(new TextEncoderStream());\n\n    return options?.data ? mergeStreams(options?.data.stream, stream) : stream;\n  }\n\n  mergeIntoDataStream(writer: DataStreamWriter, options?: DataStreamOptions) {\n    writer.merge(\n      this.toDataStreamInternal({\n        getErrorMessage: writer.onError,\n        sendUsage: options?.sendUsage,\n        sendReasoning: options?.sendReasoning,\n        sendSources: options?.sendSources,\n        experimental_sendFinish: options?.experimental_sendFinish,\n      }),\n    );\n  }\n\n  toDataStreamResponse({\n    headers,\n    status,\n    statusText,\n    data,\n    getErrorMessage,\n    sendUsage,\n    sendReasoning,\n    sendSources,\n    experimental_sendFinish,\n  }: ResponseInit &\n    DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    } = {}): Response {\n    return new Response(\n      this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n      {\n        status,\n        statusText,\n        headers: prepareResponseHeaders(headers, {\n          contentType: 'text/plain; charset=utf-8',\n          dataStreamVersion: 'v1',\n        }),\n      },\n    );\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n","export function asArray<T>(value: T | T[] | undefined): T[] {\n  return value === undefined ? [] : Array.isArray(value) ? value : [value];\n}\n","/**\n * Consumes a ReadableStream until it's fully read.\n *\n * This function reads the stream chunk by chunk until the stream is exhausted.\n * It doesn't process or return the data from the stream; it simply ensures\n * that the entire stream is read.\n *\n * @param {ReadableStream} stream - The ReadableStream to be consumed.\n * @returns {Promise<void>} A promise that resolves when the stream is fully consumed.\n */\nexport async function consumeStream({\n  stream,\n  onError,\n}: {\n  stream: ReadableStream;\n  onError?: (error: unknown) => void;\n}): Promise<void> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done) break;\n    }\n  } catch (error) {\n    onError?.(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n","/**\n * Merges two readable streams into a single readable stream, emitting values\n * from each stream as they become available.\n *\n * The first stream is prioritized over the second stream. If both streams have\n * values available, the first stream's value is emitted first.\n *\n * @template VALUE1 - The type of values emitted by the first stream.\n * @template VALUE2 - The type of values emitted by the second stream.\n * @param {ReadableStream<VALUE1>} stream1 - The first readable stream.\n * @param {ReadableStream<VALUE2>} stream2 - The second readable stream.\n * @returns {ReadableStream<VALUE1 | VALUE2>} A new readable stream that emits values from both input streams.\n */\nexport function mergeStreams<VALUE1, VALUE2>(\n  stream1: ReadableStream<VALUE1>,\n  stream2: ReadableStream<VALUE2>,\n): ReadableStream<VALUE1 | VALUE2> {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n\n  let lastRead1: Promise<ReadableStreamReadResult<VALUE1>> | undefined =\n    undefined;\n  let lastRead2: Promise<ReadableStreamReadResult<VALUE2>> | undefined =\n    undefined;\n\n  let stream1Done = false;\n  let stream2Done = false;\n\n  // only use when stream 2 is done:\n  async function readStream1(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n\n      const result = await lastRead1;\n      lastRead1 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  // only use when stream 1 is done:\n  async function readStream2(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n\n      const result = await lastRead2;\n      lastRead2 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  return new ReadableStream<VALUE1 | VALUE2>({\n    async pull(controller) {\n      try {\n        // stream 1 is done, we can only read from stream 2:\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n\n        // stream 2 is done, we can only read from stream 1:\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n\n        // pull the next value from the stream that was read last:\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n\n        // Note on Promise.race (prioritizing stream 1 over stream 2):\n        // If the iterable contains one or more non-promise values and/or an already settled promise,\n        // then Promise.race() will settle to the first of these values found in the iterable.\n        const { result, reader } = await Promise.race([\n          lastRead1.then(result => ({ result, reader: reader1 })),\n          lastRead2.then(result => ({ result, reader: reader2 })),\n        ]);\n\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n\n        if (reader === reader1) {\n          lastRead1 = undefined;\n          if (result.done) {\n            // stream 1 is done, we can only read from stream 2:\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = undefined;\n          // stream 2 is done, we can only read from stream 1:\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    },\n  });\n}\n","import { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport { generateId } from '@ai-sdk/ui-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { ToolExecutionError } from '../../errors';\nimport { CoreMessage } from '../prompt/message';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  FinishReason,\n  LanguageModelUsage,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { Source } from '../types/language-model';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { DefaultGeneratedFileWithType, GeneratedFile } from './generated-file';\nimport { parseToolCall } from './parse-tool-call';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultUnion } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nexport type SingleRequestTextStreamPart<TOOLS extends ToolSet> =\n  | {\n      type: 'text-delta';\n      textDelta: string;\n    }\n  | {\n      type: 'reasoning';\n      textDelta: string;\n    }\n  | {\n      type: 'reasoning-signature';\n      signature: string;\n    }\n  | {\n      type: 'redacted-reasoning';\n      data: string;\n    }\n  | ({\n      type: 'file';\n    } & GeneratedFile)\n  | {\n      type: 'source';\n      source: Source;\n    }\n  | ({\n      type: 'tool-call';\n    } & ToolCallUnion<TOOLS>)\n  | {\n      type: 'tool-call-streaming-start';\n      toolCallId: string;\n      toolName: string;\n    }\n  | {\n      type: 'tool-call-delta';\n      toolCallId: string;\n      toolName: string;\n      argsTextDelta: string;\n    }\n  | ({\n      type: 'tool-result';\n    } & ToolResultUnion<TOOLS>)\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      experimental_providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'error';\n      error: unknown;\n    };\n\nexport function runToolsTransformation<TOOLS extends ToolSet>({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n}: {\n  tools: TOOLS | undefined;\n  generatorStream: ReadableStream<LanguageModelV1StreamPart>;\n  toolCallStreaming: boolean;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  system: string | undefined;\n  messages: CoreMessage[];\n  abortSignal: AbortSignal | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n}): ReadableStream<SingleRequestTextStreamPart<TOOLS>> {\n  // tool results stream\n  let toolResultsStreamController: ReadableStreamDefaultController<\n    SingleRequestTextStreamPart<TOOLS>\n  > | null = null;\n  const toolResultsStream = new ReadableStream<\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    start(controller) {\n      toolResultsStreamController = controller;\n    },\n  });\n\n  // keep track of active tool calls for tool call streaming:\n  const activeToolCalls: Record<string, boolean> = {};\n\n  // keep track of outstanding tool results for stream closing:\n  const outstandingToolResults = new Set<string>();\n\n  let canClose = false;\n  let finishChunk:\n    | (SingleRequestTextStreamPart<TOOLS> & { type: 'finish' })\n    | undefined = undefined;\n\n  function attemptClose() {\n    // close the tool results controller if no more outstanding tool calls\n    if (canClose && outstandingToolResults.size === 0) {\n      // we delay sending the finish chunk until all tool results (incl. delayed ones)\n      // are received to ensure that the frontend receives tool results before a message\n      // finish event arrives.\n      if (finishChunk != null) {\n        toolResultsStreamController!.enqueue(finishChunk);\n      }\n\n      toolResultsStreamController!.close();\n    }\n  }\n\n  // forward stream\n  const forwardStream = new TransformStream<\n    LanguageModelV1StreamPart,\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    async transform(\n      chunk: LanguageModelV1StreamPart,\n      controller: TransformStreamDefaultController<\n        SingleRequestTextStreamPart<TOOLS>\n      >,\n    ) {\n      const chunkType = chunk.type;\n\n      switch (chunkType) {\n        // forward:\n        case 'text-delta':\n        case 'reasoning':\n        case 'reasoning-signature':\n        case 'redacted-reasoning':\n        case 'source':\n        case 'response-metadata':\n        case 'error': {\n          controller.enqueue(chunk);\n          break;\n        }\n\n        case 'file': {\n          controller.enqueue(\n            new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mimeType: chunk.mimeType,\n            }),\n          );\n          break;\n        }\n\n        // forward with less information:\n        case 'tool-call-delta': {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: 'tool-call-streaming-start',\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n              });\n\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n\n            controller.enqueue({\n              type: 'tool-call-delta',\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta,\n            });\n          }\n          break;\n        }\n\n        // process tool call:\n        case 'tool-call': {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages,\n            });\n\n            controller.enqueue(toolCall);\n\n            const tool = tools![toolCall.toolName];\n\n            if (tool.execute != null) {\n              const toolExecutionId = generateId(); // use our own id to guarantee uniqueness\n              outstandingToolResults.add(toolExecutionId);\n\n              // Note: we don't await the tool execution here (by leaving out 'await' on recordSpan),\n              // because we want to process the next chunk as soon as possible.\n              // This is important for the case where the tool execution takes a long time.\n              recordSpan({\n                name: 'ai.toolCall',\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: 'ai.toolCall',\n                      telemetry,\n                    }),\n                    'ai.toolCall.name': toolCall.toolName,\n                    'ai.toolCall.id': toolCall.toolCallId,\n                    'ai.toolCall.args': {\n                      output: () => JSON.stringify(toolCall.args),\n                    },\n                  },\n                }),\n                tracer,\n                fn: async span =>\n                  tool.execute!(toolCall.args, {\n                    toolCallId: toolCall.toolCallId,\n                    messages,\n                    abortSignal,\n                  }).then(\n                    (result: any) => {\n                      toolResultsStreamController!.enqueue({\n                        ...toolCall,\n                        type: 'tool-result',\n                        result,\n                      } as any);\n\n                      outstandingToolResults.delete(toolExecutionId);\n\n                      attemptClose();\n\n                      // record telemetry\n                      try {\n                        span.setAttributes(\n                          selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                              'ai.toolCall.result': {\n                                output: () => JSON.stringify(result),\n                              },\n                            },\n                          }),\n                        );\n                      } catch (ignored) {\n                        // JSON stringify might fail if the result is not serializable,\n                        // in which case we just ignore it. In the future we might want to\n                        // add an optional serialize method to the tool interface and warn\n                        // if the result is not serializable.\n                      }\n                    },\n                    (error: any) => {\n                      toolResultsStreamController!.enqueue({\n                        type: 'error',\n                        error: new ToolExecutionError({\n                          toolCallId: toolCall.toolCallId,\n                          toolName: toolCall.toolName,\n                          toolArgs: toolCall.args,\n                          cause: error,\n                        }),\n                      });\n\n                      outstandingToolResults.delete(toolExecutionId);\n                      attemptClose();\n                    },\n                  ),\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController!.enqueue({\n              type: 'error',\n              error,\n            });\n          }\n\n          break;\n        }\n\n        case 'finish': {\n          finishChunk = {\n            type: 'finish',\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateLanguageModelUsage(chunk.usage),\n            experimental_providerMetadata: chunk.providerMetadata,\n          };\n          break;\n        }\n\n        default: {\n          const _exhaustiveCheck: never = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    flush() {\n      canClose = true;\n      attemptClose();\n    },\n  });\n\n  // combine the generator stream and the tool results stream\n  return new ReadableStream<SingleRequestTextStreamPart<TOOLS>>({\n    async start(controller) {\n      // need to wait for both pipes so there are no dangling promises that\n      // can cause uncaught promise rejections when the stream is aborted\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              // the generator stream controller is automatically closed when it's consumed\n            },\n          }),\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            },\n          }),\n        ),\n      ]);\n    },\n  });\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { SpeechModelResponseMetadata } from '../core/types/speech-model-response-metadata';\n\n/**\nError that is thrown when no speech audio was generated.\n */\nexport class NoSpeechGeneratedError extends AISDKError {\n  readonly responses: Array<SpeechModelResponseMetadata>;\n\n  constructor(options: { responses: Array<SpeechModelResponseMetadata> }) {\n    super({\n      name: 'AI_NoSpeechGeneratedError',\n      message: 'No speech audio generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n","import {\n  GeneratedFile,\n  DefaultGeneratedFile,\n} from '../generate-text/generated-file';\n\n/**\n * A generated audio file.\n */\nexport interface GeneratedAudioFile extends GeneratedFile {\n  /**\n   * Audio format of the file (e.g., 'mp3', 'wav', etc.)\n   */\n  readonly format: string;\n}\n\nexport class DefaultGeneratedAudioFile\n  extends DefaultGeneratedFile\n  implements GeneratedAudioFile\n{\n  readonly format: string;\n\n  constructor({\n    data,\n    mimeType,\n  }: {\n    data: string | Uint8Array;\n    mimeType: string;\n  }) {\n    super({ data, mimeType });\n    let format = 'mp3';\n\n    // If format is not provided, try to determine it from the mimeType\n    if (mimeType) {\n      const mimeTypeParts = mimeType.split('/');\n\n      if (mimeTypeParts.length === 2) {\n        // Handle special cases for audio formats\n        if (mimeType !== 'audio/mpeg') {\n          format = mimeTypeParts[1];\n        }\n      }\n    }\n\n    if (!format) {\n      throw new Error(\n        'Audio format must be provided or determinable from mimeType',\n      );\n    }\n\n    this.format = format;\n  }\n}\n\nexport class DefaultGeneratedAudioFileWithType extends DefaultGeneratedAudioFile {\n  readonly type = 'audio';\n\n  constructor(options: {\n    data: string | Uint8Array;\n    mimeType: string;\n    format: string;\n  }) {\n    super(options);\n  }\n}\n","import { JSONValue, SpeechModelV1 } from '@ai-sdk/provider';\nimport { NoSpeechGeneratedError } from '../../errors/no-speech-generated-error';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { SpeechWarning } from '../types/speech-model';\nimport { SpeechModelResponseMetadata } from '../types/speech-model-response-metadata';\nimport { SpeechResult } from './generate-speech-result';\nimport {\n  audioMimeTypeSignatures,\n  detectMimeType,\n} from '../util/detect-mimetype';\nimport {\n  DefaultGeneratedAudioFile,\n  GeneratedAudioFile,\n} from './generated-audio-file';\n\n/**\nGenerates speech audio using a speech model.\n\n@param model - The speech model to use.\n@param text - The text to convert to speech.\n@param voice - The voice to use for speech generation.\n@param outputFormat - The output format to use for speech generation e.g. \"mp3\", \"wav\", etc.\n@param instructions - Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n@param speed - The speed of the speech generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated audio data.\n */\nexport async function generateSpeech({\n  model,\n  text,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe speech model to use.\n     */\n  model: SpeechModelV1;\n\n  /**\nThe text to convert to speech.\n   */\n  text: string;\n\n  /**\nThe voice to use for speech generation.\n   */\n  voice?: string;\n\n  /**\n   * The desired output format for the audio e.g. \"mp3\", \"wav\", etc.\n   */\n  outputFormat?: 'mp3' | 'wav' | (string & {});\n\n  /**\n    Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n  */\n  instructions?: string;\n\n  /**\n  The speed of the speech generation.\n   */\n  speed?: number;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {}\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per speech model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<SpeechResult> {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const result = await retry(() =>\n    model.doGenerate({\n      text,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      abortSignal,\n      headers,\n      providerOptions,\n    }),\n  );\n\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mimeType:\n        detectMimeType({\n          data: result.audio,\n          signatures: audioMimeTypeSignatures,\n        }) ?? 'audio/mp3',\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultSpeechResult implements SpeechResult {\n  readonly audio: GeneratedAudioFile;\n  readonly warnings: Array<SpeechWarning>;\n  readonly responses: Array<SpeechModelResponseMetadata>;\n  readonly providerMetadata: Record<string, Record<string, JSONValue>>;\n\n  constructor(options: {\n    audio: GeneratedAudioFile;\n    warnings: Array<SpeechWarning>;\n    responses: Array<SpeechModelResponseMetadata>;\n    providerMetadata: Record<string, Record<string, JSONValue>> | undefined;\n  }) {\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { TranscriptionModelResponseMetadata } from '../core/types/transcription-model-response-metadata';\n\n/**\nError that is thrown when no transcript was generated.\n */\nexport class NoTranscriptGeneratedError extends AISDKError {\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n\n  constructor(options: {\n    responses: Array<TranscriptionModelResponseMetadata>;\n  }) {\n    super({\n      name: 'AI_NoTranscriptGeneratedError',\n      message: 'No transcript generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n","import { JSONValue, TranscriptionModelV1 } from '@ai-sdk/provider';\nimport { NoTranscriptGeneratedError } from '../../errors/no-transcript-generated-error';\nimport { download } from '../../util/download';\nimport { DataContent } from '../prompt';\nimport { convertDataContentToUint8Array } from '../prompt/data-content';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { TranscriptionWarning } from '../types/transcription-model';\nimport { TranscriptionModelResponseMetadata } from '../types/transcription-model-response-metadata';\nimport {\n  audioMimeTypeSignatures,\n  detectMimeType,\n} from '../util/detect-mimetype';\nimport { TranscriptionResult } from './transcribe-result';\n\n/**\nGenerates transcripts using a transcription model.\n\n@param model - The transcription model to use.\n@param audio - The audio data to transcribe as DataContent (string | Uint8Array | ArrayBuffer | Buffer) or a URL.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated transcript.\n */\nexport async function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe transcription model to use.\n     */\n  model: TranscriptionModelV1;\n\n  /**\nThe audio data to transcribe.\n   */\n  audio: DataContent | URL;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"temperature\": 0\n  }\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per transcript model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<TranscriptionResult> {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const audioData =\n    audio instanceof URL\n      ? (await download({ url: audio })).data\n      : convertDataContentToUint8Array(audio);\n\n  const result = await retry(() =>\n    model.doGenerate({\n      audio: audioData,\n      abortSignal,\n      headers,\n      providerOptions,\n      mediaType:\n        detectMimeType({\n          data: audioData,\n          signatures: audioMimeTypeSignatures,\n        }) ?? 'audio/wav',\n    }),\n  );\n\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultTranscriptionResult implements TranscriptionResult {\n  readonly text: string;\n  readonly segments: Array<{\n    text: string;\n    startSecond: number;\n    endSecond: number;\n  }>;\n  readonly language: string | undefined;\n  readonly durationInSeconds: number | undefined;\n  readonly warnings: Array<TranscriptionWarning>;\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n  readonly providerMetadata: Record<string, Record<string, JSONValue>>;\n\n  constructor(options: {\n    text: string;\n    segments: Array<{\n      text: string;\n      startSecond: number;\n      endSecond: number;\n    }>;\n    language: string | undefined;\n    durationInSeconds: number | undefined;\n    warnings: Array<TranscriptionWarning>;\n    responses: Array<TranscriptionModelResponseMetadata>;\n    providerMetadata: Record<string, Record<string, JSONValue>> | undefined;\n  }) {\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n","/**\n * Deeply merges two objects together.\n * - Properties from the second object override those in the first object with the same key\n * - For nested objects, the merge is performed recursively (deep merge)\n * - Arrays are replaced, not merged\n * - Primitive values are replaced\n * - If both inputs are undefined, returns undefined\n * - If one input is undefined, returns the other\n *\n * @param target The target object to merge into\n * @param source The source object to merge from\n * @returns A new object with the merged properties, or undefined if both inputs are undefined\n */\nexport function mergeObjects<T extends object, U extends object>(\n  target: T | undefined,\n  source: U | undefined,\n): (T & U) | T | U | undefined {\n  // If both inputs are undefined, return undefined\n  if (target === undefined && source === undefined) {\n    return undefined;\n  }\n\n  // If target is undefined, return source\n  if (target === undefined) {\n    return source;\n  }\n\n  // If source is undefined, return target\n  if (source === undefined) {\n    return target;\n  }\n\n  // Create a new object to avoid mutating the inputs\n  const result = { ...target } as T & U;\n\n  // Iterate through all keys in the source object\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      const sourceValue = source[key];\n\n      // Skip if the source value is undefined\n      if (sourceValue === undefined) continue;\n\n      // Get the target value if it exists\n      const targetValue =\n        key in target ? target[key as unknown as keyof T] : undefined;\n\n      // Check if both values are objects that can be deeply merged\n      const isSourceObject =\n        sourceValue !== null &&\n        typeof sourceValue === 'object' &&\n        !Array.isArray(sourceValue) &&\n        !(sourceValue instanceof Date) &&\n        !(sourceValue instanceof RegExp);\n\n      const isTargetObject =\n        targetValue !== null &&\n        targetValue !== undefined &&\n        typeof targetValue === 'object' &&\n        !Array.isArray(targetValue) &&\n        !(targetValue instanceof Date) &&\n        !(targetValue instanceof RegExp);\n\n      // If both values are mergeable objects, merge them recursively\n      if (isSourceObject && isTargetObject) {\n        result[key as keyof (T & U)] = mergeObjects(\n          targetValue as object,\n          sourceValue as object,\n        ) as any;\n      } else {\n        // For primitives, arrays, or when one value is not a mergeable object,\n        // simply override with the source value\n        result[key as keyof (T & U)] = sourceValue as any;\n      }\n    }\n  }\n\n  return result;\n}\n","import {\n  LanguageModelV1CallOptions,\n  LanguageModelV1ProviderMetadata,\n} from '@ai-sdk/provider';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\nimport { mergeObjects } from '../util/merge-objects';\n\n/**\n * Applies default settings for a language model.\n */\nexport function defaultSettingsMiddleware({\n  settings,\n}: {\n  settings: Partial<\n    LanguageModelV1CallOptions & {\n      providerMetadata?: LanguageModelV1ProviderMetadata;\n    }\n  >;\n}): LanguageModelV1Middleware {\n  return {\n    middlewareVersion: 'v1',\n    transformParams: async ({ params }) => {\n      return {\n        ...settings,\n        ...params,\n        providerMetadata: mergeObjects(\n          settings.providerMetadata,\n          params.providerMetadata,\n        ),\n\n        // special case for temperature 0\n        // TODO remove when temperature defaults to undefined\n        temperature:\n          params.temperature === 0 || params.temperature == null\n            ? (settings.temperature ?? 0)\n            : params.temperature,\n      };\n    },\n  };\n}\n","/**\n * Returns the index of the start of the searchedText in the text, or null if it\n * is not found.\n */\nexport function getPotentialStartIndex(\n  text: string,\n  searchedText: string,\n): number | null {\n  // Return null immediately if searchedText is empty.\n  if (searchedText.length === 0) {\n    return null;\n  }\n\n  // Check if the searchedText exists as a direct substring of text.\n  const directIndex = text.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n\n  // Otherwise, look for the largest suffix of \"text\" that matches\n  // a prefix of \"searchedText\". We go from the end of text inward.\n  for (let i = text.length - 1; i >= 0; i--) {\n    const suffix = text.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n\n  return null;\n}\n","import type { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport { getPotentialStartIndex } from '../util/get-potential-start-index';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\n\n/**\n * Extract an XML-tagged reasoning section from the generated text and exposes it\n * as a `reasoning` property on the result.\n *\n * @param tagName - The name of the XML tag to extract reasoning from.\n * @param separator - The separator to use between reasoning and text sections.\n * @param startWithReasoning - Whether to start with reasoning tokens.\n */\nexport function extractReasoningMiddleware({\n  tagName,\n  separator = '\\n',\n  startWithReasoning = false,\n}: {\n  tagName: string;\n  separator?: string;\n  startWithReasoning?: boolean;\n}): LanguageModelV1Middleware {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `<\\/${tagName}>`;\n\n  return {\n    middlewareVersion: 'v1',\n    wrapGenerate: async ({ doGenerate }) => {\n      const { text: rawText, ...rest } = await doGenerate();\n\n      if (rawText == null) {\n        return { text: rawText, ...rest };\n      }\n\n      const text = startWithReasoning ? openingTag + rawText : rawText;\n\n      const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, 'gs');\n      const matches = Array.from(text.matchAll(regexp));\n\n      if (!matches.length) {\n        return { text, ...rest };\n      }\n\n      const reasoning = matches.map(match => match[1]).join(separator);\n\n      let textWithoutReasoning = text;\n      for (let i = matches.length - 1; i >= 0; i--) {\n        const match = matches[i];\n\n        const beforeMatch = textWithoutReasoning.slice(0, match.index);\n        const afterMatch = textWithoutReasoning.slice(\n          match.index! + match[0].length,\n        );\n\n        textWithoutReasoning =\n          beforeMatch +\n          (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : '') +\n          afterMatch;\n      }\n\n      return { ...rest, text: textWithoutReasoning, reasoning };\n    },\n\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n\n      let isFirstReasoning = true;\n      let isFirstText = true;\n      let afterSwitch = false;\n      let isReasoning = startWithReasoning;\n      let buffer = '';\n\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream<\n            LanguageModelV1StreamPart,\n            LanguageModelV1StreamPart\n          >({\n            transform: (chunk, controller) => {\n              if (chunk.type !== 'text-delta') {\n                controller.enqueue(chunk);\n                return;\n              }\n\n              buffer += chunk.textDelta;\n\n              function publish(text: string) {\n                if (text.length > 0) {\n                  const prefix =\n                    afterSwitch &&\n                    (isReasoning ? !isFirstReasoning : !isFirstText)\n                      ? separator\n                      : '';\n\n                  controller.enqueue({\n                    type: isReasoning ? 'reasoning' : 'text-delta',\n                    textDelta: prefix + text,\n                  });\n                  afterSwitch = false;\n\n                  if (isReasoning) {\n                    isFirstReasoning = false;\n                  } else {\n                    isFirstText = false;\n                  }\n                }\n              }\n\n              do {\n                const nextTag = isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(buffer, nextTag);\n\n                // no opening or closing tag found, publish the buffer\n                if (startIndex == null) {\n                  publish(buffer);\n                  buffer = '';\n                  break;\n                }\n\n                // publish text before the tag\n                publish(buffer.slice(0, startIndex));\n\n                const foundFullMatch =\n                  startIndex + nextTag.length <= buffer.length;\n\n                if (foundFullMatch) {\n                  buffer = buffer.slice(startIndex + nextTag.length);\n                  isReasoning = !isReasoning;\n                  afterSwitch = true;\n                } else {\n                  buffer = buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            },\n          }),\n        ),\n        ...rest,\n      };\n    },\n  };\n}\n","import type { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\n\n/**\n * Simulates streaming chunks with the response from a generate call.\n */\nexport function simulateStreamingMiddleware(): LanguageModelV1Middleware {\n  return {\n    middlewareVersion: 'v1',\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n\n      const simulatedStream = new ReadableStream<LanguageModelV1StreamPart>({\n        start(controller) {\n          controller.enqueue({ type: 'response-metadata', ...result.response });\n\n          if (result.reasoning) {\n            if (typeof result.reasoning === 'string') {\n              controller.enqueue({\n                type: 'reasoning',\n                textDelta: result.reasoning,\n              });\n            } else {\n              for (const reasoning of result.reasoning) {\n                switch (reasoning.type) {\n                  case 'text': {\n                    controller.enqueue({\n                      type: 'reasoning',\n                      textDelta: reasoning.text,\n                    });\n                    if (reasoning.signature != null) {\n                      controller.enqueue({\n                        type: 'reasoning-signature',\n                        signature: reasoning.signature,\n                      });\n                    }\n                    break;\n                  }\n                  case 'redacted': {\n                    controller.enqueue({\n                      type: 'redacted-reasoning',\n                      data: reasoning.data,\n                    });\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          if (result.text) {\n            controller.enqueue({\n              type: 'text-delta',\n              textDelta: result.text,\n            });\n          }\n\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: 'tool-call-delta',\n                toolCallType: 'function',\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args,\n              });\n\n              controller.enqueue({\n                type: 'tool-call',\n                ...toolCall,\n              });\n            }\n          }\n\n          controller.enqueue({\n            type: 'finish',\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata,\n          });\n\n          controller.close();\n        },\n      });\n\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings,\n      };\n    },\n  };\n}\n","import { LanguageModelV1, LanguageModelV1CallOptions } from '@ai-sdk/provider';\nimport { LanguageModelV1Middleware } from './language-model-v1-middleware';\nimport { asArray } from '../../util/as-array';\n\n/**\n * Wraps a LanguageModelV1 instance with middleware functionality.\n * This function allows you to apply middleware to transform parameters,\n * wrap generate operations, and wrap stream operations of a language model.\n *\n * @param options - Configuration options for wrapping the language model.\n * @param options.model - The original LanguageModelV1 instance to be wrapped.\n * @param options.middleware - The middleware to be applied to the language model. When multiple middlewares are provided, the first middleware will transform the input first, and the last middleware will be wrapped directly around the model.\n * @param options.modelId - Optional custom model ID to override the original model's ID.\n * @param options.providerId - Optional custom provider ID to override the original model's provider.\n * @returns A new LanguageModelV1 instance with middleware applied.\n */\nexport const wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV1;\n  middleware: LanguageModelV1Middleware | LanguageModelV1Middleware[];\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV1 => {\n  return asArray(middlewareArg)\n    .reverse()\n    .reduce((wrappedModel, middleware) => {\n      return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n    }, model);\n};\n\nconst doWrap = ({\n  model,\n  middleware: { transformParams, wrapGenerate, wrapStream },\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV1;\n  middleware: LanguageModelV1Middleware;\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV1 => {\n  async function doTransform({\n    params,\n    type,\n  }: {\n    params: LanguageModelV1CallOptions;\n    type: 'generate' | 'stream';\n  }) {\n    return transformParams ? await transformParams({ params, type }) : params;\n  }\n\n  return {\n    specificationVersion: 'v1',\n\n    provider: providerId ?? model.provider,\n    modelId: modelId ?? model.modelId,\n\n    defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n    supportsImageUrls: model.supportsImageUrls,\n    supportsUrl: model.supportsUrl?.bind(model),\n    supportsStructuredOutputs: model.supportsStructuredOutputs,\n\n    async doGenerate(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n      const transformedParams = await doTransform({ params, type: 'generate' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate\n        ? wrapGenerate({\n            doGenerate,\n            doStream,\n            params: transformedParams,\n            model,\n          })\n        : doGenerate();\n    },\n\n    async doStream(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n      const transformedParams = await doTransform({ params, type: 'stream' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream\n        ? wrapStream({ doGenerate, doStream, params: transformedParams, model })\n        : doStream();\n    },\n  };\n};\n\n/**\n * @deprecated Use `wrapLanguageModel` instead.\n */\n// TODO remove in v5\nexport const experimental_wrapLanguageModel = wrapLanguageModel;\n","import { Message } from '@ai-sdk/ui-utils';\n\n/**\n * Appends a client message to the messages array.\n * If the last message in the array has the same id as the new message, it will be replaced.\n * Otherwise, the new message will be appended.\n */\nexport function appendClientMessage({\n  messages,\n  message,\n}: {\n  messages: Message[];\n  message: Message;\n}) {\n  return [\n    ...(messages.length > 0 && messages[messages.length - 1].id === message.id\n      ? messages.slice(0, -1)\n      : messages),\n    message,\n  ];\n}\n","import {\n  extractMaxToolInvocationStep,\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  StepStartUIPart,\n  TextUIPart,\n  ToolInvocation,\n  ToolInvocationUIPart,\n} from '@ai-sdk/ui-utils';\nimport { ResponseMessage } from '../generate-text/step-result';\nimport { convertDataContentToBase64String } from './data-content';\nimport { AISDKError } from '@ai-sdk/provider';\n\n/**\n * Appends the ResponseMessage[] from the response to a Message[] (for useChat).\n * The messages are converted to Messages before being appended.\n * Timestamps are generated for the new messages.\n *\n * @returns A new Message[] with the response messages appended.\n */\nexport function appendResponseMessages({\n  messages,\n  responseMessages,\n  _internal: { currentDate = () => new Date() } = {},\n}: {\n  messages: Message[];\n  responseMessages: ResponseMessage[];\n\n  /**\nInternal. For test use only. May change without notice.\n     */\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}): Message[] {\n  const clonedMessages = structuredClone(messages);\n\n  for (const message of responseMessages) {\n    const role = message.role;\n\n    // check if the last message is an assistant message:\n    const lastMessage = clonedMessages[clonedMessages.length - 1];\n    const isLastMessageAssistant = lastMessage.role === 'assistant';\n\n    switch (role) {\n      case 'assistant': {\n        function getToolInvocations(step: number) {\n          return (\n            typeof message.content === 'string'\n              ? []\n              : message.content.filter(part => part.type === 'tool-call')\n          ).map(call => ({\n            state: 'call' as const,\n            step,\n            args: call.args,\n            toolCallId: call.toolCallId,\n            toolName: call.toolName,\n          }));\n        }\n\n        const parts: Array<\n          | TextUIPart\n          | ReasoningUIPart\n          | ToolInvocationUIPart\n          | FileUIPart\n          | StepStartUIPart\n        > = [{ type: 'step-start' as const }]; // always start with a step-start part\n        let textContent = '';\n        let reasoningTextContent = undefined;\n\n        if (typeof message.content === 'string') {\n          textContent = message.content;\n          parts.push({\n            type: 'text' as const,\n            text: message.content,\n          });\n        } else {\n          let reasoningPart: ReasoningUIPart | undefined = undefined;\n          for (const part of message.content) {\n            switch (part.type) {\n              case 'text': {\n                reasoningPart = undefined; // reset the reasoning part\n\n                textContent += part.text;\n                parts.push({\n                  type: 'text' as const,\n                  text: part.text,\n                });\n                break;\n              }\n              case 'reasoning': {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: 'reasoning' as const,\n                    reasoning: '',\n                    details: [],\n                  };\n                  parts.push(reasoningPart);\n                }\n\n                reasoningTextContent = (reasoningTextContent ?? '') + part.text;\n                reasoningPart.reasoning += part.text;\n                reasoningPart.details.push({\n                  type: 'text' as const,\n                  text: part.text,\n                  signature: part.signature,\n                });\n                break;\n              }\n              case 'redacted-reasoning': {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: 'reasoning' as const,\n                    reasoning: '',\n                    details: [],\n                  };\n                  parts.push(reasoningPart);\n                }\n\n                reasoningPart.details.push({\n                  type: 'redacted' as const,\n                  data: part.data,\n                });\n                break;\n              }\n              case 'tool-call':\n                break;\n              case 'file':\n                if (part.data instanceof URL) {\n                  throw new AISDKError({\n                    name: 'InvalidAssistantFileData',\n                    message: 'File data cannot be a URL',\n                  });\n                }\n                parts.push({\n                  type: 'file' as const,\n                  mimeType: part.mimeType,\n                  data: convertDataContentToBase64String(part.data),\n                });\n                break;\n            }\n          }\n        }\n\n        if (isLastMessageAssistant) {\n          const maxStep = extractMaxToolInvocationStep(\n            lastMessage.toolInvocations,\n          );\n\n          lastMessage.parts ??= [];\n\n          lastMessage.content = textContent;\n          lastMessage.reasoning = reasoningTextContent;\n          lastMessage.parts.push(...parts);\n\n          lastMessage.toolInvocations = [\n            ...(lastMessage.toolInvocations ?? []),\n            ...getToolInvocations(maxStep === undefined ? 0 : maxStep + 1),\n          ];\n\n          getToolInvocations(maxStep === undefined ? 0 : maxStep + 1)\n            .map(call => ({\n              type: 'tool-invocation' as const,\n              toolInvocation: call,\n            }))\n            .forEach(part => {\n              lastMessage.parts!.push(part);\n            });\n        } else {\n          // last message was a user message, add the assistant message:\n          clonedMessages.push({\n            role: 'assistant',\n            id: message.id,\n            createdAt: currentDate(), // generate a createdAt date for the message, will be overridden by the client\n            content: textContent,\n            reasoning: reasoningTextContent,\n            toolInvocations: getToolInvocations(0),\n            parts: [\n              ...parts,\n              ...getToolInvocations(0).map(call => ({\n                type: 'tool-invocation' as const,\n                toolInvocation: call,\n              })),\n            ],\n          });\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        // for tool call results, add the result to previous message:\n        lastMessage.toolInvocations ??= []; // ensure the toolInvocations array exists\n\n        if (lastMessage.role !== 'assistant') {\n          throw new Error(\n            `Tool result must follow an assistant message: ${lastMessage.role}`,\n          );\n        }\n\n        lastMessage.parts ??= [];\n\n        for (const contentPart of message.content) {\n          // find the tool call in the previous message:\n          const toolCall = lastMessage.toolInvocations.find(\n            call => call.toolCallId === contentPart.toolCallId,\n          );\n          const toolCallPart: ToolInvocationUIPart | undefined =\n            lastMessage.parts.find(\n              (part): part is ToolInvocationUIPart =>\n                part.type === 'tool-invocation' &&\n                part.toolInvocation.toolCallId === contentPart.toolCallId,\n            );\n\n          if (!toolCall) {\n            throw new Error('Tool call not found in previous message');\n          }\n\n          // add the result to the tool call:\n          toolCall.state = 'result';\n          const toolResult = toolCall as ToolInvocation & { state: 'result' };\n          toolResult.result = contentPart.result;\n\n          if (toolCallPart) {\n            toolCallPart.toolInvocation = toolResult;\n          } else {\n            lastMessage.parts.push({\n              type: 'tool-invocation' as const,\n              toolInvocation: toolResult,\n            });\n          }\n        }\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported message role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return clonedMessages;\n}\n","import { NoSuchModelError, ProviderV1 } from '@ai-sdk/provider';\nimport { EmbeddingModel, ImageModel, LanguageModel, Provider } from '../types';\n\n/**\n * Creates a custom provider with specified language models, text embedding models, and an optional fallback provider.\n *\n * @param {Object} options - The options for creating the custom provider.\n * @param {Record<string, LanguageModel>} [options.languageModels] - A record of language models, where keys are model IDs and values are LanguageModel instances.\n * @param {Record<string, EmbeddingModel<string>>} [options.textEmbeddingModels] - A record of text embedding models, where keys are model IDs and values are EmbeddingModel<string> instances.\n * @param {Record<string, ImageModel>} [options.imageModels] - A record of image models, where keys are model IDs and values are ImageModel instances.\n * @param {Provider} [options.fallbackProvider] - An optional fallback provider to use when a requested model is not found in the custom provider.\n * @returns {Provider} A Provider object with languageModel, textEmbeddingModel, and imageModel methods.\n *\n * @throws {NoSuchModelError} Throws when a requested model is not found and no fallback provider is available.\n */\nexport function customProvider<\n  LANGUAGE_MODELS extends Record<string, LanguageModel>,\n  EMBEDDING_MODELS extends Record<string, EmbeddingModel<string>>,\n  IMAGE_MODELS extends Record<string, ImageModel>,\n>({\n  languageModels,\n  textEmbeddingModels,\n  imageModels,\n  fallbackProvider,\n}: {\n  languageModels?: LANGUAGE_MODELS;\n  textEmbeddingModels?: EMBEDDING_MODELS;\n  imageModels?: IMAGE_MODELS;\n  fallbackProvider?: ProviderV1;\n}): Provider & {\n  languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModel;\n  textEmbeddingModel(\n    modelId: ExtractModelId<EMBEDDING_MODELS>,\n  ): EmbeddingModel<string>;\n  imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModel;\n} {\n  return {\n    languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModel {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'languageModel' });\n    },\n\n    textEmbeddingModel(\n      modelId: ExtractModelId<EMBEDDING_MODELS>,\n    ): EmbeddingModel<string> {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'textEmbeddingModel' });\n    },\n\n    imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModel {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n\n      if (fallbackProvider?.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'imageModel' });\n    },\n  };\n}\n\n/**\n * @deprecated Use `customProvider` instead.\n */\nexport const experimental_customProvider = customProvider;\n\ntype ExtractModelId<MODELS extends Record<string, unknown>> = Extract<\n  keyof MODELS,\n  string\n>;\n","import { AISDKError, NoSuchModelError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchProviderError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchProviderError extends NoSuchModelError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly providerId: string;\n  readonly availableProviders: string[];\n\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`,\n  }: {\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel';\n    providerId: string;\n    availableProviders: string[];\n    message?: string;\n  }) {\n    super({ errorName: name, modelId, modelType, message });\n\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n\n  static isInstance(error: unknown): error is NoSuchProviderError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { NoSuchModelError, ProviderV1 } from '@ai-sdk/provider';\nimport { EmbeddingModel, ImageModel, LanguageModel } from '../types';\nimport { NoSuchProviderError } from './no-such-provider-error';\n\ntype ExtractLiteralUnion<T> = T extends string\n  ? string extends T\n    ? never\n    : T\n  : never;\n\nexport interface ProviderRegistryProvider<\n  PROVIDERS extends Record<string, ProviderV1> = Record<string, ProviderV1>,\n  SEPARATOR extends string = ':',\n> {\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['languageModel']>>[0]>}`\n      : never,\n  ): LanguageModel;\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): LanguageModel;\n\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['textEmbeddingModel']>>[0]>}`\n      : never,\n  ): EmbeddingModel<string>;\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): EmbeddingModel<string>;\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['imageModel']>>[0]>}`\n      : never,\n  ): ImageModel;\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): ImageModel;\n}\n\n/**\n * Creates a registry for the given providers.\n */\nexport function createProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV1>,\n  SEPARATOR extends string = ':',\n>(\n  providers: PROVIDERS,\n  {\n    separator = ':' as SEPARATOR,\n  }: {\n    separator?: SEPARATOR;\n  } = {},\n): ProviderRegistryProvider<PROVIDERS, SEPARATOR> {\n  const registry = new DefaultProviderRegistry<PROVIDERS, SEPARATOR>({\n    separator,\n  });\n\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider } as {\n      id: keyof PROVIDERS;\n      provider: PROVIDERS[keyof PROVIDERS];\n    });\n  }\n\n  return registry;\n}\n\n/**\n * @deprecated Use `createProviderRegistry` instead.\n */\nexport const experimental_createProviderRegistry = createProviderRegistry;\n\nclass DefaultProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV1>,\n  SEPARATOR extends string,\n> implements ProviderRegistryProvider<PROVIDERS, SEPARATOR>\n{\n  private providers: PROVIDERS = {} as PROVIDERS;\n  private separator: SEPARATOR;\n\n  constructor({ separator }: { separator: SEPARATOR }) {\n    this.separator = separator;\n  }\n\n  registerProvider<K extends keyof PROVIDERS>({\n    id,\n    provider,\n  }: {\n    id: K;\n    provider: PROVIDERS[K];\n  }): void {\n    this.providers[id] = provider;\n  }\n\n  private getProvider(id: string): ProviderV1 {\n    const provider = this.providers[id as keyof PROVIDERS];\n\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType: 'languageModel',\n        providerId: id,\n        availableProviders: Object.keys(this.providers),\n      });\n    }\n\n    return provider;\n  }\n\n  private splitId(\n    id: string,\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel',\n  ): [string, string] {\n    const index = id.indexOf(this.separator);\n\n    if (index === -1) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType,\n        message:\n          `Invalid ${modelType} id for registry: ${id} ` +\n          `(must be in the format \"providerId${this.separator}modelId\")`,\n      });\n    }\n\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): LanguageModel {\n    const [providerId, modelId] = this.splitId(id, 'languageModel');\n    const model = this.getProvider(providerId).languageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'languageModel' });\n    }\n\n    return model;\n  }\n\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): EmbeddingModel<string> {\n    const [providerId, modelId] = this.splitId(id, 'textEmbeddingModel');\n    const provider = this.getProvider(providerId);\n\n    const model = provider.textEmbeddingModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: 'textEmbeddingModel',\n      });\n    }\n\n    return model;\n  }\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): ImageModel {\n    const [providerId, modelId] = this.splitId(id, 'imageModel');\n    const provider = this.getProvider(providerId);\n\n    const model = provider.imageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'imageModel' });\n    }\n\n    return model;\n  }\n}\n","import { JSONSchema7 } from '@ai-sdk/provider';\nimport { jsonSchema } from '@ai-sdk/ui-utils';\nimport { z, ZodType } from 'zod';\nimport { MCPClientError } from '../../../errors';\nimport { inferParameters, tool, Tool, ToolExecutionOptions } from '../tool';\nimport {\n  JSONRPCError,\n  JSONRPCNotification,\n  JSONRPCRequest,\n  JSONRPCResponse,\n} from './json-rpc-message';\nimport {\n  createMcpTransport,\n  isCustomMcpTransport,\n  MCPTransport,\n  MCPTransportConfig,\n} from './mcp-transport';\nimport {\n  CallToolResult,\n  CallToolResultSchema,\n  Configuration as ClientConfiguration,\n  InitializeResultSchema,\n  LATEST_PROTOCOL_VERSION,\n  ListToolsResult,\n  ListToolsResultSchema,\n  McpToolSet,\n  Notification,\n  PaginatedRequest,\n  Request,\n  RequestOptions,\n  ServerCapabilities,\n  SUPPORTED_PROTOCOL_VERSIONS,\n  ToolSchemas,\n} from './types';\n\nconst CLIENT_VERSION = '1.0.0';\n\ninterface MCPClientConfig {\n  /** Transport configuration for connecting to the MCP server */\n  transport: MCPTransportConfig | MCPTransport;\n  /** Optional callback for uncaught errors */\n  onUncaughtError?: (error: unknown) => void;\n  /** Optional client name, defaults to 'ai-sdk-mcp-client' */\n  name?: string;\n}\n\nexport async function createMCPClient(\n  config: MCPClientConfig,\n): Promise<MCPClient> {\n  const client = new MCPClient(config);\n  await client.init();\n  return client;\n}\n\n/**\n * A lightweight MCP Client implementation\n *\n * The primary purpose of this client is tool conversion between MCP<>AI SDK\n * but can later be extended to support other MCP features\n *\n * Tool parameters are automatically inferred from the server's JSON schema\n * if not explicitly provided in the tools configuration\n *\n * This client is meant to be used to communicate with a single server. To communicate and fetch tools across multiple servers, it's recommended to create a new client instance per server.\n *\n * Not supported:\n * - Client options (e.g. sampling, roots) as they are not needed for tool conversion\n * - Accepting notifications\n * - Session management (when passing a sessionId to an instance of the Streamable HTTP transport)\n * - Resumable SSE streams\n */\nclass MCPClient {\n  private transport: MCPTransport;\n  private onUncaughtError?: (error: unknown) => void;\n  private clientInfo: ClientConfiguration;\n  private requestMessageId = 0;\n  private responseHandlers: Map<\n    number,\n    (response: JSONRPCResponse | Error) => void\n  > = new Map();\n  private serverCapabilities: ServerCapabilities = {};\n  private isClosed = true;\n\n  constructor({\n    transport: transportConfig,\n    name = 'ai-sdk-mcp-client',\n    onUncaughtError,\n  }: MCPClientConfig) {\n    this.onUncaughtError = onUncaughtError;\n\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error: Error) => this.onError(error);\n    this.transport.onmessage = message => {\n      if ('method' in message) {\n        // This lightweight client implementation does not support\n        // receiving notifications or requests from server.\n        // If we get an unsupported message, we can safely ignore it and pass to the onError handler:\n        this.onError(\n          new MCPClientError({\n            message: 'Unsupported message type',\n          }),\n        );\n        return;\n      }\n\n      this.onResponse(message);\n    };\n\n    this.clientInfo = {\n      name,\n      version: CLIENT_VERSION,\n    };\n  }\n\n  async init(): Promise<this> {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n\n      const result = await this.request({\n        request: {\n          method: 'initialize',\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            clientInfo: this.clientInfo,\n          },\n        },\n        resultSchema: InitializeResultSchema,\n      });\n\n      if (result === undefined) {\n        throw new MCPClientError({\n          message: 'Server sent invalid initialize result',\n        });\n      }\n\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`,\n        });\n      }\n\n      this.serverCapabilities = result.capabilities;\n\n      // Complete initialization handshake:\n      await this.notification({\n        method: 'notifications/initialized',\n      });\n\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) return;\n    await this.transport?.close();\n    this.onClose();\n  }\n\n  private assertCapability(method: string): void {\n    switch (method) {\n      case 'initialize':\n        break;\n      case 'tools/list':\n      case 'tools/call':\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`,\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`,\n        });\n    }\n  }\n\n  private async request<T extends ZodType<object>>({\n    request,\n    resultSchema,\n    options,\n  }: {\n    request: Request;\n    resultSchema: T;\n    options?: RequestOptions;\n  }): Promise<z.infer<T>> {\n    return new Promise((resolve, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: 'Attempted to send a request from a closed client',\n          }),\n        );\n      }\n\n      this.assertCapability(request.method);\n\n      const signal = options?.signal;\n      signal?.throwIfAborted();\n\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest: JSONRPCRequest = {\n        ...request,\n        jsonrpc: '2.0',\n        id: messageId,\n      };\n\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n\n      this.responseHandlers.set(messageId, response => {\n        if (signal?.aborted) {\n          return reject(\n            new MCPClientError({\n              message: 'Request was aborted',\n              cause: signal.reason,\n            }),\n          );\n        }\n\n        if (response instanceof Error) {\n          return reject(response);\n        }\n\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: 'Failed to parse server response',\n            cause: error,\n          });\n          reject(parseError);\n        }\n      });\n\n      this.transport.send(jsonrpcRequest).catch(error => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n\n  private async listTools({\n    params,\n    options,\n  }: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  } = {}): Promise<ListToolsResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/list', params },\n        resultSchema: ListToolsResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async callTool({\n    name,\n    args,\n    options,\n  }: {\n    name: string;\n    args: Record<string, unknown>;\n    options?: ToolExecutionOptions;\n  }): Promise<CallToolResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/call', params: { name, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options?.abortSignal,\n        },\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async notification(notification: Notification): Promise<void> {\n    const jsonrpcNotification: JSONRPCNotification = {\n      ...notification,\n      jsonrpc: '2.0',\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools<TOOL_SCHEMAS extends ToolSchemas = 'automatic'>({\n    schemas = 'automatic',\n  }: {\n    schemas?: TOOL_SCHEMAS;\n  } = {}): Promise<McpToolSet<TOOL_SCHEMAS>> {\n    const tools: Record<string, Tool> = {};\n\n    try {\n      const listToolsResult = await this.listTools();\n\n      for (const { name, description, inputSchema } of listToolsResult.tools) {\n        if (schemas !== 'automatic' && !(name in schemas)) {\n          continue;\n        }\n\n        const parameters =\n          schemas === 'automatic'\n            ? jsonSchema({\n                ...inputSchema,\n                properties: inputSchema.properties ?? {},\n                additionalProperties: false,\n              } as JSONSchema7)\n            : schemas[name].parameters;\n\n        const self = this;\n        const toolWithExecute = tool({\n          description,\n          parameters,\n          execute: async (\n            args: inferParameters<typeof parameters>,\n            options: ToolExecutionOptions,\n          ): Promise<CallToolResult> => {\n            options?.abortSignal?.throwIfAborted();\n\n            return self.callTool({\n              name,\n              args,\n              options,\n            });\n          },\n        });\n\n        tools[name] = toolWithExecute;\n      }\n\n      return tools as McpToolSet<TOOL_SCHEMAS>;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private onClose(): void {\n    if (this.isClosed) return;\n\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: 'Connection closed',\n    });\n\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n\n    this.responseHandlers.clear();\n  }\n\n  private onError(error: unknown): void {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n\n  private onResponse(response: JSONRPCResponse | JSONRPCError): void {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n\n    if (handler === undefined) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response,\n        )}`,\n      });\n    }\n\n    this.responseHandlers.delete(messageId);\n\n    handler(\n      'result' in response\n        ? response\n        : new MCPClientError({\n            message: response.error.message,\n            cause: response.error,\n          }),\n    );\n  }\n}\n","import { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { ToolResultContent } from '../prompt/tool-result-content';\nimport { CoreMessage } from '../prompt/message';\n\nexport type ToolParameters = z.ZodTypeAny | Schema<any>;\n\nexport type inferParameters<PARAMETERS extends ToolParameters> =\n  PARAMETERS extends Schema<any>\n    ? PARAMETERS['_type']\n    : PARAMETERS extends z.ZodTypeAny\n      ? z.infer<PARAMETERS>\n      : never;\n\nexport interface ToolExecutionOptions {\n  /**\n   * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.\n   */\n  toolCallId: string;\n\n  /**\n   * Messages that were sent to the language model to initiate the response that contained the tool call.\n   * The messages **do not** include the system prompt nor the assistant response that contained the tool call.\n   */\n  messages: CoreMessage[];\n\n  /**\n   * An optional abort signal that indicates that the overall operation should be aborted.\n   */\n  abortSignal?: AbortSignal;\n}\n\n/**\nA tool contains the description and the schema of the input that the tool expects.\nThis enables the language model to generate the input.\n\nThe tool can also contain an optional execute function for the actual execution function of the tool.\n */\nexport type Tool<PARAMETERS extends ToolParameters = any, RESULT = any> = {\n  /**\nThe schema of the input that the tool expects. The language model will use this to generate the input.\nIt is also used to validate the output of the language model.\nUse descriptions to make the input understandable for the language model.\n   */\n  parameters: PARAMETERS;\n\n  /**\nAn optional description of what the tool does.\nWill be used by the language model to decide whether to use the tool.\nNot used for provider-defined tools.\n   */\n  description?: string;\n\n  /**\nOptional conversion function that maps the tool result to multi-part tool content for LLMs.\n   */\n  experimental_toToolResultContent?: (result: RESULT) => ToolResultContent;\n\n  /**\nAn async function that is called with the arguments from the tool call and produces a result.\nIf not provided, the tool will not be executed automatically.\n\n@args is the input of the tool call.\n@options.abortSignal is a signal that can be used to abort the tool call.\n   */\n  execute?: (\n    args: inferParameters<PARAMETERS>,\n    options: ToolExecutionOptions,\n  ) => PromiseLike<RESULT>;\n} & (\n  | {\n      /**\nFunction tool.\n       */\n      type?: undefined | 'function';\n    }\n  | {\n      /**\nProvider-defined tool.\n       */\n      type: 'provider-defined';\n\n      /**\nThe ID of the tool. Should follow the format `<provider-name>.<tool-name>`.\n       */\n      id: `${string}.${string}`;\n\n      /**\nThe arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.\n       */\n      args: Record<string, unknown>;\n    }\n);\n\n/**\n * @deprecated Use `Tool` instead.\n */\n// TODO remove in v5\nexport type CoreTool<\n  PARAMETERS extends ToolParameters = any,\n  RESULT = any,\n> = Tool<PARAMETERS, RESULT>;\n\n/**\nHelper function for inferring the execute args of a tool.\n */\n// Note: special type inference is needed for the execute function args to make sure they are inferred correctly.\nexport function tool<PARAMETERS extends ToolParameters, RESULT>(\n  tool: Tool<PARAMETERS, RESULT> & {\n    execute: (\n      args: inferParameters<PARAMETERS>,\n      options: ToolExecutionOptions,\n    ) => PromiseLike<RESULT>;\n  },\n): Tool<PARAMETERS, RESULT> & {\n  execute: (\n    args: inferParameters<PARAMETERS>,\n    options: ToolExecutionOptions,\n  ) => PromiseLike<RESULT>;\n};\nexport function tool<PARAMETERS extends ToolParameters, RESULT>(\n  tool: Tool<PARAMETERS, RESULT> & {\n    execute?: undefined;\n  },\n): Tool<PARAMETERS, RESULT> & {\n  execute: undefined;\n};\nexport function tool<PARAMETERS extends ToolParameters, RESULT = any>(\n  tool: Tool<PARAMETERS, RESULT>,\n): Tool<PARAMETERS, RESULT> {\n  return tool;\n}\n","import { createEventSourceParserStream } from '@ai-sdk/provider-utils';\nimport { MCPClientError } from '../../../errors';\nimport { JSONRPCMessage, JSONRPCMessageSchema } from './json-rpc-message';\nimport { MCPTransport } from './mcp-transport';\n\nexport class SseMCPTransport implements MCPTransport {\n  private endpoint?: URL;\n  private abortController?: AbortController;\n  private url: URL;\n  private connected = false;\n  private sseConnection?: {\n    close: () => void;\n  };\n  private headers?: Record<string, string>;\n\n  onclose?: () => void;\n  onerror?: (error: unknown) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor({\n    url,\n    headers,\n  }: {\n    url: string;\n    headers?: Record<string, string>;\n  }) {\n    this.url = new URL(url);\n    this.headers = headers;\n  }\n\n  async start(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (this.connected) {\n        return resolve();\n      }\n\n      this.abortController = new AbortController();\n\n      const establishConnection = async () => {\n        try {\n          const headers = new Headers(this.headers);\n          headers.set('Accept', 'text/event-stream');\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: this.abortController?.signal,\n          });\n\n          if (!response.ok || !response.body) {\n            const error = new MCPClientError({\n              message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`,\n            });\n            this.onerror?.(error);\n            return reject(error);\n          }\n\n          const stream = response.body\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(createEventSourceParserStream());\n\n          const reader = stream.getReader();\n\n          const processEvents = async () => {\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Connection closed unexpectedly',\n                    });\n                  }\n                  return;\n                }\n\n                const { event, data } = value;\n\n                if (event === 'endpoint') {\n                  this.endpoint = new URL(data, this.url);\n\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`,\n                    });\n                  }\n\n                  this.connected = true;\n                  resolve();\n                } else if (event === 'message') {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data),\n                    );\n                    this.onmessage?.(message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Failed to parse message',\n                      cause: error,\n                    });\n                    this.onerror?.(e);\n                    // We do not throw here so we continue processing events after reporting the error\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === 'AbortError') {\n                return;\n              }\n\n              this.onerror?.(error);\n              reject(error);\n            }\n          };\n\n          this.sseConnection = {\n            close: () => reader.cancel(),\n          };\n\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === 'AbortError') {\n            return;\n          }\n\n          this.onerror?.(error);\n          reject(error);\n        }\n      };\n\n      establishConnection();\n    });\n  }\n\n  async close(): Promise<void> {\n    this.connected = false;\n    this.sseConnection?.close();\n    this.abortController?.abort();\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: 'MCP SSE Transport Error: Not connected',\n      });\n    }\n\n    try {\n      const headers = new Headers(this.headers);\n      headers.set('Content-Type', 'application/json');\n      const init = {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(message),\n        signal: this.abortController?.signal,\n      };\n\n      const response = await fetch(this.endpoint, init);\n\n      if (!response.ok) {\n        const text = await response.text().catch(() => null);\n        const error = new MCPClientError({\n          message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text}`,\n        });\n        this.onerror?.(error);\n        return;\n      }\n    } catch (error) {\n      this.onerror?.(error);\n      return;\n    }\n  }\n}\n\nexport function deserializeMessage(line: string): JSONRPCMessage {\n  return JSONRPCMessageSchema.parse(JSON.parse(line));\n}\n","import { z } from 'zod';\nimport { BaseParamsSchema, RequestSchema, ResultSchema } from './types';\n\nconst JSONRPC_VERSION = '2.0';\n\nconst JSONRPCRequestSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n  })\n  .merge(RequestSchema)\n  .strict();\n\nexport type JSONRPCRequest = z.infer<typeof JSONRPCRequestSchema>;\n\nconst JSONRPCResponseSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    result: ResultSchema,\n  })\n  .strict();\n\nexport type JSONRPCResponse = z.infer<typeof JSONRPCResponseSchema>;\n\nconst JSONRPCErrorSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    error: z.object({\n      code: z.number().int(),\n      message: z.string(),\n      data: z.optional(z.unknown()),\n    }),\n  })\n  .strict();\n\nexport type JSONRPCError = z.infer<typeof JSONRPCErrorSchema>;\n\nconst JSONRPCNotificationSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n  })\n  .merge(\n    z.object({\n      method: z.string(),\n      params: z.optional(BaseParamsSchema),\n    }),\n  )\n  .strict();\n\nexport type JSONRPCNotification = z.infer<typeof JSONRPCNotificationSchema>;\n\nexport const JSONRPCMessageSchema = z.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema,\n]);\n\nexport type JSONRPCMessage = z.infer<typeof JSONRPCMessageSchema>;\n","import { z } from 'zod';\nimport {\n  inferParameters,\n  Tool,\n  ToolExecutionOptions,\n  ToolParameters,\n} from '../tool';\n\nexport const LATEST_PROTOCOL_VERSION = '2024-11-05';\nexport const SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  '2024-10-07',\n];\n\nexport type ToolSchemas =\n  | Record<string, { parameters: ToolParameters }>\n  | 'automatic'\n  | undefined;\n\nexport type McpToolSet<TOOL_SCHEMAS extends ToolSchemas = 'automatic'> =\n  TOOL_SCHEMAS extends Record<string, { parameters: ToolParameters }>\n    ? {\n        [K in keyof TOOL_SCHEMAS]: Tool<\n          TOOL_SCHEMAS[K]['parameters'],\n          CallToolResult\n        > & {\n          execute: (\n            args: inferParameters<TOOL_SCHEMAS[K]['parameters']>,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      }\n    : {\n        [k: string]: Tool<z.ZodUnknown, CallToolResult> & {\n          execute: (\n            args: unknown,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      };\n\nconst ClientOrServerImplementationSchema = z\n  .object({\n    name: z.string(),\n    version: z.string(),\n  })\n  .passthrough();\nexport type Configuration = z.infer<typeof ClientOrServerImplementationSchema>;\n\nexport const BaseParamsSchema = z\n  .object({\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\ntype BaseParams = z.infer<typeof BaseParamsSchema>;\nexport const ResultSchema = BaseParamsSchema;\n\nexport const RequestSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseParamsSchema),\n});\nexport type Request = z.infer<typeof RequestSchema>;\nexport type RequestOptions = {\n  signal?: AbortSignal;\n  timeout?: number;\n  maxTotalTimeout?: number;\n};\n\nexport type Notification = z.infer<typeof RequestSchema>;\n\nconst ServerCapabilitiesSchema = z\n  .object({\n    experimental: z.optional(z.object({}).passthrough()),\n    logging: z.optional(z.object({}).passthrough()),\n    prompts: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    resources: z.optional(\n      z\n        .object({\n          subscribe: z.optional(z.boolean()),\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    tools: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n  })\n  .passthrough();\nexport type ServerCapabilities = z.infer<typeof ServerCapabilitiesSchema>;\n\nexport const InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: z.optional(z.string()),\n});\nexport type InitializeResult = z.infer<typeof InitializeResultSchema>;\n\nexport type PaginatedRequest = Request & {\n  params?: BaseParams & {\n    cursor?: string;\n  };\n};\n\nconst PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: z.optional(z.string()),\n});\n\nconst ToolSchema = z\n  .object({\n    name: z.string(),\n    description: z.optional(z.string()),\n    inputSchema: z\n      .object({\n        type: z.literal('object'),\n        properties: z.optional(z.object({}).passthrough()),\n      })\n      .passthrough(),\n  })\n  .passthrough();\nexport type MCPTool = z.infer<typeof ToolSchema>;\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: z.array(ToolSchema),\n});\nexport type ListToolsResult = z.infer<typeof ListToolsResultSchema>;\n\nconst TextContentSchema = z\n  .object({\n    type: z.literal('text'),\n    text: z.string(),\n  })\n  .passthrough();\nconst ImageContentSchema = z\n  .object({\n    type: z.literal('image'),\n    data: z.string().base64(),\n    mimeType: z.string(),\n  })\n  .passthrough();\nconst ResourceContentsSchema = z\n  .object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n  })\n  .passthrough();\nconst TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: z.string(),\n});\nconst BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: z.string().base64(),\n});\nconst EmbeddedResourceSchema = z\n  .object({\n    type: z.literal('resource'),\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  })\n  .passthrough();\n\nexport const CallToolResultSchema = ResultSchema.extend({\n  content: z.array(\n    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema]),\n  ),\n  isError: z.boolean().default(false).optional(),\n}).or(\n  ResultSchema.extend({\n    toolResult: z.unknown(),\n  }),\n);\nexport type CallToolResult = z.infer<typeof CallToolResultSchema>;\n","import { MCPClientError } from '../../../errors';\nimport { JSONRPCMessage } from './json-rpc-message';\nimport { SseMCPTransport } from './mcp-sse-transport';\n\n/**\n * Transport interface for MCP (Model Context Protocol) communication.\n * Maps to the `Transport` interface in the MCP spec.\n */\nexport interface MCPTransport {\n  /**\n   * Initialize and start the transport\n   */\n  start(): Promise<void>;\n\n  /**\n   * Send a JSON-RPC message through the transport\n   * @param message The JSON-RPC message to send\n   */\n  send(message: JSONRPCMessage): Promise<void>;\n\n  /**\n   * Clean up and close the transport\n   */\n  close(): Promise<void>;\n\n  /**\n   * Event handler for transport closure\n   */\n  onclose?: () => void;\n\n  /**\n   * Event handler for transport errors\n   */\n  onerror?: (error: Error) => void;\n\n  /**\n   * Event handler for received messages\n   */\n  onmessage?: (message: JSONRPCMessage) => void;\n}\n\nexport type MCPTransportConfig = {\n  type: 'sse';\n\n  /**\n   * The URL of the MCP server.\n   */\n  url: string;\n\n  /**\n   * Additional HTTP headers to be sent with requests.\n   */\n  headers?: Record<string, string>;\n};\n\nexport function createMcpTransport(config: MCPTransportConfig): MCPTransport {\n  if (config.type !== 'sse') {\n    throw new MCPClientError({\n      message:\n        'Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.',\n    });\n  }\n\n  return new SseMCPTransport(config);\n}\n\nexport function isCustomMcpTransport(\n  transport: MCPTransportConfig | MCPTransport,\n): transport is MCPTransport {\n  return (\n    'start' in transport &&\n    typeof transport.start === 'function' &&\n    'send' in transport &&\n    typeof transport.send === 'function' &&\n    'close' in transport &&\n    typeof transport.close === 'function'\n  );\n}\n","import { InvalidArgumentError } from '../../errors/invalid-argument-error';\n\n/**\n * Calculates the cosine similarity between two vectors. This is a useful metric for\n * comparing the similarity of two vectors such as embeddings.\n *\n * @param vector1 - The first vector.\n * @param vector2 - The second vector.\n * @param options - Optional configuration.\n * @param options.throwErrorForEmptyVectors - If true, throws an error for empty vectors. Default: false.\n *\n * @returns The cosine similarity between vector1 and vector2.\n * @returns 0 if either vector is the zero vector.\n *\n * @throws {InvalidArgumentError} If throwErrorForEmptyVectors is true and vectors are empty.\n * @throws {InvalidArgumentError} If the vectors do not have the same length.\n */\nexport function cosineSimilarity(\n  vector1: number[],\n  vector2: number[],\n  // TODO remove throw option in 5.0\n  options?: {\n    /**\n     * @deprecated will be removed in 5.0\n     */\n    throwErrorForEmptyVectors?: boolean;\n  },\n): number {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: 'vector1,vector2',\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`,\n    });\n  }\n\n  const n = vector1.length;\n\n  if (n === 0) {\n    if (options?.throwErrorForEmptyVectors) {\n      throw new InvalidArgumentError({\n        parameter: 'vector1',\n        value: vector1,\n        message: 'Vectors cannot be empty',\n      });\n    }\n\n    return 0; // Return 0 for empty vectors if no error is thrown\n  }\n\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0\n    ? 0\n    : dotProduct /\n        (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n","import { delay as delayFunction } from '@ai-sdk/provider-utils';\n\n/**\n * Creates a ReadableStream that emits the provided values with an optional delay between each value.\n *\n * @param options - The configuration options\n * @param options.chunks - Array of values to be emitted by the stream\n * @param options.initialDelayInMs - Optional initial delay in milliseconds before emitting the first value (default: 0). Can be set to `null` to skip the initial delay. The difference between `initialDelayInMs: null` and `initialDelayInMs: 0` is that `initialDelayInMs: null` will emit the values without any delay, while `initialDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @param options.chunkDelayInMs - Optional delay in milliseconds between emitting each value (default: 0). Can be set to `null` to skip the delay. The difference between `chunkDelayInMs: null` and `chunkDelayInMs: 0` is that `chunkDelayInMs: null` will emit the values without any delay, while `chunkDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @returns A ReadableStream that emits the provided values\n */\nexport function simulateReadableStream<T>({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal,\n}: {\n  chunks: T[];\n  initialDelayInMs?: number | null;\n  chunkDelayInMs?: number | null;\n  _internal?: {\n    delay?: (ms: number | null) => Promise<void>;\n  };\n}): ReadableStream<T> {\n  const delay = _internal?.delay ?? delayFunction;\n\n  let index = 0;\n\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    },\n  });\n}\n","import {\n  AssistantMessage,\n  DataMessage,\n  formatAssistantStreamPart,\n} from '@ai-sdk/ui-utils';\n\n/**\nYou can pass the thread and the latest message into the `AssistantResponse`. This establishes the context for the response.\n */\ntype AssistantResponseSettings = {\n  /**\nThe thread ID that the response is associated with.\n   */\n  threadId: string;\n\n  /**\nThe ID of the latest message that the response is associated with.\n */\n  messageId: string;\n};\n\n/**\nThe process parameter is a callback in which you can run the assistant on threads, and send messages and data messages to the client.\n */\ntype AssistantResponseCallback = (options: {\n  /**\nForwards an assistant message (non-streaming) to the client.\n   */\n  sendMessage: (message: AssistantMessage) => void;\n\n  /**\nSend a data message to the client. You can use this to provide information for rendering custom UIs while the assistant is processing the thread.\n */\n  sendDataMessage: (message: DataMessage) => void;\n\n  /**\nForwards the assistant response stream to the client. Returns the `Run` object after it completes, or when it requires an action.\n   */\n  forwardStream: (stream: any) => Promise<any | undefined>;\n}) => Promise<void>;\n\n/**\nThe `AssistantResponse` allows you to send a stream of assistant update to `useAssistant`.\nIt is designed to facilitate streaming assistant responses to the `useAssistant` hook.\nIt receives an assistant thread and a current message, and can send messages and data messages to the client.\n */\nexport function AssistantResponse(\n  { threadId, messageId }: AssistantResponseSettings,\n  process: AssistantResponseCallback,\n): Response {\n  const stream = new ReadableStream({\n    async start(controller) {\n      const textEncoder = new TextEncoder();\n\n      const sendMessage = (message: AssistantMessage) => {\n        controller.enqueue(\n          textEncoder.encode(\n            formatAssistantStreamPart('assistant_message', message),\n          ),\n        );\n      };\n\n      const sendDataMessage = (message: DataMessage) => {\n        controller.enqueue(\n          textEncoder.encode(\n            formatAssistantStreamPart('data_message', message),\n          ),\n        );\n      };\n\n      const sendError = (errorMessage: string) => {\n        controller.enqueue(\n          textEncoder.encode(formatAssistantStreamPart('error', errorMessage)),\n        );\n      };\n\n      const forwardStream = async (stream: any) => {\n        let result: any | undefined = undefined;\n\n        for await (const value of stream) {\n          switch (value.event) {\n            case 'thread.message.created': {\n              controller.enqueue(\n                textEncoder.encode(\n                  formatAssistantStreamPart('assistant_message', {\n                    id: value.data.id,\n                    role: 'assistant',\n                    content: [{ type: 'text', text: { value: '' } }],\n                  }),\n                ),\n              );\n              break;\n            }\n\n            case 'thread.message.delta': {\n              const content = value.data.delta.content?.[0];\n\n              if (content?.type === 'text' && content.text?.value != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    formatAssistantStreamPart('text', content.text.value),\n                  ),\n                );\n              }\n\n              break;\n            }\n\n            case 'thread.run.completed':\n            case 'thread.run.requires_action': {\n              result = value.data;\n              break;\n            }\n          }\n        }\n\n        return result;\n      };\n\n      // send the threadId and messageId as the first message:\n      controller.enqueue(\n        textEncoder.encode(\n          formatAssistantStreamPart('assistant_control_data', {\n            threadId,\n            messageId,\n          }),\n        ),\n      );\n\n      try {\n        await process({\n          sendMessage,\n          sendDataMessage,\n          forwardStream,\n        });\n      } catch (error) {\n        sendError((error as any).message ?? `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {},\n    cancel() {},\n  });\n\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      'Content-Type': 'text/plain; charset=utf-8',\n    },\n  });\n}\n","import { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype LangChainImageDetail = 'auto' | 'low' | 'high';\n\ntype LangChainMessageContentText = {\n  type: 'text';\n  text: string;\n};\n\ntype LangChainMessageContentImageUrl = {\n  type: 'image_url';\n  image_url:\n    | string\n    | {\n        url: string;\n        detail?: LangChainImageDetail;\n      };\n};\n\ntype LangChainMessageContentComplex =\n  | LangChainMessageContentText\n  | LangChainMessageContentImageUrl\n  | (Record<string, any> & {\n      type?: 'text' | 'image_url' | string;\n    })\n  | (Record<string, any> & {\n      type?: never;\n    });\n\ntype LangChainMessageContent = string | LangChainMessageContentComplex[];\n\ntype LangChainAIMessageChunk = {\n  content: LangChainMessageContent;\n};\n\n// LC stream event v2\ntype LangChainStreamEvent = {\n  event: string;\n  data: any;\n};\n\nfunction toDataStreamInternal(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return stream\n    .pipeThrough(\n      new TransformStream<\n        LangChainStreamEvent | LangChainAIMessageChunk | string\n      >({\n        transform: async (value, controller) => {\n          // text stream:\n          if (typeof value === 'string') {\n            controller.enqueue(value);\n            return;\n          }\n\n          // LC stream events v2:\n          if ('event' in value) {\n            // chunk is AIMessage Chunk for on_chat_model_stream event:\n            if (value.event === 'on_chat_model_stream') {\n              forwardAIMessageChunk(\n                value.data?.chunk as LangChainAIMessageChunk,\n                controller,\n              );\n            }\n            return;\n          }\n\n          // AI Message chunk stream:\n          forwardAIMessageChunk(value, controller);\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\n/**\nConverts LangChain output streams to an AI SDK Data Stream.\n\nThe following streams are supported:\n- `LangChainAIMessageChunk` streams (LangChain `model.stream` output)\n- `string` streams (LangChain `StringOutputParser` output)\n */\nexport function toDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options?: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  const dataStream = toDataStreamInternal(\n    stream,\n    options?.callbacks,\n  ).pipeThrough(new TextEncoderStream());\n  const data = options?.data;\n  const init = options?.init;\n\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options: { dataStream: DataStreamWriter; callbacks?: StreamCallbacks },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction forwardAIMessageChunk(\n  chunk: LangChainAIMessageChunk,\n  controller: TransformStreamDefaultController<any>,\n) {\n  if (typeof chunk.content === 'string') {\n    controller.enqueue(chunk.content);\n  } else {\n    const content: LangChainMessageContentComplex[] = chunk.content;\n    for (const item of content) {\n      if (item.type === 'text') {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n","/**\n * Configuration options and helper callback methods for stream lifecycle events.\n */\nexport interface StreamCallbacks {\n  /** `onStart`: Called once when the stream is initialized. */\n  onStart?: () => Promise<void> | void;\n\n  /**\n   * `onCompletion`: Called for each tokenized message.\n   *\n   * @deprecated Use `onFinal` instead.\n   */\n  onCompletion?: (completion: string) => Promise<void> | void;\n\n  /** `onFinal`: Called once when the stream is closed with the final completion message. */\n  onFinal?: (completion: string) => Promise<void> | void;\n\n  /** `onToken`: Called for each tokenized message. */\n  onToken?: (token: string) => Promise<void> | void;\n\n  /** `onText`: Called for each text chunk. */\n  onText?: (text: string) => Promise<void> | void;\n}\n\n/**\n * Creates a transform stream that encodes input messages and invokes optional callback functions.\n * The transform stream uses the provided callbacks to execute custom logic at different stages of the stream's lifecycle.\n * - `onStart`: Called once when the stream is initialized.\n * - `onToken`: Called for each tokenized message.\n * - `onCompletion`: Called every time a completion message is received. This can occur multiple times when using e.g. OpenAI functions\n * - `onFinal`: Called once when the stream is closed with the final completion message.\n *\n * This function is useful when you want to process a stream of messages and perform specific actions during the stream's lifecycle.\n *\n * @param {StreamCallbacks} [callbacks] - An object containing the callback functions.\n * @return {TransformStream<string, Uint8Array>} A transform stream that encodes input messages as Uint8Array and allows the execution of custom logic through callbacks.\n *\n * @example\n * const callbacks = {\n *   onStart: async () => console.log('Stream started'),\n *   onToken: async (token) => console.log(`Token: ${token}`),\n *   onCompletion: async (completion) => console.log(`Completion: ${completion}`)\n *   onFinal: async () => data.close()\n * };\n * const transformer = createCallbacksTransformer(callbacks);\n */\nexport function createCallbacksTransformer(\n  callbacks: StreamCallbacks | undefined = {},\n): TransformStream<string, Uint8Array> {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = '';\n\n  return new TransformStream({\n    async start(): Promise<void> {\n      if (callbacks.onStart) await callbacks.onStart();\n    },\n\n    async transform(message, controller): Promise<void> {\n      controller.enqueue(textEncoder.encode(message));\n\n      aggregatedResponse += message;\n\n      if (callbacks.onToken) await callbacks.onToken(message);\n      if (callbacks.onText && typeof message === 'string') {\n        await callbacks.onText(message);\n      }\n    },\n\n    async flush(): Promise<void> {\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    },\n  });\n}\n","import { convertAsyncIteratorToReadableStream } from '@ai-sdk/provider-utils';\nimport { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype EngineResponse = {\n  delta: string;\n};\n\nfunction toDataStreamInternal(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  const trimStart = trimStartOfStream();\n\n  return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]())\n    .pipeThrough(\n      new TransformStream({\n        async transform(message, controller): Promise<void> {\n          controller.enqueue(trimStart(message.delta));\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\nexport function toDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  } = {},\n) {\n  const { init, data, callbacks } = options;\n  const dataStream = toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    dataStream: DataStreamWriter;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction trimStartOfStream(): (text: string) => string {\n  let isStreamStart = true;\n\n  return (text: string): string => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text) isStreamStart = false;\n    }\n    return text;\n  };\n}\n","import { JSONValue, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { HANGING_STREAM_WARNING_TIME_MS } from '../util/constants';\n\n/**\n * A stream wrapper to send custom JSON-encoded data back to the client.\n *\n * @deprecated Please use `createDataStream`, `createDataStreamResponse`, and `pipeDataStreamToResponse` instead.\n */\nexport class StreamData {\n  private encoder = new TextEncoder();\n\n  private controller: ReadableStreamController<Uint8Array> | null = null;\n  public stream: ReadableStream<Uint8Array>;\n\n  private isClosed: boolean = false;\n  private warningTimeout: NodeJS.Timeout | null = null;\n\n  constructor() {\n    const self = this;\n\n    this.stream = new ReadableStream({\n      start: async controller => {\n        self.controller = controller;\n\n        // Set a timeout to show a warning if the stream is not closed within 3 seconds\n        if (process.env.NODE_ENV === 'development') {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              'The data stream is hanging. Did you forget to close it with `data.close()`?',\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: controller => {\n        // No-op: we don't need to do anything special on pull\n      },\n      cancel: reason => {\n        this.isClosed = true;\n      },\n    });\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.close();\n    this.isClosed = true;\n\n    // Clear the warning timeout if the stream is closed\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n\n  append(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatDataStreamPart('data', [value])),\n    );\n  }\n\n  appendMessageAnnotation(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatDataStreamPart('message_annotations', [value])),\n    );\n  }\n}\n","/**\n * Warning time for notifying developers that a stream is hanging in dev mode\n * using a console.warn.\n */\nexport const HANGING_STREAM_WARNING_TIME_MS = 15 * 1000;\n"],"mappings":"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","names":["createIdGenerator","generateId","formatDataStreamPart","jsonSchema","AISDKError","name","marker","symbol","_a","_a","name","name","attributes","_a","embedding","usage","embeddings","_a","usage","AISDKError","name","marker","symbol","_a","convertBase64ToUint8Array","_a","TypeValidationError","AISDKError","name","marker","symbol","_a","text","AISDKError","name","marker","symbol","_a","_a","convertBase64ToUint8Array","convertUint8ArrayToBase64","AISDKError","name","marker","symbol","_a","_a","convertUint8ArrayToBase64","convertBase64ToUint8Array","AISDKError","name","marker","symbol","_a","_a","z","_a","AISDKError","name","marker","symbol","_a","_a","processBlock","content","tool","i","z","z","z","z","z","z","z","z","z","safeValidateTypes","safeValidateTypes","_a","generateId","_a","span","_b","_c","_d","result","object","TypeValidationError","createIdGenerator","_a","_a","originalGenerateId","createIdGenerator","generateId","now","_a","doStreamSpan","object","_b","error","createIdGenerator","AISDKError","name","marker","symbol","_a","AISDKError","getErrorMessage","name","marker","symbol","_a","asSchema","object","name","tool","asSchema","text","text","safeParseJSON","safeValidateTypes","asSchema","AISDKError","getErrorMessage","name","marker","symbol","_a","AISDKError","name","marker","symbol","_a","AISDKError","getErrorMessage","name","marker","symbol","_a","asSchema","tool","safeValidateTypes","safeParseJSON","text","tool","originalGenerateId","createIdGenerator","generateId","_a","text","tool","span","_b","_c","_d","_e","_f","result","safeParseJSON","safeValidateTypes","asSchema","parsePartialJson","AISDKError","APICallError","InvalidPromptError","JSONParseError","TypeValidationError","UnsupportedFunctionalityError","AISDKError","name","marker","symbol","_a","AISDKError","name","marker","symbol","_a","text","asSchema","parsePartialJson","safeParseJSON","safeValidateTypes","InvalidArgumentError","delay","AISDKError","createIdGenerator","formatDataStreamPart","result","tool","originalGenerateId","createIdGenerator","originalGenerateMessageId","now","generateId","text","_a","AISDKError","stepType","stream","tool","doStreamSpan","stepReasoning","stepFiles","activeReasoningText","getErrorMessage","formatDataStreamPart","AISDKError","text","_a","AISDKError","_a","_a","text","text","_a","AISDKError","_a","getToolInvocations","NoSuchModelError","AISDKError","NoSuchModelError","name","marker","symbol","_a","NoSuchModelError","NoSuchModelError","_a","tool","z","z","z","_a","_b","_c","text","name","_a","_a","delay","formatAssistantStreamPart","process","_a","stream","formatDataStreamPart","_a","formatDataStreamPart","mergeIntoDataStream","toDataStream","toDataStreamResponse","formatDataStreamPart","toDataStreamInternal","formatDataStreamPart","toDataStream","toDataStreamResponse","_a","mergeIntoDataStream","text","formatDataStreamPart","formatDataStreamPart"]}