// src/index.ts
import fs5 from "node:fs/promises";
import path6 from "node:path";

// src/build.ts
import fs, { copyFile } from "node:fs/promises";
import { builtinModules } from "node:module";
import path2, { basename } from "node:path";
import { findRoot } from "@manypkg/find-root";
import { getNodeVersion } from "@vercel/build-utils";
import { nodeFileTrace } from "@vercel/nft";
import { build } from "esbuild";
import glob from "fast-glob";
import { generateCode, loadFile } from "magicast";

// src/assert.ts
import { newError } from "@brillout/libassert";
var libName = "vite-plugin-vercel";
function assert(condition, errorMessage) {
  if (condition) {
    return;
  }
  const err = newError(`[${libName}][Wrong Usage] ${errorMessage}`, 2);
  throw err;
}

// src/schemas/config/vc-config.ts
import { z } from "zod";
var vercelOutputEdgeVcConfigSchema = z.object({
  runtime: z.literal("edge"),
  entrypoint: z.string(),
  envVarsInUse: z.array(z.string()).optional()
}).strict();
var vercelOutputServerlessVcConfigSchema = z.object({
  runtime: z.string(),
  handler: z.string(),
  memory: z.number().int().min(128).max(3008).optional(),
  maxDuration: z.number().int().positive().optional(),
  environment: z.record(z.string()).optional(),
  regions: z.array(z.string()).optional(),
  supportsWrapper: z.boolean().optional(),
  supportsResponseStreaming: z.boolean().optional()
}).strict();
var vercelOutputServerlessNodeVcConfigSchema = vercelOutputServerlessVcConfigSchema.extend({
  launcherType: z.literal("Nodejs"),
  shouldAddHelpers: z.boolean().optional(),
  shouldAddSourcemapSupport: z.boolean().optional(),
  awsLambdaHandler: z.string().optional()
}).strict();
var vercelOutputVcConfigSchema = z.union([
  vercelOutputEdgeVcConfigSchema,
  vercelOutputServerlessVcConfigSchema,
  vercelOutputServerlessNodeVcConfigSchema
]);

// src/schemas/exports.ts
import { z as z2 } from "zod";
var vercelEndpointExports = z2.object({
  edge: z2.boolean().optional(),
  headers: z2.record(z2.string()).optional(),
  streaming: z2.boolean().optional(),
  isr: z2.object({
    expiration: z2.number().or(z2.literal(false))
  }).optional()
});

// src/utils.ts
import { normalizePath } from "vite";
import path from "node:path";
function getRoot(config) {
  return normalizePath(config.root || process.cwd());
}
function getOutput(config, suffix) {
  return path.join(
    config.vercel?.outDir ? "" : getRoot(config),
    config.vercel?.outDir ?? ".vercel/output",
    suffix ?? ""
  );
}
function getPublic(config) {
  return path.join(getRoot(config), config.publicDir || "public");
}
function pathRelativeTo(filePath, config, rel) {
  const root = getRoot(config);
  return normalizePath(path.relative(normalizePath(path.join(root, rel)), filePath));
}

// src/build.ts
async function getAdditionalEndpoints(resolvedConfig) {
  const userEndpoints = [];
  if (Array.isArray(resolvedConfig.vercel?.additionalEndpoints)) {
    for (const endpoint of resolvedConfig.vercel.additionalEndpoints) {
      if (typeof endpoint === "function") {
        const res = await endpoint();
        if (Array.isArray(res)) {
          userEndpoints.push(...res);
        } else {
          userEndpoints.push(res);
        }
      } else {
        userEndpoints.push(endpoint);
      }
    }
  }
  return userEndpoints.map((e) => ({
    ...e,
    route: e.route ?? true,
    // path.resolve removes the trailing slash if any
    destination: `${path2.posix.resolve("/", e.destination)}.func`
  }));
}
async function getEntries(resolvedConfig) {
  const apiEntries = glob.sync(`${getRoot(resolvedConfig)}/api/**/*.*([a-zA-Z0-9])`).filter((filepath) => !path2.basename(filepath).startsWith("_"));
  if (apiEntries.length > 0) {
    console.warn(
      "@vercel/build is currently force building /api files itself, with no way to disable it. In order to avoid double compilation, you should temporarily rename /api to /_api while using this plugin. /_api functions are compiled under .vercel/output/functions/api/*.func as if they were in /api."
    );
  }
  const otherApiEntries = glob.sync(`${getRoot(resolvedConfig)}/_api/**/*.*([a-zA-Z0-9])`).filter((filepath) => !path2.basename(filepath).startsWith("_"));
  return [...apiEntries, ...otherApiEntries].reduce(
    (entryPoints, filePath) => {
      const outFilePath = pathRelativeTo(filePath, resolvedConfig, filePath.includes("/_api/") ? "_api" : "api");
      const parsed = path2.posix.parse(outFilePath);
      entryPoints.push({
        source: filePath,
        destination: `api/${path2.posix.join(parsed.dir, parsed.name)}.func`,
        route: true
      });
      return entryPoints;
    },
    await getAdditionalEndpoints(resolvedConfig)
  );
}
var edgeWasmPlugin = {
  name: "edge-wasm-vercel",
  setup(build2) {
    build2.onResolve({ filter: /\.wasm/ }, (args) => {
      return {
        path: args.path.replace(/\.wasm\?module$/i, ".wasm"),
        external: true
      };
    });
  }
};
var vercelOgPlugin = (ctx) => {
  return {
    name: "vercel-og",
    setup(build2) {
      build2.onResolve({ filter: /@vercel\/og/ }, () => {
        ctx.found = true;
        return void 0;
      });
      build2.onLoad({ filter: /@vercel\/og/ }, (args) => {
        ctx.index = args.path;
        return void 0;
      });
    }
  };
};
var standardBuildOptions = {
  bundle: true,
  target: "es2022",
  format: "esm",
  platform: "node",
  logLevel: "info",
  logOverride: {
    "ignored-bare-import": "verbose",
    "require-resolve-not-external": "verbose"
  },
  minify: false,
  plugins: [],
  define: {
    "process.env.NODE_ENV": '"production"',
    "import.meta.env.NODE_ENV": '"production"'
  }
};
async function buildFn(resolvedConfig, entry, buildOptions) {
  assert(
    entry.destination.length > 0,
    `Endpoint ${typeof entry.source === "string" ? entry.source : "-"} does not have build destination`
  );
  const options = Object.assign({}, standardBuildOptions);
  if (buildOptions) {
    Object.assign(options, buildOptions);
  }
  const filename = entry.edge || options.format === "cjs" ? "index.js" : "index.mjs";
  const outfile = path2.join(getOutput(resolvedConfig, "functions"), entry.destination, filename);
  Object.assign(options, { outfile });
  if (!options.stdin) {
    if (typeof entry.source === "string") {
      options.entryPoints = [entry.source];
    } else {
      assert(typeof entry.source === "object", "`{ source }` must be a string or an object");
      assert(typeof entry.source.contents === "string", "`{ contents }` must be a string");
      options.stdin = entry.source;
    }
  }
  if (entry.edge) {
    options.platform = void 0;
    options.external = [...builtinModules, ...builtinModules.map((m) => `node:${m}`)];
    options.conditions = ["edge-light", "worker", "browser", "module", "import", "require"];
    options.plugins?.push(edgeWasmPlugin);
    options.format = "esm";
  } else if (options.format === "esm") {
    options.banner = {
      js: `import { createRequire as VPV_createRequire } from "node:module";
import { fileURLToPath as VPV_fileURLToPath } from "node:url";
import { dirname as VPV_dirname } from "node:path";
const require = VPV_createRequire(import.meta.url);
const __filename = VPV_fileURLToPath(import.meta.url);
const __dirname = VPV_dirname(__filename);
`
    };
  }
  const ctx = { found: false, index: "" };
  options.plugins?.push(vercelOgPlugin(ctx));
  const output = await build(options);
  if (typeof entry.source === "string") {
    let base = resolvedConfig.root;
    try {
      const dir = await findRoot(resolvedConfig.root);
      base = dir.rootDir;
    } catch (e) {
    }
    const { fileList, reasons } = await nodeFileTrace([entry.source], {
      base,
      processCwd: resolvedConfig.root,
      mixedModules: true,
      ignore: [
        "**/node_modules/react{,-dom,-dom-server-turbopack}/**/*.development.js",
        "**/*.d.ts",
        "**/*.map",
        "**/node_modules/webpack5/**/*"
      ],
      async readFile(filepath) {
        if (filepath.endsWith(".ts") || filepath.endsWith(".tsx")) {
          const result = await build({
            ...standardBuildOptions,
            entryPoints: [entry.source],
            bundle: false,
            write: false
          });
          return result.outputFiles[0].text;
        }
        return fs.readFile(filepath, "utf-8");
      }
    });
    for (const file of fileList) {
      if (reasons.has(file) && reasons.get(file)?.type.includes("asset") && !file.endsWith(".js") && !file.endsWith(".cjs") && !file.endsWith(".mjs") && !file.endsWith("package.json")) {
        await copyFile(
          path2.join(base, file),
          path2.join(getOutput(resolvedConfig, "functions"), entry.destination, basename(file))
        );
      }
    }
  }
  await writeVcConfig(resolvedConfig, entry.destination, filename, {
    edge: Boolean(entry.edge),
    streaming: entry.streaming
  });
  return output;
}
async function writeVcConfig(resolvedConfig, destination, filename, options) {
  const vcConfig = path2.join(getOutput(resolvedConfig, "functions"), destination, ".vc-config.json");
  const nodeVersion = await getNodeVersion(getOutput(resolvedConfig));
  await fs.writeFile(
    vcConfig,
    JSON.stringify(
      vercelOutputVcConfigSchema.parse(
        options.edge ? {
          runtime: "edge",
          entrypoint: filename
        } : {
          runtime: nodeVersion.runtime,
          handler: filename,
          maxDuration: resolvedConfig.vercel?.defaultMaxDuration,
          launcherType: "Nodejs",
          shouldAddHelpers: true,
          supportsResponseStreaming: options.streaming ?? resolvedConfig.vercel?.defaultSupportsResponseStreaming
        }
      ),
      void 0,
      2
    ),
    "utf-8"
  );
}
function getSourceAndDestination(destination) {
  if (destination.startsWith("api/")) {
    return path2.posix.resolve("/", destination);
  }
  return path2.posix.resolve("/", destination, ":match*");
}
var RE_BRACKETS = /^\[([^/]+)\]$/gm;
function replaceBrackets(source) {
  return source.split("/").map((segment) => segment.replace(RE_BRACKETS, ":$1")).join("/");
}
function isPrimitive(test) {
  return test !== Object(test);
}
function _eval(code) {
  const func = new Function(`{ return function(){ return ${code} } };`);
  return func.call(null).call(null);
}
function evalExport(exp) {
  if (!exp) return;
  const code = isPrimitive(exp) ? exp : generateCode(exp).code;
  return _eval(code);
}
async function extractExports(filepath) {
  try {
    const mod = await loadFile(filepath);
    const subject = {
      edge: evalExport(mod.exports.edge),
      headers: evalExport(mod.exports.headers),
      streaming: evalExport(mod.exports.streaming),
      isr: evalExport(mod.exports.isr)
    };
    return vercelEndpointExports.parse(subject);
  } catch (e) {
    console.warn(`Warning: failed to read exports of '${filepath}'`, e);
  }
}
async function extractHeaders(resolvedConfig) {
  let headers = [];
  if (typeof resolvedConfig.vercel?.headers === "function") {
    headers = await resolvedConfig.vercel.headers();
  } else if (Array.isArray(resolvedConfig.vercel?.headers)) {
    headers = resolvedConfig.vercel.headers;
  }
  return headers;
}
async function buildEndpoints(resolvedConfig) {
  const entries = await getEntries(resolvedConfig);
  const headers = await extractHeaders(resolvedConfig);
  for (const entry of entries) {
    if (typeof entry.source === "string") {
      const exports = await extractExports(entry.source);
      if (exports) {
        if (entry.headers || exports.headers) {
          entry.headers = {
            ...exports.headers,
            ...entry.headers
          };
        }
        if (entry.edge !== void 0 && exports.edge !== void 0) {
          throw new Error(
            `edge configuration should be defined either in the endpoint itself or through Vite config, not both ('${entry.source}')`
          );
        }
        if (exports.edge !== void 0) {
          entry.edge = exports.edge;
        }
        if (entry.isr !== void 0 && exports.isr !== void 0) {
          throw new Error(
            `isr configuration should be defined either in the endpoint itself or through Vite config, not both ('${entry.source}')`
          );
        }
        if ((entry.isr !== void 0 || exports.isr !== void 0) && (entry.edge !== void 0 || exports.edge !== void 0)) {
          throw new Error(`isr cannot be enabled for edge functions ('${entry.source}')`);
        }
        if (exports.isr) {
          entry.isr = exports.isr;
        }
        if (typeof exports.streaming === "boolean") {
          entry.streaming = exports.streaming;
        }
      }
    }
    await buildFn(resolvedConfig, entry, entry.buildOptions);
  }
  const isrEntries = entries.filter((e) => e.isr).map((e) => [e.destination.replace(/\.func$/, ""), { expiration: e.isr?.expiration }]);
  return {
    rewrites: entries.filter((e) => {
      if (e.addRoute === void 0 && e.route !== void 0) {
        return e.route !== false;
      }
      if (e.addRoute !== void 0 && e.route === void 0) {
        return e.addRoute !== false;
      }
      if (e.addRoute !== void 0 && e.route !== void 0) {
        throw new Error("Cannot use both `route` and `addRoute` in `additionalEndpoints`");
      }
      return true;
    }).map((e) => {
      const destination = e.destination.replace(/\.func$/, "");
      if (typeof e.route === "string") {
        return {
          source: `(${e.route})`,
          destination: `${destination}/?__original_path=$1`
        };
      }
      return {
        source: replaceBrackets(getSourceAndDestination(destination)),
        destination: getSourceAndDestination(destination)
      };
    }),
    isr: Object.fromEntries(isrEntries),
    headers: [
      ...entries.filter((e) => e.headers).map((e) => ({
        source: `/${e.destination.replace(/\.func$/, "")}`,
        headers: Object.entries(e.headers ?? {}).map(([key, value]) => ({
          key,
          value
        }))
      })),
      ...headers
    ]
  };
}

// src/config.ts
import path3 from "node:path";

// src/schemas/config/config.ts
import { z as z3 } from "zod";
var HasOrMissing = z3.array(
  z3.union([
    z3.object({
      type: z3.literal("host"),
      value: z3.string()
    }).strict(),
    z3.object({
      type: z3.literal("header"),
      key: z3.string(),
      value: z3.string().optional()
    }).strict(),
    z3.object({
      type: z3.literal("cookie"),
      key: z3.string(),
      value: z3.string().optional()
    }).strict(),
    z3.object({
      type: z3.literal("query"),
      key: z3.string(),
      value: z3.string().optional()
    }).strict()
  ])
).optional();
var vercelOutputConfigSchema = z3.object({
  version: z3.literal(3),
  routes: z3.array(
    z3.union([
      z3.object({
        src: z3.string(),
        dest: z3.string().optional(),
        headers: z3.record(z3.string()).optional(),
        methods: z3.array(z3.string()).optional(),
        status: z3.number().int().positive().optional(),
        continue: z3.boolean().optional(),
        check: z3.boolean().optional(),
        missing: HasOrMissing,
        has: HasOrMissing,
        locale: z3.object({
          redirect: z3.record(z3.string()).optional(),
          cookie: z3.string().optional()
        }).strict().optional(),
        middlewarePath: z3.string().optional()
      }).strict(),
      z3.object({
        handle: z3.union([
          z3.literal("rewrite"),
          z3.literal("filesystem"),
          z3.literal("resource"),
          z3.literal("miss"),
          z3.literal("hit"),
          z3.literal("error")
        ]),
        src: z3.string().optional(),
        dest: z3.string().optional(),
        status: z3.number().optional()
      }).strict()
    ])
  ).optional(),
  images: z3.object({
    sizes: z3.tuple([z3.number().int().positive(), z3.number().int().positive()]),
    domains: z3.array(z3.string()).nonempty().optional(),
    minimumCacheTTL: z3.number().int().positive().optional(),
    formats: z3.union([z3.literal("image/avif"), z3.literal("image/webp")]).array().nonempty().optional(),
    dangerouslyAllowSVG: z3.boolean().optional(),
    contentSecurityPolicy: z3.string().optional()
  }).strict().optional(),
  wildcard: z3.array(
    z3.object({
      domain: z3.string(),
      value: z3.string()
    }).strict()
  ).optional(),
  overrides: z3.record(
    z3.object({
      path: z3.string().optional(),
      contentType: z3.string().optional()
    }).strict()
  ).optional(),
  cache: z3.array(z3.string()).optional()
}).strict();

// src/config.ts
import fs2 from "node:fs/promises";
import {
  getTransformedRoutes,
  mergeRoutes,
  normalizeRoutes
} from "@vercel/routing-utils";
function reorderEnforce(arr) {
  return [
    ...arr.filter((r) => r.enforce === "pre"),
    ...arr.filter((r) => !r.enforce),
    ...arr.filter((r) => r.enforce === "post")
  ];
}
function getConfig(resolvedConfig, rewrites, overrides, headers) {
  const _rewrites = [
    // User provided config always comes first
    ...resolvedConfig.vercel?.rewrites ?? [],
    ...rewrites ?? []
  ];
  const _enforcedRewrites = reorderEnforce(_rewrites).map((r) => {
    r.source = r.source.replaceAll(/:\[(\.\.\.)(.*)\]/g, ":$2*");
    r.source = r.source.replaceAll(/:(\.\.\.)(.*)/g, ":$2+");
    return r;
  });
  const { routes, error } = getTransformedRoutes({
    cleanUrls: resolvedConfig.vercel?.cleanUrls ?? true,
    trailingSlash: resolvedConfig.vercel?.trailingSlash,
    rewrites: _enforcedRewrites,
    redirects: resolvedConfig.vercel?.redirects ? reorderEnforce(resolvedConfig.vercel?.redirects) : void 0,
    headers
  });
  if (error) {
    throw error;
  }
  if (resolvedConfig.vercel?.config?.routes && resolvedConfig.vercel.config.routes.length > 0 && !resolvedConfig.vercel.config.routes.every((r) => "continue" in r && r.continue)) {
    console.warn(
      'Did you forget to add `"continue": true` to your routes? See https://vercel.com/docs/build-output-api/v3/configuration#source-route\nIf not, it is discouraged to use `vercel.config.routes` to override routes. Prefer using `vercel.rewrites` and `vercel.redirects`.'
    );
  }
  let userRoutes = [];
  let buildRoutes = [];
  if (resolvedConfig.vercel?.config?.routes) {
    const norm = normalizeRoutes(resolvedConfig.vercel.config.routes);
    if (norm.error) {
      throw norm.error;
    }
    userRoutes = norm.routes ?? [];
  }
  if (routes) {
    const norm = normalizeRoutes(routes);
    if (norm.error) {
      throw norm.error;
    }
    buildRoutes = norm.routes ?? [];
  }
  const cleanRoutes = mergeRoutes({
    userRoutes,
    builds: [
      {
        use: "@vercel/node",
        entrypoint: "index.js",
        routes: buildRoutes
      }
    ]
  });
  return vercelOutputConfigSchema.parse({
    version: 3,
    ...resolvedConfig.vercel?.config,
    routes: cleanRoutes,
    overrides: {
      ...resolvedConfig.vercel?.config?.overrides,
      ...overrides
    }
  });
}
function getConfigDestination(resolvedConfig) {
  return path3.join(getOutput(resolvedConfig), "config.json");
}
async function writeConfig(resolvedConfig, rewrites, overrides, headers) {
  await fs2.writeFile(
    getConfigDestination(resolvedConfig),
    JSON.stringify(getConfig(resolvedConfig, rewrites, overrides, headers), void 0, 2),
    "utf-8"
  );
}

// src/helpers.ts
import fs3 from "node:fs/promises";
import path4 from "node:path";
async function copyDir(src, dest) {
  await fs3.mkdir(dest, { recursive: true });
  const entries = await fs3.readdir(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = path4.join(src, entry.name);
    const destPath = path4.join(dest, entry.name);
    entry.isDirectory() ? await copyDir(srcPath, destPath) : await fs3.copyFile(srcPath, destPath);
  }
}

// src/prerender.ts
import path5 from "node:path";

// src/schemas/config/prerender-config.ts
import { z as z4 } from "zod";
var vercelOutputPrerenderConfigSchema = z4.object({
  expiration: z4.union([z4.number().int().positive(), z4.literal(false)]),
  group: z4.number().int().optional(),
  bypassToken: z4.string().optional(),
  fallback: z4.string().optional(),
  allowQuery: z4.array(z4.string()).optional()
}).strict();

// src/prerender.ts
import fs4 from "node:fs/promises";
function execPrerender(resolvedConfig) {
  const prerender = resolvedConfig.vercel?.prerender;
  if (prerender === false) {
    return;
  }
  return prerender?.(resolvedConfig);
}
var group = 1;
async function writePrerenderConfig(resolvedConfig, destination, isr) {
  const parsed = path5.parse(destination);
  const outfile = path5.join(getOutput(resolvedConfig, "functions"), parsed.dir, `${parsed.name}.prerender-config.json`);
  await fs4.mkdir(path5.join(getOutput(resolvedConfig, "functions"), parsed.dir), { recursive: true });
  await fs4.writeFile(
    outfile,
    JSON.stringify(
      vercelOutputPrerenderConfigSchema.parse({
        group: group++,
        ...isr
      }),
      void 0,
      2
    ),
    "utf-8"
  );
}
function getPrerenderSymlinkInfo(resolvedConfig, destination, target) {
  const parsed = path5.parse(destination);
  const targetParsed = path5.parse(target);
  return {
    target: path5.join(getOutput(resolvedConfig, "functions"), targetParsed.dir, `${targetParsed.name}.func`),
    link: path5.join(getOutput(resolvedConfig, "functions"), parsed.dir, `${parsed.name}.func`)
  };
}
async function buildPrerenderConfigs(resolvedConfig, extractedIsr) {
  const isr = Object.assign({}, extractedIsr, await getIsrConfig(resolvedConfig));
  const entries = Object.entries(isr);
  const rewrites = [];
  for (const [destination, { symlink, route, ...isr2 }] of entries) {
    await writePrerenderConfig(resolvedConfig, destination, isr2);
    if (symlink) {
      const info = getPrerenderSymlinkInfo(resolvedConfig, destination, symlink);
      await copyDir(info.target, info.link);
    }
    if (route) {
      rewrites.push({
        source: `(${route})`,
        destination: `${destination}/?__original_path=$1`
      });
    }
  }
  return rewrites;
}
async function getIsrConfig(resolvedConfig) {
  const isr = resolvedConfig.vercel?.isr ?? {};
  if (typeof isr === "function") {
    return await isr();
  }
  return isr;
}

// src/index.ts
function vercelPluginCleanup() {
  let resolvedConfig;
  return {
    apply: "build",
    name: "vite-plugin-vercel:cleanup",
    enforce: "pre",
    configResolved(config) {
      resolvedConfig = config;
    },
    writeBundle: {
      order: "pre",
      sequential: true,
      async handler() {
        if (!resolvedConfig.build?.ssr) {
          await cleanOutputDirectory(resolvedConfig);
        }
      }
    }
  };
}
function vercelPlugin() {
  let resolvedConfig;
  let vikeFound = false;
  return {
    apply: "build",
    name: "vite-plugin-vercel",
    enforce: "post",
    configResolved(config) {
      resolvedConfig = config;
      vikeFound = resolvedConfig.plugins.some((p) => p.name.match("^vite-plugin-ssr:|^vike:"));
      if (typeof resolvedConfig.vercel?.distContainsOnlyStatic === "undefined") {
        resolvedConfig.vercel ??= {};
        resolvedConfig.vercel.distContainsOnlyStatic = !vikeFound;
      }
    },
    writeBundle: {
      order: "post",
      sequential: true,
      async handler() {
        if (!resolvedConfig.build?.ssr) {
          if (vikeFound) {
            return;
          }
        }
        const overrides = await execPrerender(resolvedConfig);
        const userOverrides = await computeStaticHtmlOverrides(resolvedConfig);
        const { rewrites, isr, headers } = await buildEndpoints(resolvedConfig);
        rewrites.push(...await buildPrerenderConfigs(resolvedConfig, isr));
        await writeConfig(
          resolvedConfig,
          rewrites,
          {
            ...userOverrides,
            ...overrides
          },
          headers
        );
        await copyDistToStatic(resolvedConfig);
      }
    }
  };
}
async function cleanOutputDirectory(resolvedConfig) {
  await fs5.rm(getOutput(resolvedConfig), {
    recursive: true,
    force: true
  });
  await fs5.mkdir(getOutput(resolvedConfig), { recursive: true });
}
async function copyDistToStatic(resolvedConfig) {
  if (resolvedConfig.vercel?.distContainsOnlyStatic) {
    await copyDir(resolvedConfig.build.outDir, getOutput(resolvedConfig, "static"));
  }
}
async function computeStaticHtmlOverrides(resolvedConfig) {
  const staticAbsolutePath = getOutput(resolvedConfig, "static");
  const files = await getStaticHtmlFiles(staticAbsolutePath);
  const publicDir = getPublic(resolvedConfig);
  const publicFiles = await getStaticHtmlFiles(publicDir);
  files.push(...publicFiles.map((f) => f.replace(publicDir, staticAbsolutePath)));
  return files.reduce(
    (acc, curr) => {
      const relPath = path6.relative(staticAbsolutePath, curr);
      const parsed = path6.parse(relPath);
      const pathJoined = path6.join(parsed.dir, parsed.name);
      acc[relPath] = {
        path: pathJoined
      };
      return acc;
    },
    {}
  );
}
async function getStaticHtmlFiles(src) {
  try {
    await fs5.stat(src);
  } catch (e) {
    return [];
  }
  const entries = await fs5.readdir(src, { withFileTypes: true });
  const htmlFiles = [];
  for (const entry of entries) {
    const srcPath = path6.join(src, entry.name);
    entry.isDirectory() ? htmlFiles.push(...await getStaticHtmlFiles(srcPath)) : srcPath.endsWith(".html") ? htmlFiles.push(srcPath) : void 0;
  }
  return htmlFiles;
}
async function tryImportVpvv(options) {
  try {
    await import("vike/plugin");
    const vpvv = await import("@vite-plugin-vercel/vike");
    return vpvv.default(options);
  } catch (e) {
    try {
      await import("vite-plugin-ssr/plugin");
      const vpvv = await import("@vite-plugin-vercel/vike");
      return vpvv.default(options);
    } catch (e2) {
      return null;
    }
  }
}
function allPlugins(options = {}) {
  const { smart, ...rest } = options;
  return [vercelPluginCleanup(), vercelPlugin(), smart !== false ? tryImportVpvv(rest) : null];
}
export {
  allPlugins as default
};
