import "./chunk-BFCEFRYA.js";

// node_modules/ios-vibrator-pro-max/dist/mergeVibrations.js
function mergeVibrations(patterns, startAtTime = "latest") {
  if (patterns.length === 0) {
    return [];
  }
  const normalizedPatterns = patterns.map(([start, intervals]) => [
    Math.round(start),
    intervals.map((interval) => Math.max(0, Math.round(interval)))
    // Ensure at least 1ms
  ]);
  const startTimes = normalizedPatterns.map(([start]) => start);
  const startTime = typeof startAtTime === "number" ? startAtTime : startAtTime === "first" ? Math.min(...startTimes) : Math.max(...startTimes);
  const endTimes = normalizedPatterns.map(([start, pattern]) => {
    return start + pattern.reduce((sum, dur) => sum + dur, 0);
  });
  const maxEndTime = Math.max(...endTimes);
  const timeline = new Array(maxEndTime - startTime).fill(false);
  normalizedPatterns.forEach(([patternStart, intervals]) => {
    let currentTime = patternStart;
    let isVibrating = true;
    for (const interval of intervals) {
      if (isVibrating) {
        const fromIndex = Math.max(0, currentTime - startTime);
        const toIndex = Math.max(0, Math.min(timeline.length, currentTime - startTime + interval));
        timeline.fill(true, fromIndex, toIndex);
      }
      currentTime += interval;
      isVibrating = !isVibrating;
    }
  });
  const result = [];
  const length = timeline.length;
  let currentState = timeline[0];
  let currentCount = 0;
  for (let i = 0; i <= length; i++) {
    const newState = i < length ? timeline[i] : !currentState;
    if (newState !== currentState) {
      if (currentCount > 0) {
        result.push(currentCount);
      }
      currentState = newState;
      currentCount = 1;
    } else {
      currentCount++;
    }
  }
  if (result.length > 0 && !timeline[0]) {
    result.unshift(0);
  }
  if (result.length > 0 && !timeline[timeline.length - 1]) {
    result.pop();
  }
  return result;
}
function trimVibrations(amount, patterns) {
  const result = [];
  let remainingAmount = amount;
  for (let i = 0; i < patterns.length; i++) {
    const currentVibration = patterns[i];
    if (remainingAmount > 0) {
      const remaining = currentVibration - remainingAmount;
      if (remaining > 0) {
        if (!result.length && i % 2) {
          result.push(0);
        }
        result.push(remaining);
        remainingAmount = 0;
      } else {
        remainingAmount = Math.abs(remaining);
      }
    } else {
      if (!result.length && i % 2) {
        result.push(0);
      }
      result.push(currentVibration);
    }
  }
  return result;
}

// node_modules/ios-vibrator-pro-max/dist/pro-max-vibrator.js
var SAFARI_VERSION = getSafariVersion();
var MAGIC_NUMBER = 26.26;
var GRANT_TIMEOUT = 1e3;
var polyfillKind = !navigator.vibrate && SAFARI_VERSION ? SAFARI_VERSION >= 18.4 ? "granted" : SAFARI_VERSION >= 18 ? "full" : null : null;
var trigger;
var timer;
var lastGrant = null;
var vibration = [Date.now(), []];
var blockMainThread = false;
function enableMainThreadBlocking(enabled) {
  blockMainThread = enabled;
}
function teachSafariHowToVibe(rawPatterns) {
  const patterns = typeof rawPatterns === "number" ? [rawPatterns] : [...rawPatterns];
  if (!patterns.length || patterns.some((pattern) => typeof pattern !== "number")) {
    return false;
  }
  vibration = [Date.now(), patterns];
  return true;
}
async function grantedVibrate() {
  lastGrant = Date.now();
  let adjustment = 0;
  while (true) {
    vibration = [
      Date.now(),
      trimVibrations(Date.now() - vibration[0], vibration[1])
    ];
    const [vibrateMs, waitMs] = vibration[1];
    if (vibrateMs == null) {
      if (!getTimeUntilGrantExpires()) {
        return;
      }
      await asyncWait(1);
      continue;
    }
    const vibrate = vibrateMs > 0;
    const waitTime = (vibrate ? MAGIC_NUMBER : waitMs ?? 0) + adjustment;
    if (vibrate) {
      trigger.click();
    }
    adjustment = await wait(waitTime);
  }
}
function getTimeUntilGrantExpires() {
  if (polyfillKind === "full") {
    return Infinity;
  }
  if (!lastGrant) {
    return 0;
  }
  return Math.max(0, GRANT_TIMEOUT - (Date.now() - lastGrant));
}
async function wait(duration) {
  const timeUntilGrantExpires = getTimeUntilGrantExpires();
  const grantTimeout = timeUntilGrantExpires - 150;
  if (blockMainThread && grantTimeout <= 0) {
    return blockingWait(duration);
  }
  if (!blockMainThread || grantTimeout > duration) {
    return asyncWait(duration);
  }
  const adjustment = await asyncWait(grantTimeout);
  const wait2 = duration - grantTimeout - adjustment;
  return blockingWait(wait2);
}
function blockingWait(ms) {
  if (ms < 0) {
    return ms;
  }
  const start = Date.now();
  while (Date.now() - start < ms) {
  }
  return 0;
}
async function asyncWait(ms) {
  const start = Date.now();
  await new Promise((resolve) => {
    clearTimeout(timer);
    timer = setTimeout(resolve, ms);
  });
  return ms - (Date.now() - start);
}
if (typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined" && polyfillKind) {
  let authorizeVibrations = function({ target }) {
    if (target === trigger || target === triggerInput) {
      return;
    }
    grantedVibrate();
  };
  navigator.vibrate = teachSafariHowToVibe;
  trigger = document.createElement("label");
  trigger.ariaHidden = "true";
  trigger.style.display = "none";
  const triggerInput = document.createElement("input");
  triggerInput.type = "checkbox";
  triggerInput.setAttribute("switch", "");
  trigger.appendChild(triggerInput);
  window.addEventListener("click", authorizeVibrations);
  window.addEventListener("touchend", authorizeVibrations);
  window.addEventListener("keyup", authorizeVibrations);
  window.addEventListener("keypress", authorizeVibrations);
  if (document.head) {
    document.head.appendChild(trigger);
  } else {
    setTimeout(() => document.head.appendChild(trigger), 0);
  }
}
function getSafariVersion() {
  const userAgent = navigator.userAgent;
  if (userAgent.indexOf("Safari") !== -1 && userAgent.indexOf("Chrome") === -1) {
    const versionRegex = /Version\/(\d+(\.\d+)?)/;
    const match = userAgent.match(versionRegex);
    if (match && match[1]) {
      return parseFloat(match[1]);
    }
  }
  return null;
}
export {
  enableMainThreadBlocking,
  mergeVibrations,
  trimVibrations
};
//# sourceMappingURL=ios-vibrator-pro-max.js.map
