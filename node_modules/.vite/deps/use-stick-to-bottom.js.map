{
  "version": 3,
  "sources": ["../../use-stick-to-bottom/dist/useStickToBottom.js", "../../use-stick-to-bottom/dist/StickToBottom.js"],
  "sourcesContent": ["/*!---------------------------------------------------------------------------------------------\n *  Copyright (c) StackBlitz. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { useCallback, useMemo, useRef, useState, } from \"react\";\nconst DEFAULT_SPRING_ANIMATION = {\n    /**\n     * A value from 0 to 1, on how much to damp the animation.\n     * 0 means no damping, 1 means full damping.\n     *\n     * @default 0.7\n     */\n    damping: 0.7,\n    /**\n     * The stiffness of how fast/slow the animation gets up to speed.\n     *\n     * @default 0.05\n     */\n    stiffness: 0.05,\n    /**\n     * The inertial mass associated with the animation.\n     * Higher numbers make the animation slower.\n     *\n     * @default 1.25\n     */\n    mass: 1.25,\n};\nconst STICK_TO_BOTTOM_OFFSET_PX = 70;\nconst SIXTY_FPS_INTERVAL_MS = 1000 / 60;\nconst RETAIN_ANIMATION_DURATION_MS = 350;\nlet mouseDown = false;\nglobalThis.document?.addEventListener(\"mousedown\", () => {\n    mouseDown = true;\n});\nglobalThis.document?.addEventListener(\"mouseup\", () => {\n    mouseDown = false;\n});\nglobalThis.document?.addEventListener(\"click\", () => {\n    mouseDown = false;\n});\nexport const useStickToBottom = (options = {}) => {\n    const [escapedFromLock, updateEscapedFromLock] = useState(false);\n    const [isAtBottom, updateIsAtBottom] = useState(options.initial !== false);\n    const [isNearBottom, setIsNearBottom] = useState(false);\n    const optionsRef = useRef(null);\n    optionsRef.current = options;\n    const isSelecting = useCallback(() => {\n        if (!mouseDown) {\n            return false;\n        }\n        const selection = window.getSelection();\n        if (!selection || !selection.rangeCount) {\n            return false;\n        }\n        const range = selection.getRangeAt(0);\n        return (range.commonAncestorContainer.contains(scrollRef.current) ||\n            scrollRef.current?.contains(range.commonAncestorContainer));\n    }, []);\n    const setIsAtBottom = useCallback((isAtBottom) => {\n        state.isAtBottom = isAtBottom;\n        updateIsAtBottom(isAtBottom);\n    }, []);\n    const setEscapedFromLock = useCallback((escapedFromLock) => {\n        state.escapedFromLock = escapedFromLock;\n        updateEscapedFromLock(escapedFromLock);\n    }, []);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: not needed\n    const state = useMemo(() => {\n        let lastCalculation;\n        return {\n            escapedFromLock,\n            isAtBottom,\n            resizeDifference: 0,\n            accumulated: 0,\n            velocity: 0,\n            listeners: new Set(),\n            get scrollTop() {\n                return scrollRef.current?.scrollTop ?? 0;\n            },\n            set scrollTop(scrollTop) {\n                if (scrollRef.current) {\n                    scrollRef.current.scrollTop = scrollTop;\n                    state.ignoreScrollToTop = scrollRef.current.scrollTop;\n                }\n            },\n            get targetScrollTop() {\n                if (!scrollRef.current || !contentRef.current) {\n                    return 0;\n                }\n                return (scrollRef.current.scrollHeight - 1 - scrollRef.current.clientHeight);\n            },\n            get calculatedTargetScrollTop() {\n                if (!scrollRef.current || !contentRef.current) {\n                    return 0;\n                }\n                const { targetScrollTop } = this;\n                if (!options.targetScrollTop) {\n                    return targetScrollTop;\n                }\n                if (lastCalculation?.targetScrollTop === targetScrollTop) {\n                    return lastCalculation.calculatedScrollTop;\n                }\n                const calculatedScrollTop = Math.max(Math.min(options.targetScrollTop(targetScrollTop, {\n                    scrollElement: scrollRef.current,\n                    contentElement: contentRef.current,\n                }), targetScrollTop), 0);\n                lastCalculation = { targetScrollTop, calculatedScrollTop };\n                requestAnimationFrame(() => {\n                    lastCalculation = undefined;\n                });\n                return calculatedScrollTop;\n            },\n            get scrollDifference() {\n                return this.calculatedTargetScrollTop - this.scrollTop;\n            },\n            get isNearBottom() {\n                return this.scrollDifference <= STICK_TO_BOTTOM_OFFSET_PX;\n            },\n        };\n    }, []);\n    const scrollToBottom = useCallback((scrollOptions = {}) => {\n        if (typeof scrollOptions === \"string\") {\n            scrollOptions = { animation: scrollOptions };\n        }\n        if (!scrollOptions.preserveScrollPosition) {\n            setIsAtBottom(true);\n        }\n        const waitElapsed = Date.now() + (Number(scrollOptions.wait) || 0);\n        const behavior = mergeAnimations(optionsRef.current, scrollOptions.animation);\n        const { ignoreEscapes = false } = scrollOptions;\n        let durationElapsed;\n        let startTarget = state.calculatedTargetScrollTop;\n        if (scrollOptions.duration instanceof Promise) {\n            scrollOptions.duration.finally(() => {\n                durationElapsed = Date.now();\n            });\n        }\n        else {\n            durationElapsed = waitElapsed + (scrollOptions.duration ?? 0);\n        }\n        const next = async () => {\n            const promise = new Promise(requestAnimationFrame).then(() => {\n                if (!state.isAtBottom) {\n                    state.animation = undefined;\n                    return false;\n                }\n                const { scrollTop } = state;\n                const tick = performance.now();\n                const tickDelta = (tick - (state.lastTick ?? tick)) / SIXTY_FPS_INTERVAL_MS;\n                state.animation || (state.animation = { behavior, promise, ignoreEscapes });\n                if (state.animation.behavior === behavior) {\n                    state.lastTick = tick;\n                }\n                if (isSelecting()) {\n                    return next();\n                }\n                if (waitElapsed > Date.now()) {\n                    return next();\n                }\n                if (scrollTop < Math.min(startTarget, state.calculatedTargetScrollTop)) {\n                    if (state.animation?.behavior === behavior) {\n                        if (behavior === \"instant\") {\n                            state.scrollTop = state.calculatedTargetScrollTop;\n                            return next();\n                        }\n                        state.velocity =\n                            (behavior.damping * state.velocity +\n                                behavior.stiffness * state.scrollDifference) /\n                                behavior.mass;\n                        state.accumulated += state.velocity * tickDelta;\n                        state.scrollTop += state.accumulated;\n                        if (state.scrollTop !== scrollTop) {\n                            state.accumulated = 0;\n                        }\n                    }\n                    return next();\n                }\n                if (durationElapsed > Date.now()) {\n                    startTarget = state.calculatedTargetScrollTop;\n                    return next();\n                }\n                state.animation = undefined;\n                /**\n                 * If we're still below the target, then queue\n                 * up another scroll to the bottom with the last\n                 * requested animatino.\n                 */\n                if (state.scrollTop < state.calculatedTargetScrollTop) {\n                    return scrollToBottom({\n                        animation: mergeAnimations(optionsRef.current, optionsRef.current.resize),\n                        ignoreEscapes,\n                        duration: Math.max(0, durationElapsed - Date.now()) || undefined,\n                    });\n                }\n                return state.isAtBottom;\n            });\n            return promise.then((isAtBottom) => {\n                requestAnimationFrame(() => {\n                    if (!state.animation) {\n                        state.lastTick = undefined;\n                        state.velocity = 0;\n                    }\n                });\n                return isAtBottom;\n            });\n        };\n        if (scrollOptions.wait !== true) {\n            state.animation = undefined;\n        }\n        if (state.animation?.behavior === behavior) {\n            return state.animation.promise;\n        }\n        return next();\n    }, [setIsAtBottom, isSelecting, state]);\n    const stopScroll = useCallback(() => {\n        setEscapedFromLock(true);\n        setIsAtBottom(false);\n    }, [setEscapedFromLock, setIsAtBottom]);\n    const handleScroll = useCallback(({ target }) => {\n        if (target !== scrollRef.current) {\n            return;\n        }\n        const { scrollTop, ignoreScrollToTop } = state;\n        let { lastScrollTop = scrollTop } = state;\n        state.lastScrollTop = scrollTop;\n        state.ignoreScrollToTop = undefined;\n        if (ignoreScrollToTop && ignoreScrollToTop > scrollTop) {\n            /**\n             * When the user scrolls up while the animation plays, the `scrollTop` may\n             * not come in separate events; if this happens, to make sure `isScrollingUp`\n             * is correct, set the lastScrollTop to the ignored event.\n             */\n            lastScrollTop = ignoreScrollToTop;\n        }\n        setIsNearBottom(state.isNearBottom);\n        /**\n         * Scroll events may come before a ResizeObserver event,\n         * so in order to ignore resize events correctly we use a\n         * timeout.\n         *\n         * @see https://github.com/WICG/resize-observer/issues/25#issuecomment-248757228\n         */\n        setTimeout(() => {\n            /**\n             * When theres a resize difference ignore the resize event.\n             */\n            if (state.resizeDifference || scrollTop === ignoreScrollToTop) {\n                return;\n            }\n            if (isSelecting()) {\n                setEscapedFromLock(true);\n                setIsAtBottom(false);\n                return;\n            }\n            const isScrollingDown = scrollTop > lastScrollTop;\n            const isScrollingUp = scrollTop < lastScrollTop;\n            if (state.animation?.ignoreEscapes) {\n                state.scrollTop = lastScrollTop;\n                return;\n            }\n            if (isScrollingUp) {\n                setEscapedFromLock(true);\n                setIsAtBottom(false);\n            }\n            if (isScrollingDown) {\n                setEscapedFromLock(false);\n            }\n            if (!state.escapedFromLock && state.isNearBottom) {\n                setIsAtBottom(true);\n            }\n        }, 1);\n    }, [setEscapedFromLock, setIsAtBottom, isSelecting, state]);\n    const handleWheel = useCallback(({ target, deltaY }) => {\n        let element = target;\n        while (![\"scroll\", \"auto\"].includes(getComputedStyle(element).overflow)) {\n            if (!element.parentElement) {\n                return;\n            }\n            element = element.parentElement;\n        }\n        /**\n         * The browser may cancel the scrolling from the mouse wheel\n         * if we update it from the animation in meantime.\n         * To prevent this, always escape when the wheel is scrolled up.\n         */\n        if (element === scrollRef.current &&\n            deltaY < 0 &&\n            scrollRef.current.scrollHeight > scrollRef.current.clientHeight &&\n            !state.animation?.ignoreEscapes) {\n            setEscapedFromLock(true);\n            setIsAtBottom(false);\n        }\n    }, [setEscapedFromLock, setIsAtBottom, state]);\n    const scrollRef = useRefCallback((scroll) => {\n        scrollRef.current?.removeEventListener(\"scroll\", handleScroll);\n        scrollRef.current?.removeEventListener(\"wheel\", handleWheel);\n        scroll?.addEventListener(\"scroll\", handleScroll, { passive: true });\n        scroll?.addEventListener(\"wheel\", handleWheel, { passive: true });\n    }, []);\n    const contentRef = useRefCallback((content) => {\n        state.resizeObserver?.disconnect();\n        if (!content) {\n            return;\n        }\n        let previousHeight;\n        state.resizeObserver = new ResizeObserver(([entry]) => {\n            const { height } = entry.contentRect;\n            const difference = height - (previousHeight ?? height);\n            state.resizeDifference = difference;\n            /**\n             * Sometimes the browser can overscroll past the target,\n             * so check for this and adjust appropriately.\n             */\n            if (state.scrollTop > state.targetScrollTop) {\n                state.scrollTop = state.targetScrollTop;\n            }\n            setIsNearBottom(state.isNearBottom);\n            if (difference >= 0) {\n                /**\n                 * If it's a positive resize, scroll to the bottom when\n                 * we're already at the bottom.\n                 */\n                const animation = mergeAnimations(optionsRef.current, previousHeight\n                    ? optionsRef.current.resize\n                    : optionsRef.current.initial);\n                scrollToBottom({\n                    animation,\n                    wait: true,\n                    preserveScrollPosition: true,\n                    duration: animation === \"instant\" ? undefined : RETAIN_ANIMATION_DURATION_MS,\n                });\n            }\n            else {\n                /**\n                 * Else if it's a negative resize, check if we're near the bottom\n                 * if we are want to un-escape from the lock, because the resize\n                 * could have caused the container to be at the bottom.\n                 */\n                if (state.isNearBottom) {\n                    setEscapedFromLock(false);\n                    setIsAtBottom(true);\n                }\n            }\n            previousHeight = height;\n            /**\n             * Reset the resize difference after the scroll event\n             * has fired. Requires a rAF to wait for the scroll event,\n             * and a setTimeout to wait for the other timeout we have in\n             * resizeObserver in case the scroll event happens after the\n             * resize event.\n             */\n            requestAnimationFrame(() => {\n                setTimeout(() => {\n                    if (state.resizeDifference === difference) {\n                        state.resizeDifference = 0;\n                    }\n                }, 1);\n            });\n        });\n        state.resizeObserver?.observe(content);\n    }, []);\n    return {\n        contentRef,\n        scrollRef,\n        scrollToBottom,\n        stopScroll,\n        isAtBottom: isAtBottom || isNearBottom,\n        isNearBottom,\n        escapedFromLock,\n        state,\n    };\n};\nfunction useRefCallback(callback, deps) {\n    // biome-ignore lint/correctness/useExhaustiveDependencies: not needed\n    const result = useCallback((ref) => {\n        result.current = ref;\n        return callback(ref);\n    }, deps);\n    return result;\n}\nconst animationCache = new Map();\nfunction mergeAnimations(...animations) {\n    const result = { ...DEFAULT_SPRING_ANIMATION };\n    let instant = false;\n    for (const animation of animations) {\n        if (animation === \"instant\") {\n            instant = true;\n            continue;\n        }\n        if (typeof animation !== \"object\") {\n            continue;\n        }\n        instant = false;\n        result.damping = animation.damping ?? result.damping;\n        result.stiffness = animation.stiffness ?? result.stiffness;\n        result.mass = animation.mass ?? result.mass;\n    }\n    const key = JSON.stringify(result);\n    if (!animationCache.has(key)) {\n        animationCache.set(key, Object.freeze(result));\n    }\n    return instant ? \"instant\" : animationCache.get(key);\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\n/*!---------------------------------------------------------------------------------------------\n *  Copyright (c) StackBlitz. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as React from \"react\";\nimport { createContext, useContext, useEffect, useImperativeHandle, useLayoutEffect, useMemo, useRef, } from \"react\";\nimport { useStickToBottom, } from \"./useStickToBottom.js\";\nconst StickToBottomContext = createContext(null);\nconst useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\nexport function StickToBottom({ instance, children, resize, initial, mass, damping, stiffness, targetScrollTop: currentTargetScrollTop, contextRef, ...props }) {\n    const customTargetScrollTop = useRef(null);\n    const targetScrollTop = React.useCallback((target, elements) => {\n        const get = context?.targetScrollTop ?? currentTargetScrollTop;\n        return get?.(target, elements) ?? target;\n    }, [currentTargetScrollTop]);\n    const defaultInstance = useStickToBottom({\n        mass,\n        damping,\n        stiffness,\n        resize,\n        initial,\n        targetScrollTop,\n    });\n    const { scrollRef, contentRef, scrollToBottom, stopScroll, isAtBottom, escapedFromLock, state, } = instance ?? defaultInstance;\n    const context = useMemo(() => ({\n        scrollToBottom,\n        stopScroll,\n        scrollRef,\n        isAtBottom,\n        escapedFromLock,\n        contentRef,\n        state,\n        get targetScrollTop() {\n            return customTargetScrollTop.current;\n        },\n        set targetScrollTop(targetScrollTop) {\n            customTargetScrollTop.current = targetScrollTop;\n        },\n    }), [\n        scrollToBottom,\n        isAtBottom,\n        contentRef,\n        scrollRef,\n        stopScroll,\n        escapedFromLock,\n        state,\n    ]);\n    useImperativeHandle(contextRef, () => context, [context]);\n    useIsomorphicLayoutEffect(() => {\n        if (!scrollRef.current) {\n            return;\n        }\n        if (getComputedStyle(scrollRef.current).overflow === \"visible\") {\n            scrollRef.current.style.overflow = \"auto\";\n        }\n    }, []);\n    return (_jsx(StickToBottomContext.Provider, { value: context, children: _jsx(\"div\", { ...props, children: typeof children === \"function\" ? children(context) : children }) }));\n}\n(function (StickToBottom) {\n    function Content({ children, ...props }) {\n        const context = useStickToBottomContext();\n        return (_jsx(\"div\", { ref: context.scrollRef, style: {\n                height: \"100%\",\n                width: \"100%\",\n            }, children: _jsx(\"div\", { ...props, ref: context.contentRef, children: typeof children === \"function\" ? children(context) : children }) }));\n    }\n    StickToBottom.Content = Content;\n})(StickToBottom || (StickToBottom = {}));\n/**\n * Use this hook inside a <StickToBottom> component to gain access to whether the component is at the bottom of the scrollable area.\n */\nexport function useStickToBottomContext() {\n    const context = useContext(StickToBottomContext);\n    if (!context) {\n        throw new Error(\"use-stick-to-bottom component context must be used within a StickToBottom component\");\n    }\n    return context;\n}\n"],
  "mappings": "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",
  "names": ["_a", "isAtBottom", "escapedFromLock", "import_react", "targetScrollTop", "_jsx", "StickToBottom"]
}
