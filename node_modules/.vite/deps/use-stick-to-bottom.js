import {
  require_jsx_runtime
} from "./chunk-BYMS7Q2E.js";
import {
  require_react
} from "./chunk-EVDGXMUC.js";
import {
  __toESM
} from "./chunk-BFCEFRYA.js";

// node_modules/use-stick-to-bottom/dist/useStickToBottom.js
var import_react = __toESM(require_react(), 1);
var DEFAULT_SPRING_ANIMATION = {
  /**
   * A value from 0 to 1, on how much to damp the animation.
   * 0 means no damping, 1 means full damping.
   *
   * @default 0.7
   */
  damping: 0.7,
  /**
   * The stiffness of how fast/slow the animation gets up to speed.
   *
   * @default 0.05
   */
  stiffness: 0.05,
  /**
   * The inertial mass associated with the animation.
   * Higher numbers make the animation slower.
   *
   * @default 1.25
   */
  mass: 1.25
};
var STICK_TO_BOTTOM_OFFSET_PX = 70;
var SIXTY_FPS_INTERVAL_MS = 1e3 / 60;
var RETAIN_ANIMATION_DURATION_MS = 350;
var mouseDown = false;
var _a;
(_a = globalThis.document) == null ? void 0 : _a.addEventListener("mousedown", () => {
  mouseDown = true;
});
var _a2;
(_a2 = globalThis.document) == null ? void 0 : _a2.addEventListener("mouseup", () => {
  mouseDown = false;
});
var _a3;
(_a3 = globalThis.document) == null ? void 0 : _a3.addEventListener("click", () => {
  mouseDown = false;
});
var useStickToBottom = (options = {}) => {
  const [escapedFromLock, updateEscapedFromLock] = (0, import_react.useState)(false);
  const [isAtBottom, updateIsAtBottom] = (0, import_react.useState)(options.initial !== false);
  const [isNearBottom, setIsNearBottom] = (0, import_react.useState)(false);
  const optionsRef = (0, import_react.useRef)(null);
  optionsRef.current = options;
  const isSelecting = (0, import_react.useCallback)(() => {
    var _a4;
    if (!mouseDown) {
      return false;
    }
    const selection = window.getSelection();
    if (!selection || !selection.rangeCount) {
      return false;
    }
    const range = selection.getRangeAt(0);
    return range.commonAncestorContainer.contains(scrollRef.current) || ((_a4 = scrollRef.current) == null ? void 0 : _a4.contains(range.commonAncestorContainer));
  }, []);
  const setIsAtBottom = (0, import_react.useCallback)((isAtBottom2) => {
    state.isAtBottom = isAtBottom2;
    updateIsAtBottom(isAtBottom2);
  }, []);
  const setEscapedFromLock = (0, import_react.useCallback)((escapedFromLock2) => {
    state.escapedFromLock = escapedFromLock2;
    updateEscapedFromLock(escapedFromLock2);
  }, []);
  const state = (0, import_react.useMemo)(() => {
    let lastCalculation;
    return {
      escapedFromLock,
      isAtBottom,
      resizeDifference: 0,
      accumulated: 0,
      velocity: 0,
      listeners: /* @__PURE__ */ new Set(),
      get scrollTop() {
        var _a4;
        return ((_a4 = scrollRef.current) == null ? void 0 : _a4.scrollTop) ?? 0;
      },
      set scrollTop(scrollTop) {
        if (scrollRef.current) {
          scrollRef.current.scrollTop = scrollTop;
          state.ignoreScrollToTop = scrollRef.current.scrollTop;
        }
      },
      get targetScrollTop() {
        if (!scrollRef.current || !contentRef.current) {
          return 0;
        }
        return scrollRef.current.scrollHeight - 1 - scrollRef.current.clientHeight;
      },
      get calculatedTargetScrollTop() {
        if (!scrollRef.current || !contentRef.current) {
          return 0;
        }
        const { targetScrollTop } = this;
        if (!options.targetScrollTop) {
          return targetScrollTop;
        }
        if ((lastCalculation == null ? void 0 : lastCalculation.targetScrollTop) === targetScrollTop) {
          return lastCalculation.calculatedScrollTop;
        }
        const calculatedScrollTop = Math.max(Math.min(options.targetScrollTop(targetScrollTop, {
          scrollElement: scrollRef.current,
          contentElement: contentRef.current
        }), targetScrollTop), 0);
        lastCalculation = { targetScrollTop, calculatedScrollTop };
        requestAnimationFrame(() => {
          lastCalculation = void 0;
        });
        return calculatedScrollTop;
      },
      get scrollDifference() {
        return this.calculatedTargetScrollTop - this.scrollTop;
      },
      get isNearBottom() {
        return this.scrollDifference <= STICK_TO_BOTTOM_OFFSET_PX;
      }
    };
  }, []);
  const scrollToBottom = (0, import_react.useCallback)((scrollOptions = {}) => {
    var _a4;
    if (typeof scrollOptions === "string") {
      scrollOptions = { animation: scrollOptions };
    }
    if (!scrollOptions.preserveScrollPosition) {
      setIsAtBottom(true);
    }
    const waitElapsed = Date.now() + (Number(scrollOptions.wait) || 0);
    const behavior = mergeAnimations(optionsRef.current, scrollOptions.animation);
    const { ignoreEscapes = false } = scrollOptions;
    let durationElapsed;
    let startTarget = state.calculatedTargetScrollTop;
    if (scrollOptions.duration instanceof Promise) {
      scrollOptions.duration.finally(() => {
        durationElapsed = Date.now();
      });
    } else {
      durationElapsed = waitElapsed + (scrollOptions.duration ?? 0);
    }
    const next = async () => {
      const promise = new Promise(requestAnimationFrame).then(() => {
        var _a5;
        if (!state.isAtBottom) {
          state.animation = void 0;
          return false;
        }
        const { scrollTop } = state;
        const tick = performance.now();
        const tickDelta = (tick - (state.lastTick ?? tick)) / SIXTY_FPS_INTERVAL_MS;
        state.animation || (state.animation = { behavior, promise, ignoreEscapes });
        if (state.animation.behavior === behavior) {
          state.lastTick = tick;
        }
        if (isSelecting()) {
          return next();
        }
        if (waitElapsed > Date.now()) {
          return next();
        }
        if (scrollTop < Math.min(startTarget, state.calculatedTargetScrollTop)) {
          if (((_a5 = state.animation) == null ? void 0 : _a5.behavior) === behavior) {
            if (behavior === "instant") {
              state.scrollTop = state.calculatedTargetScrollTop;
              return next();
            }
            state.velocity = (behavior.damping * state.velocity + behavior.stiffness * state.scrollDifference) / behavior.mass;
            state.accumulated += state.velocity * tickDelta;
            state.scrollTop += state.accumulated;
            if (state.scrollTop !== scrollTop) {
              state.accumulated = 0;
            }
          }
          return next();
        }
        if (durationElapsed > Date.now()) {
          startTarget = state.calculatedTargetScrollTop;
          return next();
        }
        state.animation = void 0;
        if (state.scrollTop < state.calculatedTargetScrollTop) {
          return scrollToBottom({
            animation: mergeAnimations(optionsRef.current, optionsRef.current.resize),
            ignoreEscapes,
            duration: Math.max(0, durationElapsed - Date.now()) || void 0
          });
        }
        return state.isAtBottom;
      });
      return promise.then((isAtBottom2) => {
        requestAnimationFrame(() => {
          if (!state.animation) {
            state.lastTick = void 0;
            state.velocity = 0;
          }
        });
        return isAtBottom2;
      });
    };
    if (scrollOptions.wait !== true) {
      state.animation = void 0;
    }
    if (((_a4 = state.animation) == null ? void 0 : _a4.behavior) === behavior) {
      return state.animation.promise;
    }
    return next();
  }, [setIsAtBottom, isSelecting, state]);
  const stopScroll = (0, import_react.useCallback)(() => {
    setEscapedFromLock(true);
    setIsAtBottom(false);
  }, [setEscapedFromLock, setIsAtBottom]);
  const handleScroll = (0, import_react.useCallback)(({ target }) => {
    if (target !== scrollRef.current) {
      return;
    }
    const { scrollTop, ignoreScrollToTop } = state;
    let { lastScrollTop = scrollTop } = state;
    state.lastScrollTop = scrollTop;
    state.ignoreScrollToTop = void 0;
    if (ignoreScrollToTop && ignoreScrollToTop > scrollTop) {
      lastScrollTop = ignoreScrollToTop;
    }
    setIsNearBottom(state.isNearBottom);
    setTimeout(() => {
      var _a4;
      if (state.resizeDifference || scrollTop === ignoreScrollToTop) {
        return;
      }
      if (isSelecting()) {
        setEscapedFromLock(true);
        setIsAtBottom(false);
        return;
      }
      const isScrollingDown = scrollTop > lastScrollTop;
      const isScrollingUp = scrollTop < lastScrollTop;
      if ((_a4 = state.animation) == null ? void 0 : _a4.ignoreEscapes) {
        state.scrollTop = lastScrollTop;
        return;
      }
      if (isScrollingUp) {
        setEscapedFromLock(true);
        setIsAtBottom(false);
      }
      if (isScrollingDown) {
        setEscapedFromLock(false);
      }
      if (!state.escapedFromLock && state.isNearBottom) {
        setIsAtBottom(true);
      }
    }, 1);
  }, [setEscapedFromLock, setIsAtBottom, isSelecting, state]);
  const handleWheel = (0, import_react.useCallback)(({ target, deltaY }) => {
    var _a4;
    let element = target;
    while (!["scroll", "auto"].includes(getComputedStyle(element).overflow)) {
      if (!element.parentElement) {
        return;
      }
      element = element.parentElement;
    }
    if (element === scrollRef.current && deltaY < 0 && scrollRef.current.scrollHeight > scrollRef.current.clientHeight && !((_a4 = state.animation) == null ? void 0 : _a4.ignoreEscapes)) {
      setEscapedFromLock(true);
      setIsAtBottom(false);
    }
  }, [setEscapedFromLock, setIsAtBottom, state]);
  const scrollRef = useRefCallback((scroll) => {
    var _a4, _b;
    (_a4 = scrollRef.current) == null ? void 0 : _a4.removeEventListener("scroll", handleScroll);
    (_b = scrollRef.current) == null ? void 0 : _b.removeEventListener("wheel", handleWheel);
    scroll == null ? void 0 : scroll.addEventListener("scroll", handleScroll, { passive: true });
    scroll == null ? void 0 : scroll.addEventListener("wheel", handleWheel, { passive: true });
  }, []);
  const contentRef = useRefCallback((content) => {
    var _a4, _b;
    (_a4 = state.resizeObserver) == null ? void 0 : _a4.disconnect();
    if (!content) {
      return;
    }
    let previousHeight;
    state.resizeObserver = new ResizeObserver(([entry]) => {
      const { height } = entry.contentRect;
      const difference = height - (previousHeight ?? height);
      state.resizeDifference = difference;
      if (state.scrollTop > state.targetScrollTop) {
        state.scrollTop = state.targetScrollTop;
      }
      setIsNearBottom(state.isNearBottom);
      if (difference >= 0) {
        const animation = mergeAnimations(optionsRef.current, previousHeight ? optionsRef.current.resize : optionsRef.current.initial);
        scrollToBottom({
          animation,
          wait: true,
          preserveScrollPosition: true,
          duration: animation === "instant" ? void 0 : RETAIN_ANIMATION_DURATION_MS
        });
      } else {
        if (state.isNearBottom) {
          setEscapedFromLock(false);
          setIsAtBottom(true);
        }
      }
      previousHeight = height;
      requestAnimationFrame(() => {
        setTimeout(() => {
          if (state.resizeDifference === difference) {
            state.resizeDifference = 0;
          }
        }, 1);
      });
    });
    (_b = state.resizeObserver) == null ? void 0 : _b.observe(content);
  }, []);
  return {
    contentRef,
    scrollRef,
    scrollToBottom,
    stopScroll,
    isAtBottom: isAtBottom || isNearBottom,
    isNearBottom,
    escapedFromLock,
    state
  };
};
function useRefCallback(callback, deps) {
  const result = (0, import_react.useCallback)((ref) => {
    result.current = ref;
    return callback(ref);
  }, deps);
  return result;
}
var animationCache = /* @__PURE__ */ new Map();
function mergeAnimations(...animations) {
  const result = { ...DEFAULT_SPRING_ANIMATION };
  let instant = false;
  for (const animation of animations) {
    if (animation === "instant") {
      instant = true;
      continue;
    }
    if (typeof animation !== "object") {
      continue;
    }
    instant = false;
    result.damping = animation.damping ?? result.damping;
    result.stiffness = animation.stiffness ?? result.stiffness;
    result.mass = animation.mass ?? result.mass;
  }
  const key = JSON.stringify(result);
  if (!animationCache.has(key)) {
    animationCache.set(key, Object.freeze(result));
  }
  return instant ? "instant" : animationCache.get(key);
}

// node_modules/use-stick-to-bottom/dist/StickToBottom.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var StickToBottomContext = (0, import_react2.createContext)(null);
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
function StickToBottom({ instance, children, resize, initial, mass, damping, stiffness, targetScrollTop: currentTargetScrollTop, contextRef, ...props }) {
  const customTargetScrollTop = (0, import_react2.useRef)(null);
  const targetScrollTop = React.useCallback((target, elements) => {
    const get = (context == null ? void 0 : context.targetScrollTop) ?? currentTargetScrollTop;
    return (get == null ? void 0 : get(target, elements)) ?? target;
  }, [currentTargetScrollTop]);
  const defaultInstance = useStickToBottom({
    mass,
    damping,
    stiffness,
    resize,
    initial,
    targetScrollTop
  });
  const { scrollRef, contentRef, scrollToBottom, stopScroll, isAtBottom, escapedFromLock, state } = instance ?? defaultInstance;
  const context = (0, import_react2.useMemo)(() => ({
    scrollToBottom,
    stopScroll,
    scrollRef,
    isAtBottom,
    escapedFromLock,
    contentRef,
    state,
    get targetScrollTop() {
      return customTargetScrollTop.current;
    },
    set targetScrollTop(targetScrollTop2) {
      customTargetScrollTop.current = targetScrollTop2;
    }
  }), [
    scrollToBottom,
    isAtBottom,
    contentRef,
    scrollRef,
    stopScroll,
    escapedFromLock,
    state
  ]);
  (0, import_react2.useImperativeHandle)(contextRef, () => context, [context]);
  useIsomorphicLayoutEffect(() => {
    if (!scrollRef.current) {
      return;
    }
    if (getComputedStyle(scrollRef.current).overflow === "visible") {
      scrollRef.current.style.overflow = "auto";
    }
  }, []);
  return (0, import_jsx_runtime.jsx)(StickToBottomContext.Provider, { value: context, children: (0, import_jsx_runtime.jsx)("div", { ...props, children: typeof children === "function" ? children(context) : children }) });
}
(function(StickToBottom2) {
  function Content({ children, ...props }) {
    const context = useStickToBottomContext();
    return (0, import_jsx_runtime.jsx)("div", { ref: context.scrollRef, style: {
      height: "100%",
      width: "100%"
    }, children: (0, import_jsx_runtime.jsx)("div", { ...props, ref: context.contentRef, children: typeof children === "function" ? children(context) : children }) });
  }
  StickToBottom2.Content = Content;
})(StickToBottom || (StickToBottom = {}));
function useStickToBottomContext() {
  const context = (0, import_react2.useContext)(StickToBottomContext);
  if (!context) {
    throw new Error("use-stick-to-bottom component context must be used within a StickToBottom component");
  }
  return context;
}
export {
  StickToBottom,
  useStickToBottom,
  useStickToBottomContext
};
/*! Bundled license information:

use-stick-to-bottom/dist/useStickToBottom.js:
use-stick-to-bottom/dist/StickToBottom.js:
  (*!---------------------------------------------------------------------------------------------
   *  Copyright (c) StackBlitz. All rights reserved.
   *  Licensed under the MIT License. See License.txt in the project root for license information.
   *--------------------------------------------------------------------------------------------*)
*/
//# sourceMappingURL=use-stick-to-bottom.js.map
